






















                       Операционная система QNX 4

                        Руководство пользователя


                                - 2 -

                          ОБ ЭТОМ РУКОВОДСТВЕ

       Что я найду в этом руководстве?

       Руководство пользователя операционной системы QNX сопровождает
  операционную систему QNX (версия) и предназначено как для Системных
  администраторов, так и для конечных пользователей.

       Руководство пользователя содержит две основные части:

       Подготовка к работе - краткое описание использования клавиату-
  ры, базовых команд и файловой системы QNX.
       Управление системой -  подробное  описание  установки,  выбора
  конфигурации и обслуживания Вашей системы.

       ВНИМАНИЕ. В пределах этого руководства, мы допускаем, что, как
  Администратор системы,  Вы имеете привилегии суперпользователя, ко-
  торые приобретаете при входе в систему, используя идентификатор ro-
  ot.

                          _Условные обозначения

                          Технические термины


       В пределах этого руководства мы используем определенные услов-
   ные обозначения,  чтобы различить технические термины. В основном,
   условные обозначения,  которые мы используем, соответствуют услов-
   ным обозначениям,  примененным в публикациях IEEE  POSIX.  Примеры
   условных обозначений сведены в следующую таблицу:

   ───────────────────────────────────────────────────────────────────
   Термины                           Пример  обозначения

   ───────────────────────────────────────────────────────────────────
   Имена команд                            ls
   Типы данных                             long
   Переменные среды                        PATH
   Номера ошибок                           [EINTR]
   Имена файлов                            /dev/ tty()
   Функции                                 system ()
   Аргументы функций                       arg1
   Глобальные переменные                   errno
   Заголовочные файлы                      <sys/stat.h>

                                - 3 -
   ───────────────────────────────────────────────────────────────────
   Термины                           Пример  обозначения
   ───────────────────────────────────────────────────────────────────
   Опции                                   -c
   Аргументы опций                         -w width
   Операнды                                file_name
   Параметры                               <directory pathname>
   Символические константы                 {_POSIX_VDISABLE}
   ───────────────────────────────────────────────────────────────────

                   Как изображаются клавиши в тексте

       Названия клавиш клавиатуры заключены в угловые скобки.  Напри-
  мер, если руководство указывает Вам:

                           нажмите <Enter>

       Вы должны нажать клавишу Enter.

                           Сочетания клавиш

       Нажатие более  чем  одной  клавиши одновременно представлено в
  виде последовательности названий клавиш,  разделенных  дефисом (-).
       Например, если Вы видите:

                           нажмите <Ctrl>-<N>

       Вы должны:
   1) нажать <Ctrl> и, не отпуская клавишу,
   2) нажать <N>,
   3) быстро отпустить обе клавиши.

                              Ввод текста

       Когда это руководство предписывает Вам ввести  текст  с  Вашей
  клавиатуры,  текст, который Вы будете набирать, указывается шрифтом
  постоянной ширины. Например, если Вы видите:

       Введите pwd

       Вы должны набрать:

                           pwd



                                - 4 -
                           Важные замечания

       Важный текст выделяется словом ВНИМАНИЕ. Например:

       ВНИМАНИЕ. Если  Вы хотите переместить файл из каталога другого
                 пользователя,  Вы должны для начала иметь  соответс-
                 твующее разрешение на этот каталог.


                              СОДЕРЖАНИЕ

   Об этом руководстве

   Часть I. Подготовка к работе

   Глава 1. Использование клавиатуры                             11

   1.1.  Введение                                                11
   1.2.  Ввод строк                                              11
           1.2.1. Клавиши редактора строк                        11
           1.2.2. Максимальная длина входной строки              13
           1.2.3. Ввод длинных строк                             13
   1.3. Повторение команд                                        13
   1.4. Переключение виртуальных консолей                        13
   1.5. Использование нескольких консолей                        14
   1.6. Изменение консольных шрифтов                             15
   1.7. Задержка и продолжение вывода данных                     16
   1.8. Прекращение процесса                                     16
   1.9. Вызов системного отладчика                               16
   1.10. Перезагрузка                                            16
   1.11. Международные клавиатуры                                17
   1.12. Клавиатура в первом приближении                         17

   Глава 2. Основные команды языка                               19

   2.1. Синтаксис команд                                         19
           2.1.1. Синтаксическая структура                       19
           2.1.2. Символы клавиш                                 20
           2.1.3. Группирование опций                            21
           2.1.4. Пометка специальных символов                   21
   2.2. Переадресование ввода-вывода                             23
   2.3. Выполнение команд на другом узле или устройстве          24
   2.4. Отображение cистемных сообщений                          25
   2.5. Использование шаблонов                                   25
   2.6. Ввод нескольких команд                                   26

                                - 5 -

   2.7. Сведения о командах интерпретатора                       27
   2.8. Дополнительная информация                                27

   Глава 3. Работа с файловой системой QNX                       29

   3.1. Введение                                                 29
   3.2. Имена файлов                                             29
           3.2.1. Мобильные имена файлов                         29
           3.2.2. Суффиксы имени файла                           30
   3.3. Полные имена                                             30
           3.3.1. Полные имена в сети                            30
           3.3.2. Текущий рабочий каталог                        31
           3.3.3. Каталог home                                   31
   3.4. Типичная файловая система QNX                            31
   3.5. Часто используемые утилиты                               33

   Часть II. Управление системой                                 34

   Глава 4. Основная установка                                   34

   4.1. Установка QNX на жестком диске                           34
   4.2. Установка дополнительного программного обеспечения       35
   4.3. Файл системной инициализации                             36
           4.3.1. Что происходит, когда Вы загружаете QNX        36
   4.4. Использование файла системной инициализации              39
           4.4.1. Основные сервисные средства                    39
           4.4.2. Дополнительные сервисные средства              41
           4.4.3. Поддержка не USA-клавиатуры                    43
   4.5. Часовые пояса и часы реального времени                   43
           4.5.1. Установка часового пояса                       43
           4.5.2. Получение даты и времени с часов реального
                  времени                                        44
   4.6. Лицензирование                                           45
           4.6.1. Лицензирование операционной системы            45
           4.6.2. Лицензирование приложений                      46
           4.6.3. Расширение Вашей лицензии                      46

   Глава 5. Установка сети                                       48

   5.1. Введение                                                 48

           5.1.1. Логические узловые ID                          48
           5.1.2. Логические сетевые ID                          48
           5.1.3. Физические узловые ID                          49

                                - 6 -

   5.2. Об установке                                             49
           5.2.1. Сетевые драйверы                               49
           5.2.2. Определение физических узловых ID              49
           5.2.3. Присвоение логических узловых ID               50
           5.2.4. Серверы загрузки и рабочие станции             51
           5.2.5. Планирование Вашей сети                        51
   5.3. Выбор конфигурации сервера загрузки                      52
   5.4. Выбор конфигурации рабочей станции                       56

  Глава 6. Ввод учитываемых пользователей                        58

   6.1. Безопасность                                             58
           6.1.1. Утилиты управления доступом                    58
           6.1.2. ID пользователя и группы                       60
           6.1.3. Атрибуты доступа файлов                        61
           6.1.4. База данных паролей                            65
           6.1.5. Файлы паролей по умолчанию                     67
   6.2. Файл регистрации                                         67
           6.2.1. Включение регистрации                          67
           6.2.2. Формат записи                                  67
           6.2.3. Очистка файла регистрации                      69

   Глава 7. Подключение терминалов, принтеров и модемов          71

   7.1. Запуск драйверов устройств                               71
   7.2. Параллельные устройства                                  71
           7.2.1. Единственный параллельный порт                 71
           7.2.2. Несколько параллельных портов                  72
           7.2.3. Буфера вывода                                  72
   7.3. Последовательные устройства                              72
           7.3.1. Аппаратные адаптеры                            72
           7.3.2. Последовательный протокол RS-232               74
           7.3.3. Выбор конфигурации последовательных портов     77
           7.3.4. Соединение последовательных устройств          78
           7.3.5. Выбор конфигурации последовательных линий для
                  терминалов и пользователей                     82
           7.3.6. Проблемы тестирования последовательных
                  устройств                                      86

   Глава 8. Установка второй файловой системы                    88

   8.1. Введение                                                 88
   8.2. Разделение пространства полных имен                      88
           8.2.1. Жесткий диск и флоппи-дискета                  88

                                - 7 -

           8.2.2. Два жестких диска (на одном узле)              89
           8.2.3. Два или более разделов QNX                     89
           8.2.4. Локальные и удаленные жесткие диски            90
   8.3. Установка файловой системы DOS                           91
           8.3.1. Режимы вызова                                  92
           8.3.2. Запуск Dosfsys                                 92
           8.3.3.  Восприятие имен Dosfsys                       93
           8.3.4.  Устройства DOS                                93
           8.3.5.  Поддерживаемые версии DOS                     94
           8.3.6.  Текстовые файлы DOS                           94
           8.3.7.  Двоичные файлы DOS                            94
           8.3.8.  Преобразование символов и имен из QNX в DOS   95
           8.3.9.  Метки тома DOS                                96
           8.3.10. Преобразование атрибутов доступа DOS/QNX      96
           8.3.11. Владелец файла                                97
           8.3.12. Завершение Dosfsys                            97
           8.3.13. Коды ошибок, возвращаемые Dosfsys             97

   Глава 9. Развитие конфигурации сети                           99

   9.1. Введение                                                 99
   9.2. Множество серверов загрузки                              99
           9.2.1. Широковещательная загрузка с ПЗУ QNX           99
           9.2.2. Выполнение утилиты netboot                    100
   9.3. Многосвязная сеть                                       101
           9.3.1. Преимущества                                  101
           9.3.2. Коммуникация через сети                       102
   9.4. Выбор конфигурации многосвязной сети                    103
           9.4.1. Установка сетевых плат                        103
           9.4.2. Запуск сетевых драйверов                      104
           9.4.3. Редактирование файла netmap                   106
           9.4.4. Редактирование файла netboot                  106
           9.4.5. Примеры                                       107

   Глава 10. Буферизация печати                                 112

   10.1. Введение
           10.1.1. Разделение ресурсов в сети                   112
           10.1.2. Буферизация                                  112
   10.2. Использование утилит буферизации                       113
           10.2.1. Запуск системы буферизации                   113
           10.2.2. Представление заданий на буферизацию         114
           10.2.3. Организация очереди на буферизацию           114

                                - 8 -

           10.2.4. Отмена заданий на буферизацию                114
           10.2.5. Управление очередями на буферизацию          115
   10.3. Архитектура системы буферизации                        115
   10.4. Файл установки буферизации                             119
           10.4.1. Синтаксические определения                   119
           10.4.2. Глобальные ключевые слова                    121
           10.4.3. Метапеременные                               123
           10.4.4. Действия по умолчанию                        123
   10.5. Использование файлов установки                         124
           10.5.1. Очереди и адресаты                           124
           10.5.2. Фильтры                                      125
           10.5.3. Сцепление очередей                           126
           10.5.4. Регистрация информации                       126
           10.5.5. Трактовка ошибок                             126
   10.6. Примеры файлов установки                               127
           10.6.1. Несколько очередей к одному адресату         127
           10.6.2. Несколько очередей к трем адресатам          128
   10.7. Доступ к программам буферизации и очередям             130
           10.7.1. Переменные LPSRVR и LPDEST                   130
           10.7.2. Примеры                                      131
           10.7.3. Файлы инициализации                          133

   Глава 11. Построение заданного образа операционной системы   134

   11.1. Введение                                               134
   11.2. Создание файла построения                              134
           11.2.1. Установка размеров памяти в динамической
                   области                                      135
           11.2.2. Установка приоритетов                        135
           11.2.3. Выбор процессов для образа                   135
           11.2.4. Образы диска                                 136
           11.2.5. Сетевые образы                               138
           11.2.6. Встроенные образы                            138

   Глава 12. Использование системы управления версиями          140

   12.1. Что такое RCS?                                         140
   12.2. Подготовка к работе                                    141
           12.2.1. Сохранение                                   141
           12.2.2. Извлечение                                   141
           12.2.3. Блокирование файлов                          142
           12.2.4. Создание RCS-каталога                        143
           12.2.5. Защита Вашего рабочего файла                 143
           12.2.6. Присваивание номеров исправлений             143

                                - 9 -

   12.3. Автоматическая идентификация                           144
           12.3.1. Дополнительная информация                    145
   12.4. Формат RCS-файлов                                      145
           12.4.1. Пример                                       147
   12.5. Команды RCS                                            148

   Глава 13. Изготовление копий                                 149

   13.1. Введение                                               149
   13.2. Когда копировать                                       149
   13.3. Форматы копий                                          149
           13.3.1. Архивные копии                               150
           13.3.2. Копии файловой системы                       151
   13.4. Носители резервных копий                               151
           13.4.1. Флоппи-дискета                               151
           13.4.2. Лента                                        152
           13.4.3. Сменный диск                                 153
           13.4.4. Фиксированный диск                           153
   13.5. Сжатие                                                 153
   13.6. Примеры архивации                                      153
           13.6.1. Сжатие флоппи-архива                         154
           13.6.2. UNIX-совместимый флоппи-архив                154
           13.6.3. Архив на ленте                               154
           13.6.4. Оптические диски                             155

   Глава 14. Восстановление дисков и файлов                     156

   14.1. Введение                                               156
   14.2. Обзор структуры диска QNX 4                            157
           14.2.1. Структура раздела                            157
           14.2.2. Каталоги                                     160
           14.2.3. Связи                                        161
           14.2.4. Блоки экстентов                              162
           14.2.5. Файлы                                        164
   14.3. Утилиты работы с файлами                               165
           14.3.1. Утилита fdisk                                165
           14.3.2. Утилита dinit                                165
           14.3.3. Утилита chkfsys                              165
           14.3.4. Утилита zap                                  166
           14.3.5. Утилита spatch                               166
   14.4. Процедуры восстановления диска                         166
           14.4.1. Использование утилиты chkfsys                166
           14.4.2. Восстановление удаленных файлов              168
           14.4.3. Восстановление плохого блока в середине файла168

                               - 10 -

   14.5. Что делать, если Ваша система больше не загружается    169
           14.5.1. Рекомендуемые действия                       169
           14.5.2. Если диск неисправен                         173
           14.5.3. Если файловая система цела                   173
   14.6. Восстановление потерянных файлов и каталогов           173
           14.6.1. Каталог lost+found                           174
           14.6.2. Использование утилиты spatch                 174

   Глава 15. Система обновления версий Quantum                  176

   15.1. Введение                                               176
   15.2. Сообщения об ошибках                                   176
   15.3. Свободное программное обеспечение                      177
   15.4. Электронная почта                                      177
   15.5. Система конференций                                    177
   15.6. О наших аппаратных средствах                           177
   15.7. Как звонить нам                                        178
   15.8. Вход в систему                                         179
   15.9. Использование QUICS                                    180

   Приложение А                                                 181
   Приложение В                                                 187
.
                               - 11 -


                     Часть I. ПОДГОТОВКА К РАБОТЕ


       В этой части...

       Использование клавиатуры
       Основные команды языка
       Работа c файловой системой QNX

                   Глава 1. ИСПОЛЬЗОВАНИЕ КЛАВИАТУРЫ

       В этой главе...

       Ввод строк
       Повторение команд
       Переключение виртуальных консолей
       Использование нескольких консолей
       Изменение консольных шрифтов
       Задержка и продолжение вывода данных
       Прекращение процесса
       Вызов системного отладчика
       Перезагрузка
       Международные клавиатуры
       Клавиатура в первом приближении

       1.1. Введение

       В этой  главе  описаны условные обозначения клавиш стандартных
  клавиатур в QNX. Запомните, что некоторые клавиши могут повести се-
  бя отлично от того, как они здесь описаны. Это зависит от того, как
  Ваша система была скомпонована.

       1.2. Ввод строк

       1.2.1. Клавиши редактора строк

       Многие программы используют режим редактирования.  Если  прог-
  рамма  выполняется в этом режиме,  Вы можете использовать следующие
  клавиши для ввода данных в виде строк:
.
                               - 12 -


  ───────────────────────────────────────────────────────────────────
        Если Вы хотите:                          нажмите эту клавишу:
  ───────────────────────────────────────────────────────────────────


  Перемещение курсора
    переместить курсор влево на одну позицию    <───  (стрелка влево)
    переместить курсор вправо на одну позицию   ───> (стрелка вправо)
    переместить курсор в начало строки                  <Home>
    переместить курсор в конец строки                    <End>

  Удаление символов
    удалить символ слева от позиции курсора*    <─── 7(Back  space)
    удалить символ в позиции курсора                     <Del>
    удалить все символы в текущей строке               <Ctrl>-<U>

  Вставление/стирание символов
    переключить режим вставки на режим наложения
    и обратно (значение по умолчанию - вставка)**        <Ins>

  Ввод строки
    ввести строку                                       <Enter>
     ──────────────────────────────────
        * Клавиша перемещения курсора на Вашей клавиатуре может  быть
        помечена <Rubout> или <Backspace>. Нажатие этой клавиши гене-
        рирует 16-ричный код 7F (ASCII Rubout), а не 08H.

        ** Если Вы работаете в режиме наложения, то после ввода стро-
        ки, Вы будете возвращены в режим вставки.
  ──────────────────────────────────────────────────────────────────


       ВНИМАНИЕ. Командный интерпретатор QNX имеет дополнительные ко-
                 манды редактирования входных данных.  Для  получения
                 дополнительной информации смотрите утилиту h в "Uti-
                 lities Reference".

       ВНИМАНИЕ. Ваша клавиатура не может работать, как указано,если:
                   -Вы работаете с программой,  которая имеет сложные
                 требования для работы пользователя - программа может
                 управлять клавиатурой.
                   -Вы работаете на подключенном терминале - терминал
                 может иметь клавиатурные ограничения.

                               - 13 -


       1.2.2. Максимальная длина входной строки

       Максимальная длина  входной строки - 256 cимволов.  Прикладные
  программы могут снижать нижние пределы.

       1.2.3. Ввод длинных строк

       Если Вы вводите одну строку,  превышающую размеры экрана,  она
  отображается на экране,  как несколько экранных строк. Строка будет
  восприниматься,  как единственная входная строка в случае,  если Вы
  используете стандартные клавиши редактирования строк. Для получения
  дополнительной информации о режиме редактирования смотрите в "Архи-
  тектуре системы" главу 6 "Администратор устройств". 0

       1.3. Повторение команд

       Командный интерпретатор  позволяет  Вам восстановить командную
  строку,  которую Вы вводили раньше,  затем вновь выполнить ее.  Эти
  команды сохраняются командным интерпретатором в буфере.

  ───────────────────────────────────────────────────────────────────
  Если Вы хотите переместиться                 нажмите эту клавишу:
  в буфере:
  ───────────────────────────────────────────────────────────────────
           назад                        7 % 0 (клавиша со стрелкой вверх)
           вперед                        7^ 0 (клавиша со стрелкой вниз)
  ───────────────────────────────────────────────────────────────────

       Когда Вы повторяете команду,  Вы можете изменить ее, используя
  стандартные клавиши редактирования строк.

       1.4. Переключение виртуальных консолей

       Адаптер, экран дисплея и системная клавиатура в  целом  предс-
  тавляют собой консоль.  Чтобы взаимодействовать с несколькими прог-
  раммами одновременно,  QNX позволяет войти в систему с так называе-
  мых  виртуальных  консолей.  Эти виртуальные консоли обычно названы
  /dev/con1,  /dev/con2 и т.п..  На каждой виртуальной консоли  могут
  выполняться  программы с различным приоритетом,  которые используют
  весь экран.  Клавиатура подключается к виртуальной консоли, которая
  в  настоящий момент видима.  Вы можете переключиться с одной вирту-
  альной консоли на другую и,  таким образом,  из одной программы  на
  другую, вводя следующую комбинацию клавиш.

                               - 14 -


  ───────────────────────────────────────────────────────────────────
  Если Вы хотите увидеть:                           нажмите:
  ───────────────────────────────────────────────────────────────────
  следующую активную консоль                  <Ctrl>-<Alt>-<Enter> или
                                                  <Ctrl>-<Alt>-<+>
  предшествующую активную консоль                 <Ctrl>-<Alt>-<->

  <+> - клавиша "плюс" серого цвета
  <-> - клавиша "минус" серого цвета
  ───────────────────────────────────────────────────────────────────

       Вы можете также "прыгнуть" на определенную консоль,  используя
  комбинацию  клавиш <Ctrl>-<Alt>-<n>,  где n - цифра,  которая соот-
  ветствует номеру виртуальной консоли.

  ───────────────────────────────────────────────────────────────────
  Если Вы хотите увидеть:                             нажмите:
  ───────────────────────────────────────────────────────────────────
  /dev/con1                                       <Ctrl>-<Alt>-<1>
  /dev/con2 (если возможно)                       <Ctrl>-<Alt>-<2>
  /dev/con8 (если возможно)                       <Ctrl>-<Alt>-<8>
  ───────────────────────────────────────────────────────────────────

       Вы можете заблокировать переключение  клавиатуры  на  консоли,
  введя команду stty +noswitch. Для получения дополнительной информа-
  ции о консолях QNX смотрите в "Архитектуре  системы"  главу 6  "Адми-
   6нистратор устройств". 0

       1.5. Использование нескольких консолей

       Администратор системы определяет, сколько виртуальных консолей
  поддерживается в Вашей машине,  задавая при запуске драйвера консо-
  лей параметр (Dev.con).  Администратор может также определить прог-
  рамму (если их несколько),  которая  первоначально  запускается  на
  каждую консоль.  По умолчанию, утилита инициализации терминала (ti-
  nit) запускает login только на первой консоли,  но "готова"  запус-
  тить  login  на любой другой консоли,  на которую Вы переключаетесь
   ╧нажатием клавиш. Это означает, что, пока консоль 1 необходима, дру-
   ╧гая консоль не будет использоваться до тех пор,  пока Вы специально
   ╧не переключитесь на эту консоль. 0
       Чтобы запустить  login  на неиспользованной консоли,  сделайте
  следующее:
       1) Переключитесь на другую консоль через <Ctrl>-<Alt>-<n>.

                               - 15 -

       2) Нажмите любую клавишу,  loqin будет запущен.  Вы можете те-
  перь  управлять консолями через любую из комбинаций клавиш переклю-
  чения консоли (например,  <Ctrl>-<Alt>-<+>),  описанных  в  разделе
  "Переключение  виртуальных  консолей."
       Когда Вы завершаете сеанс,  вводя logout или exit или  нажимая
  <Ctrl>-<D>,  консоль будет снова незанятой. Она не появится при ис-
  пользовании любой из  циклических  комбинаций  клавиш  переключения
  консоли. Исключением является консоль 1,  на которой система обычно
  перезапускает loqin.

       1.6. Изменение консольных шрифтов

       В зависимости  от  видеоаппаратных  средств,  драйвер  консоли
  (Dev.con) может использовать различные экранные шрифты. Имеющиеся в
  распоряжении шрифты пронумерованы от 0 до n. Когда QNX загружается,
  он устанавливает шрифт, как текстовый шрифт 25x80. Если Вы использу-
  ете видео-адаптер EGA или VGA,  QNX определяет шрифт, как текстовый
  шрифт 3x80(EGA) или текстовый шрифт 0x80(VGA).  Чтобы информировать
  Dev.con о новых шрифтах или переопределить существующие шрифты, ис-
  пользуйте утилиту cfont.  Вы можете использовать эту утилиту, чтобы
  обеспечить работу со шрифтами различных размеров или шрифтами,  ко-
  торые содержат переменные наборы символов. Для того, чтобы изменить
  шрифт на текущей консоли, Вы можете использовать следующие комбина-
  ции клавиш:

  ───────────────────────────────────────────────────────────────────
  Если Вы хотите выбрать:                        нажмите:
  ───────────────────────────────────────────────────────────────────
  следующий шрифт (до n)                        <Ctrl>-<Alt>-< > >
  предшествующий шрифт (до 0)                   <Ctrl>-<Alt>-< < >

  < > > - клавиша "больше"
  < < > - клавиша "меньше"
  ───────────────────────────────────────────────────────────────────

       QNX отслеживает шрифты, используемые каждой консолью. Все кон-
  соли первоначально отображают шрифт.  Вы можете заблокировать изме-
  нение шрифта с клавиатуры командой stty +noresize.
.
                               - 16 -



       1.7. Задержка и продолжение вывода данных

  ───────────────────────────────────────────────────────────────────
  Если Вы хотите:                                нажмите:
  ───────────────────────────────────────────────────────────────────
  приостановить отображение вывода данных       <Ctrl>-<S>
  продолжить отображение вывода данных          <Ctrl>-<Q>
  ───────────────────────────────────────────────────────────────────

       1.8. Прекращение процесса

       Если Вы должны прекратить процесс, протекающий в настоящий мо-
  мент на консоли,  нажмите <Ctrl>-<C>  или  <Ctrl>-<Break>.  Система
  сделает попытку прекратить процесс.

       1.9. Вызов системного отладчика

       QNX снабжен отладчиком системы низкого уровня,  который позво-
  ляет Вам устанавливать контрольные точки в программе,  отображать и
  редактировать память,  дисассемблировать код и проверять порты вво-
  да-вывода.  Если он был включен в Вашу операционную систему, Вы мо-
  жете вызвать этот отладчик нажатием следующей комбинации клавиш:

                <Ctrl>-<Alt>-<Esc>

       Вы можете  заблокировать  эту  комбинацию клавиш командой stty
  +nodebug.

       ВНИМАНИЕ. Не используйте этот отладчик в многопользовательской
                 среде,  т.к.  он блокирует прерывания и замораживает
                 всю  систему -  он  предназначен  только для отладки
                 системы на низком уровне. Для получения дополнитель-
                 ной информации об этом отладчике смотрите Debugger в
                 "Utilities Reference".  Информацию об обычном отлад-
                 чике смотрите в "WATCOM C. Debugger. User's Guide".

       1.10. Перезагрузка

       Для перезагрузки  Вашего  компьютера,  используйте  комбинацию
  клавиш:

                <Ctrl>-<Alt>-<Shift>-<Del>

                               - 17 -


       Вы можете  заблокировать  эту  комбинацию клавиш командой stty
  +noboot.

       ВНИМАНИЕ. Перед  вводом  этой команды убедитесь,  что на Вашем
                 компьютере нет программ или  утилит,  находящихся  в
                 работе.  В  противном случае,  некоторые файлы могут
                 остаться открытыми.  Кроме того, если Вы производите
                 перезагрузку в момент,  когда проводится критическая
                 коррекция данных,  возможно,  что  файловой  системе
                 потребуется  восстановление (смотрите в "Архитектуре
                 системы" главу "Устойчивость к ошибкам файловой сис-
                 темы" и  главу 14  "Восстановление  файлов и дисков"
                 этого руководства).

       1.11. Международные клавиатуры

       Некоторые клавиатуры,  например,  французские и немецкие,  ис-
  пользуют клавиши,  которые сами не генерируют символы. QNX рассмат-
  ривает эти клавиши,  как "вспомогательные". Нажатие вспомогательной
  клавиши следом за второй клавишей модифицирует вторую клавишу, соз-
  давая специальный символ.  Например, для того, чтобы создать символ
  U,  Вы нажимаете <..>, затем <Shift>-<U>. Обработка вспомогательной
  клавишей позволяет операторам обычным методом формировать специаль-
  ные символы.
       Заметим, что  Вы  можете также сгенерировать составные символы
  следующим образом:
       1) нажать и отпустить клавишу <Alt>,
       2) ввести два символа.
       Для получения более подробной информации смотрите Приложение A.

       1.12. Клавиатура в первом приближении

  ───────────────────────────────────────────────────────────────────
          Если Вы хотите:                             нажмите:
  ───────────────────────────────────────────────────────────────────
  Редактирование строк (см. также утилиту sh):
      переместить курсор влево                         <───
      переместить курсор вправо                         ───>
      перемеcтить курсор в начало строки               <Home>
      переместить курсор в конец строки                <End>
      удалить символ слева от курсора              <─── (Back space)
      удалить символ в позиции курсора                 <Del>
      удалить все символы в строке                   <Ctrl>-<U>

                               - 18 -

      осуществить переключение между режимами
      вставки/наложения                                <Ins>
      ввести строку                                   <Enter>

  Повторная выдача
      повторно выдать команду                          или .

  Переключение консолей                          <Ctrl>-<Alt>-<Enter>
      переключить на следующую виртуальную
      консоль                                      <Ctrl>-<Alt>-<+>
      переключить на предыдущую виртуальную
      консоль                                      <Ctrl>-<Alt>-<->
      переключить на определенную консоль          <Ctrl>-<Alt>-<n>

  Изменение консольных шрифтов
     выбрать следующий шрифт                       <Ctrl>-<Alt>-< > >
     выбрать предыдущий шрифт                      <Ctrl>-<Alt>-< < >

  Управление выводом данных
     приостановить отображение вывода данных           <Ctrl>-<S>
     продолжить отображение вывода данных              <Ctrl>-<Q>

  Прекращение процесса
     попытаться прекратить процесс                   <Ctrl>-<C> или
                                                     <Ctrl>-<Break>

  Конец ввода данных
     указать конец ввода данных (EOF)                  <Ctrl>-<D>

  Отладка
     вызвать системный отладчик                    <Ctrl>-<Alt>-<Esc>

  Перезагрузка
     перезагрузить Ваш компьютер            <Ctrl>-<Alt>-<Shift>-<Del>
  ───────────────────────────────────────────────────────────────────
.
                               - 19 -

                    Глава 2. ОСНОВНЫЕ КОМАНДЫ ЯЗЫКА

       В этой главе...

       Синтаксис команд
       Переадресование ввода-вывода
       Выполнение команд на другом узле или устройстве
       Отображение системных сообщений
       Использование шаблонов
       Ввод нескольких команд
       Сведения о командах интерпретатора
       Хотите узнать больше?

       2.1. Синтаксис команд

       2.1.1. Синтаксическая структура

       Всякий раз, когда Вы смотрите команду в "Utilities Reference",
  Вы видите синтаксическую структуру, которая определяет, как исполь-
  зовать  команду.  Для  большинства  команд синтаксическая структура
  состоит из трех основных частей:

		имя_команды   опции   операнды,

  где:
       имя_команды - имя команды,  которую нужно выполнить. Это может
  быть имя выполняемой программы такой,  как утилита,  или это  может
  быть имя команды командного интерпретатора;
       опции - позволяют Вам задать альтернативное поведение команды.
  Опции обычно состоят из алфавитно-цифрового символа,  следуемого за
  дефисом (например, "-c"). Некоторые опции содержат аргумент (напри-
  мер,  "-n number").  Если Вы задаете опцию,  которая содержит аргу-
  мент, Вы должны также задать и его;
       операнды -  позволяют  Вам определить данные,  необходимые для
  команд (обычно имя файла).  Если команда позволяет Вам задать  нес-
  колько  операндов,  они будут обрабатываться в порядке,  который Вы
  указываете.  В отличие от опций, перед операндом дефиса нет (напри-
  мер, "файл...").

       На рис. 1 показана типичная синтаксическая структура:
.
                               - 20 -


          │Имя
          │команды             │Опции
          │          ┌─────────┼────────────┐
          │          │         │            │
          │        ┌─┴─┐       │            │
          │        │   │       │            │
         more    [-ceisu]  [-n number]   [-x tabstop]   [ file..]
                                 │            │             │
                                 └─────┬──────┘             │
                                       │                    │
                                       │Аргументы           │
                                       │опций            Операнд

                                Рис. 1

       Заметим, что элемент:

                  [-ceisu]

  является удобным способом указать, что возможны следующие опции:

                  -c -e -i -s -u

       2.1.2. Символы клавиш

       При рассмотрении синтаксической структуры Вам следует знать  о
  следующих символах:

       ... - многоточие,  следующее за параметром опции или операнда,
  указывает,  что может быть описано более, чем одно значение. Напри-
  мер, в структуре, указанной выше, для утилиты more - операнд:

				file...

  указывает, что  Вы  можете  описать более,чем один файл в командной
  строке (например, "more myfile1 myfile2").

       [ ] -значение, включенное в скобки ([ ]) - необязательное. Оп-
  ции  всегда  заключаются в скобки (например, "[-c]").  Если операнд
  заключен в скобки, его использование не обязательно (например, "[fi-
  le...]" в вышеуказанной иллюстрации).

       | -  полоса  ИЛИ используется между альтернативами,  указывая,

                               - 21 -

  что может быть выбрано только одно значение (например, "-a │ -f").

       2.1.3. Группирование опций

       Следующие примеры командной строки more  показывают  возможные
  способы  группирования опций и аргументов опций (каждая из этих ко-
  мандных строк позволит Вам отобразить файл, названный myfile):
       a) Вы  можете  перечислить  каждую опцию раздельно в командной
  строке:

                more  -c  -e  myfile;

       b)Вы можете объединить несколько опций вместе,  используя один
  дефис (-):

                more  -ce  myfile;

       c)Если Вы  вводите  опции вместе с дефисом (-),  помните,  что
  только последняя опция может иметь аргумент. Так Вы можете задать:

                more  -cen10  myfile;

  но будет ошибка, если зададите:

                more  -n10ce  myfile;

       d)Вы можете определить аргумент опции сразу же после опции или
  отделить его одним, двумя или более пробелами:

		more  -ce  -n10  -x 4  myfile

       e)Этот пример  показывает  все  способы,  которыми  Вы  можете
  сгруппировать опции и их аргументы:

		more  -c  -e  -sn10  -x  4  myfile

       2.1.4. Пометка специальных символов

      Некоторые символы могут иметь специальное значение в  командном
  интерпретаторе в зависимости от их контекста.  Если любой из специ-
  альных символов, распознаваемых командным интерпретатором, предназ-
  начен  для  включения в командную строку,  тогда Вы должны пометить
  эти символы. Пометка относится к методу, который позволяет эти сим-
  волы обработать,  как простые символы,  вместо интерпретирования их

                               - 22 -

  специальным образом командным интерпретатором.  Вы должны  помечать
  следующие символы, чтобы избежать их специальной интерпретации:

          |               $               <space>
          &               '               <tab>
          ;               \               <newline>
          (               "
          )               '

       Вы можете  пометить следующие символы в зависимости от их кон-
  текста в пределах команд командного интерпретатора

                  *  ?  [  #  ~  =  %

       Есть три способа пометить символы:

  ───────────────────────────────────────────────────────────────────
  Чтобы пометить:                             Вы должны
  ───────────────────────────────────────────────────────────────────
  единственный символ                   перед этим символом поставить
                                        один символ (\)

  все специальные символы               заключить всю строку в оди-
  в пределах строки                     нарные кавычки

  все специальные символы в пределах    заключить всю строку в двойные
  строки, за исключением $, ' и \       кавычки

  ───────────────────────────────────────────────────────────────────

  Примеры:

       Любая из следующих команд:

                  grep QNX\ 4 chapter1.txt
                  grep 'QNX 4' chapter1.txt
                  grep "QNX 4" chapter1.txt,-

  найдет все строки "QNX" в файле chapter1.txt.
       Однако, заметим, что команда:

		grep QNX 4 chapter1.txt

  будет делать не то, что Вы ожидаете, т.к. она будет пытаться искать

                               - 23 -

  строку "QNX" в файлах 4 и chapter1.txt. Кроме того, команда:

		grep 'QNX\ 4' chapter1.txt

  не будет также искать "QNX",  т.к. одинарные кавычки заставляют ко-
  мандный  интерпретатор  игнорировать  специальное  значение  симво-
  ла "\".  Следовательно,  вышеуказанная команда будет пытаться найти
  строку:

		QNX\ 4

  в файле chapter1.txt.

       2.2. Переадресование ввода-вывода

       Большинство команд читают входные данные из файла стандартного
  ввода (stdin), который обычно присваивается Вашей клавиатуре, и за-
  писывают выходные данные в файл стандартного вывода (stdout), кото-
  рый обычно присваивается экрану Вашего дисплея. Однако, бывают слу-
  чаи,  когда  Вы хотите:
       - считать входные данные из файла или устройства, отличного от
  клавиатуры;
       - переадресовать stdout в файл или на другую команду

  ───────────────────────────────────────────────────────────────────
  Если Вы хотите, чтобы процесс:            используйте этот символ:
  ───────────────────────────────────────────────────────────────────
  читал из файла или другого         < (символ входной переадресации)
  устройства
  переадресовал stdout в файл        > (символ выходной  переадресации)

  переадресовал stdout в файл,       >> (символ добавления к выходным
  добавляя к содержимому файла           данным)

  переадресовал  stdout непос-       |  (pipe-символ)
  редственно на другую  команду
  ───────────────────────────────────────────────────────────────────

       Например, посмотрим на команду ls,  которая выдает список фай-
  лов в каталоге. Если Вы хотите получить список файлов и переадресо-
  вать его в файл, названный filelist, введите:

		ls >filelist
.
                               - 24 -


       2.3. Выполнение команд на другом узле или устройстве


       В QNX Вы можете выполнять команды на другой машине (кроме  Ва-
  шей собственной), если обе машины находятся в одной сети. Это назы-
  вается удаленным выполнением.  Каждая машина в сети называется  уз-
  лом.  Когда команда вызвана на другом узле, стандартный ввод, стан-
  дартный вывод и вывод стандартной ошибки  команды  отображаются  на
  экране Вашей консоли (или терминале), если Вы явно не переназначите
  их на другое устройство.  Для того, чтобы вызвать команду на другом
  узле,  используйте команду onnode; чтобы переадресовать (или "подк-
  лючить") стандартные ввод и вывод команды на другое устройство, ис-
  пользуйте команду ontty.

       Использование onnode

       Выполнить команду sin  на узле (вывод команды sin отображается
  на экране вызова, то есть на Вашем собственном экране):

                  onnode 4 sin

       Следующая команда эквивалентна  вышеуказанной  команде onnode,
  но использует обозначение //node command:

                  //4 sin

       Загрузить команду  sin из /bin узла 2 и выполнить ее на узле 4
  (вывод команды sin все еще отображается на экране вызова):

                  onnode 4 //2/bin/sin

       Выполнить команду sin на узле 4 и переадресовать ее выход на кон-
  соль 1 узла 2 (потоки входных данных команды sin и выходные ошибки все
  еще подключаются к экрану вызова):

                  onnode 4 sin >//2/dev/con1

       Использование ontty

       Выполнить команду ls, подключив ее вход и выход к консоли 3:

                  ontty /dev/con3 ls


                               - 25 -

       Комбинирование onnode и ontty

       Если Вы объедините onnode с ontty, Вы можете запустить команду
  на другом узле,  а также подключить вход и выход команды к устройс-
  тву этого узла.  Никакие виртуальные каналы не будут  подключены  к
  узлу,  с которого вызвана команда.  Например, следующая команда за-
  пускает сервер nameloc на  узле 4 и  подключает  его  вход/выход  на
  /dev/con1 узла 4:

                  onnode 4 ontty //4/dev/con1 nameloc &

       Имейте в виду,  что даже, если программа выполняется на узле 4
  и вход/выход подключен к устройству узла 4,  она все еще зависит от
  вызвавшего ее командного интерпретатора. Например, если эта команда
  запускалась  командным  интерпретатором и он впоследствии завершает
  свою работу,  команде устанавливается сигнал SIGHUP (то есть и  она
  будет завершаться).  Для того,  чтобы полностью отделить команду от
  запускающего ее командного интерпретатора,  Вы должны  использовать
  команду nohup. Например:

                onnode 4 ontty //4/dev/con1 nohup nameloc &

       ВНИМАНИЕ. Для получения дополнительной информации  о  вышеука-
                 занных командах смотрите nohup и sh в "Utilities Re-
                 ference".

       Альтернативу использования ontty и onnode смотрите в описании  утили-
  ты on также в "Utilities Reference".

       2.4. Отображение cистемных сообщений

       Каждая утилита  QNX  формирует системные сообщения.  По коман-
  де use Вы можете отобразить используемые утилитой сообщения. Напри-
  мер, чтобы отобразить сообщения more, Вы можете ввести:

                  use more

       Если Вы задаете use для команды и команда не может быть выпол-
  нена в текущем каталоге или она не содержит записей  сообщений,  то
  Вам  выдается сообщение об ошибке.  Дополнительную информацию о ко-
  манде use смотрите в "Utilities Reference".

  2.5. Использование шаблонов


                               - 26 -

       Вместо использования команды для работы только с одним файлом,
  Вы можете использовать шаблоны (также известные,  как символы срав-
  нения с образцом),  чтобы выполнить операции в различных файлах од-
  новременно. Для формирования шаблонов Вы можете использовать следу-
  ющие символы:
          *       - соответствует отсутствию или нескольким символам;
          ?       - соответствует любому одиночному символу;
         []       - соответствует любым символам (или диапазону симво-
                    лов, разделенных знаком тире), заключенным в скоб-
                    ки;
          !       - исключает символы, заключенные в скобки.

       ВНИМАНИЕ. Имейте в виду,  что каталоги, также как и файлы, вы-
                 бираются в соответствии с этими шаблонами.

       Примеры:

       Следующие примеры  показывают Вам,  как Вы можете использовать
  шаблоны при задании утилиты cp,  чтобы скопировать группу файлов  в
  каталог  с  именем /tmp (дополнительную информацию об использовании
  утилиты cp смотрите в "Utilities Reference").

  ───────────────────────────────────────────────────────────────────
  Если Вы вводите:                       cp делает следующее:
  ───────────────────────────────────────────────────────────────────
  cp f* /tmp             копирует все файлы, начинающиеся с f (напри-
                         мер, frd.c, flnt)
  cp *d /tmp             копирует все файлы, заканчивающиеся d (напри-
                         мер, frd, fld)
  cp fred? /tmp          копирует все файлы, начинающиеся с fred и за-
                         канчивающиеся любым одиночным символом (нап-
                         ример, freda, fred3)
  cp fred[l23] /tmp      копирует все файлы, начинающиеся с fred и за-
                         канчивающиеся 1, 2, или 3 (то есть fred1,
                         fred2, fred3)
  cp fred[l-3] /tmp      как указано выше
  cp *.[ch] /tmp         копирует все файлы, заканчивающиеся .c или .h
                         (например, frd.c, barn.h)
  cp *.[!o] /tmp         копирует все файлы, за исключением .о
  ───────────────────────────────────────────────────────────────────

       2.6. Ввод нескольких команд

       Вы можете ввести более чем одну команду одновременно, разделяя

                               - 27 -

  Ваши команды знаком;.  Например,  если Вы хотите определить Ваш те-
  кущий каталог и увидеть, что он содержит, Вы можете ввести:

                  pwd; ls

       Или, скажем, Вы хотите сделать копию файла в Вашем текущем ка-
  талоге, затем посмотреть скорректированное содержание каталога. Вам
  необходимо ввести:

                  сp myfile myfile2; ls

       2.7. Сведения о командах интерпретатора

       Вы можете  ввести  любое  количество  команд  интерпретатора в
  текстовый файл и затем вызвать команды в режиме пакетной обработки,
  просто выполняя этот файл. Файл, содержащий команды интерпретатора,
  обычно известен  как последовательность команд командного интерпре-
  татора.
       Вы можете выполнить последовательность команд интерпретато-
  ра двумя способами:
       - другой командный интерпретатор  вызывается  с  именем  Вашей
  последовательности  команд командного интерпретатора,  которое вво-
  дится, как аргумент:

                  sh myscript

       - последовательность команд командного  интерпретатора  непос-
  редственно делается выполняемой и затем рассматривается,  как новая
  команда:

                  chmod 744 myscript
                  myscript

       В данном  случае Ваш командный интерпретатор автоматически вы-
  зывает новый командный интерпретатор, чтобы выполнить Вашу последо-
  вательность команд командного интерпретатора.

       2.8. Дополнительная информация

       Некоторые темы,  включенные в эту главу, описаны дополнительно
  в sh в "Utilities Reference".
.
                               - 28 -


  ───────────────────────────────────────────────────────────────────
  Чтобы узнать больше о:                          смотрите в sh:
  ───────────────────────────────────────────────────────────────────
  специальных символах отметки           Ссылка

  переадресовании ввода-вывода           Переадресование

  выполнении команд на другом узле       Удаленное выполнение и испо-
  или устройстве                         льзование команд командного
                                         интерпретатора

  использовании шаблонов                 Расширение

  вводе нескольких команд                Перечень команд

  последовательности команд              Последовательность команд ко-
  командного интерпретатора              мандного  интерпретатора
  ───────────────────────────────────────────────────────────────────
.
                               - 29 -



       Глава 3. РАБОТА С ФАЙЛОВОЙ СИСТЕМОЙ QNX

       В этой главе...

       Имена файлов
       Полные имена
       Типичная файловая система QNX
       Часто используемые утилиты

       3.1. Введение

       В QNX имеется большой набор утилит и команд, которые позволяют
  выполнять  разнообразные  операции  с файлами и каталогами.  В этой
  главе представлена основная информация о принятых в QNX соглашениях
  об именах файлов и полных именах; в ней также описывается структура
  каталога типичной файловой системы QNX.

       ВНИМАНИЕ. Для получения дополнительной информации  о  файловой
                 системе  QNX  смотрите в "Архитектуре системы" главу
                 5 "Администратор файловой системы".

       3.2. Имена файлов

       Имя файла - это символическое имя, которое позволяет Вам иден-
  тифицировать файл и обращаться к нему.  В QNX имя файла может иметь
  до 48 символов.  Вы можете создавать имена файлов, включая все сим-
  волы  из имеющегося набора символов,  за исключением следующих (все
  величины в 16-ричном представлении):
          0x00 - 0x1F (управляющие символы)
          0x2F (наклонная черта вправо: /)
          0x7F (rubout)
          0xFF

       3.2.1. Мобильные имена файлов

       Если Вы предполагаете использовать Ваши программы и  данные  в
  других  системах,  Вы  можете  сделать Ваши файлы более мобильными,
  формируя их имена только с символами,  определяемыми POSIX для имен
  файлов:

       ABCDEFGHIJKLMNOPQRSTUVWXYZ
       abcdefghijklmnopqrstuvwxyz

                               - 30 -

       0123456789_.-

       ВНИМАНИЕ. Вы не можете использовать тире (-),  как первый сим-
                 вол мобильного имени файла.

       3.2.2. Суффиксы имени файла

       Суффиксы имени файла (например, ". txt" в myfile.txt) не имеют
  специального значения. Символ "." рассматривается, как любой другой
  символ в имени файла.  Пользователи часто  используют  общепринятые
  суффиксы имени файла.  Например,  утилита make предполагает .c, .o,
  .y и т.п.

       3.3. Полные имена

       QNX позволяет Вам группировать соответствующие файлы в катало-
  ги.  Каталоги также могут содержать другие каталоги, так что Вы мо-
  жете создать иерархическую файловую систему. Каждая файловая систе-
  ма имеет свой собственный корневой каталог.  Этот корень располага-
  ется в верхней части иерархии каталога, от него QNX начинает искать
  другие каталоги и файлы. Типичное имя для корневого каталога файло-
  вой системы на жестком диске по умолчанию - "/".  Если жесткий диск
  имеет более чем одну файловую систему, выбор имен для файловой сис-
  темы предоставляется Администратору системы. Они могут включать та-
  кие имена,  как,  например,  /hd2, /hd3 и т.п. или возможны /home2,
  /home3 и т.п. Чтобы найти файл, Вы определяете маршрут из корневого
  каталога к файлу. Другие каталоги в маршруте к файлу также разделе-
  ны наклонными чертами вправо.  Таким образом,  чтобы попасть в файл
  sysinit.1 в каталоге /etc/config, Вы определите этот маршрут:

                  /etc/config/sysinit.1

       3.3.1. Полные имена в сети

       Иногда необходимо  определить,  какой компьютер (или "узел") в
  сети содержит файл,  который Вам нужен.  Чтобы обозначить узел,  Вы
  используете символ // c поcледующим номером узла.  Так, если Вы хо-
  тите иметь доступ к /home/sam/file в узлe 24 сети, Вы введете:

                  //24/home/sam/file

       Если Вы явно не определяете узел,  QNX использует по умолчанию
  текущий сетевой корень (дополнительную информацию смотрите в "Архи-
  тектуре системы").

                               - 31 -

                                             я

       3.3.2. Текущий рабочий каталог

       Чтобы избавить Вас от  необходимости  постоянного  определения
  полных  имен  каталогов  для доступа к файлам,  в QNX предусмотрено
  сокращение:  текущий рабочий каталог. Преимущество применения теку-
  щего рабочего каталога заключается в том, что Вы не должны подробно
  определять маршрут доступа к файлам. Например, если Вы находитесь в
  каталоге /home/gbbell и хотите иметь доступ к файлу prog1.c, Вам не
  нужно вводить:

                  /home/gbbell/proc1.c

       Вместо этого, Вы можете определить только имя нужного файла:

                  proc1.c

       3.3.3. Каталог home

       Когда Вы впервые входите в систему QNX,  Ваш  текущий  рабочий
  каталог  включается  в каталог,  который был предназначен Вам Вашим
  Администратором cистемы. Этот каталог имеет имя home и является Ва-
  шим  начальным текущим рабочим каталогом.  Неважно,  где Вы находи-
  тесь, Вы всегда можете возвратиться в каталог home, вводя следующую
  команду:

                  cd

       ВНИМАНИЕ. Для получения дополнительной информации о пространс-
                 тве полных имен в QNX смотрите в "Архитектуре систе-
                 мы" главу 4 "Пространство имен системы ввода/вывода".

       3.4. Типичная файловая система QNX

       QNX использует основные соглашения UNIX для хранения стандарт-
  ных файлов.  Например, выполняемые файлы хранятся в /bin, а времен-
  ные файлы находятся в /tmp.  На рис.2 представлена структура общего
  каталога в типичной операционной системе QNX.
.
                               - 32 -


                        /
                        │
   ┌───────┬────────────┼─────────┬───────────┬─────────────┐
  bin    boot          etc       tmp         usr           home
           │            │                     │             │
    ┌──────┼──────┐     │       ┌──────┬──────┼─────┐       │
  build  images  sys  config   bin  include  lib  spool   userid...
                                              │
                                           terminfo
                                       ┌──────┼────────┐
                                       a . .. q... z
                                              │
                                             qnx

                               Рис. 2

       Следующая таблица представляет типы файлов, которые Вы найдете
  в основных каталогах:

  ───────────────────────────────────────────────────────────────────
  Каталог:                      Описание:
  ───────────────────────────────────────────────────────────────────
  /bin                 выполняемые
  /boot                Makefile образа ОС
  /boot/build          файлы формирования для создания образов (их чи-
                       тает утилита make)
  /boot/images         файлы образа ОС
  /boot/sys            системные процессы, необходимые для загрузки
  /etc                 файлы инициализации
  /etc/config          sysinit и файлы конфигурации
  /etc/readme          файлы информации о программной версии
  /etc/readme/technotes   технические заметки
  /tmp                 принятое по умолчанию место для временных фай-
                       лов
  /usr/bin             выполняемые
  /usr/include         заголовочные (.h) файлы для С-компилятора
  /usr/lib             библиотеки для C-компилятора
  /usr/lib/terminfo    файлы описания терминала
  /usr/lib/application    приложения, установленные в QNX
  /usr/spool/lp        рабочие файлы систем буферизации*
  /home/userid         каталог пользователя*
────────────────────────────────
* - перестраиваются Администратором системы.

                               - 33 -


       3.5. Часто используемые утилиты

       В следующую  таблицу включены наиболее часто используемые ути-
  литы. Дополнительная информация содержится в "Utilities Reference".

  ───────────────────────────────────────────────────────────────────
          Если Вы хотите:                        используйте команду:
  ───────────────────────────────────────────────────────────────────
  Работа с каталогами
    изменить Ваш текущий рабочий каталог                  cd
    создать каталоги                                      mkdir
    удалить каталоги                                      rmdir
    отобразить Ваш текущий рабочий каталог                pwd
    распечатать содержимое каталога                       ls

  Работа с файлами
    сравнить два файла                                    diff
    объединить файлы                                      cat
    копировать файлы                                      cp
    подсчитать количество слов, строк или байтов
    в файле                                               wc
    отобразить содержимое файла                       more, less, cat
    распечатать содержимое файла                          lp
    переименовать или переместить файлы                   mv
    удалить файлы                                         rm
    найти образцы строк в файлах                          grep
    разделить или объединить строки в файле               sort

  Другие команды
    отобразить, кто в данный момент находится в системе   who
    отобразить процессы, выполнемые в данный момент       ps, sin
    найти файлы                                           find
  ───────────────────────────────────────────────────────────────────
.
                               - 34 -


                    Часть II. УПРАВЛЕНИЕ СИСТЕМОЙ


       В этой части...

       Основная установка
       Установка сети
       Ввод учитываемых пользователей
       Подключение терминалов, принтеров и модемов
       Установка второй файловой системы
       Развитие конфигурации сети
       Буферизация печати
       Построение заданного образа операционной системы
       Использование системы управления версиями
       Изготовление копий
       Восстановление дисков и файлов
       Система обновления версий Quantum

                     Глава 4. ОСНОВНАЯ УСТАНОВКА

       В этой главе...

       Установка QNX на жестком диске
       Установка дополнительного программного обеспечения
       Файл системной инициализации
       Использование файла системной инициализации
       Часовые пояса и часы реального времени
       Лицензирование

       4.1. Установка QNX на жестком диске

       Установку системы  QNX  на жестком диске выполняет специальная
  программа install. Для того, чтобы установить QNX, выполните следу-
  ющее:

       Шаг 1. Загрузитесь с флоппи-дискеты

      Установите boot-дискету QNX в накопитель на гибких дисках и пе-
  резагрузите компьютер.  Вы увидите крутящуюся стрелку в верхнем ле-
  вом углу экрана,  затем - заставка QNX,  приветствующее сообщение и
  приглашение командного интерпретатора.

       Шаг 2. Выполните программу install

                               - 35 -


       На приглашение командного интерпретатора (#) введите:

                  install

       Следуйте за инструкциями на экране,  чтобы установить  QNX  на
  жесткий диск.

       Шаг 3. Перезагрузитесь с жесткого диска

       После завершения инсталляции Вам следует вынуть флоппи-дискеты
  и перезагрузить Ваш компьютер с жесткого диска.  ОС QNX должна  на-
  чать выполняться. Теперь Вам нужно войти в систему с именем root.

       Шаг 4. Прочитайте "Архитектуру системы"

       Очень полезно  ознакомиться  с  базовыми  принципами и работой
  QNX, изложенными в "Архитектуре системы" и части  1  данного  руко-
  водства. В дальнейшем будем считать, что у Вас есть базовый уровень
  знаний о системе QNX.

       ВНИМАНИЕ. Теперь,  когда Вы установили QNX на жесткий диск, Вы
                 можете перенастроить установку.  В этом случае смот-
                 рите следующую часть "Файл системной инициализации".
                 Если у Вас есть сеть, Вам следует также ознакомиться
                 с главой 5  05 "Сетевая установка".

       4.2. Установка дополнительного программного обеспечения

       Все дополнительные программные пакеты, поставляемые фирмой Qu-
  antum для QNX 4,  поставляются в стандартном сжатом формате. Вы мо-
  жете установить эти пакеты,  используя /etc/install, поставляемый с
  операционной системой,  и следуя указанным инструкциям. Вы могли бы
  также использовать этот метод, чтобы установить пакеты от поставщи-
  ков  третьей  стороны,  следуя инструкциям,  которые поставляются с
  каждым пакетом.

       ВНИМАНИЕ. Перед установкой Вашего программного обеспечения  Вы
                 должны  войти в систему,  как суперпользователь (ro-
                 ot),  при этом должен  быть  запущен  драйвер  флоп-
                 пи-дисковода. Для того, чтобы проверить, работает ли
                 драйвер, введите:

                  sin ver

                               - 36 -


       Если "Floppy" не появляется в столбце NAME, наберите:

                  Fsys.floppy &

       Для того,  чтобы установить Ваше программное  обеспечение,  Вы
  должны выполнить следующие шаги:
       1. Вставить диск установки (обычно диск 1) в накопитель на  гиб-
  ких дисках.
       2. На приглашение командного интерпретатора набрать:

                  /etc/install [drive]

          где drive - устройство,  c которого  устанавливается  прог-
  раммное  обеспечение.
          Значение по умолчанию - локальный накопитель на гибких дис-
  ках (/dev/fd0). Следуйте инструкциям на экране; программное обеспе-
  чение будет устанавливаться на Вашем жестком диске.

       4.3. Файл системной инициализации

       4.3.1. Что происходит, когда Вы загружаете QNX

       Когда Вы загружаете QNX,  Вы загружаете  образ,  состоящий  из
  различных процессов. Первый процесс в образе - всегда Администратор
  процессов (который содержит Микроядро). Администратор процессов вы-
  полняет  инициализацию процессора и затем планирует каждый процесс,
  включенный в образ,  для выполнения.  Последний процесс  в  образе-
  утилита sinit. Утилита sinit инициирует вторую фазу Вашей системной
  инициализации,  запуская командный интерпретатор, который выполняет
  команды из файла. Этот файл - файл системной инициализации - содер-
  жит команды,  которые устанавливают сервисные функции  машины.  Это
  стандартный файл командного интерпретатора, который выполняется по-
  добно любому другому файлу командного интерпретатора с тем исключе-
  нием,  что прерывания при этом заблокированы.  Выполнение сервисных
  функций после загрузки - одно из преимуществ модульной  архитектуры
  QNX. Образ, который загружается, содержит только несколько основных
  сервисных средств,  с помощью которых можно  запустить  все  другие
  сервисные средства.

       ВНИМАНИЕ. Возможно  Вам  потребуется скомпоновать образ специ-
                 альной загрузки для некоторых  установок  (например,
                 для  встроенных систем).  Ознакомившись с нормальной
                 системной инициализацией, для получения дополнитель-

                               - 37 -

                 ной  информации Вы можете обратиться к главе 11 "Пост-
                 роение образа операционной системы".

       При выполнении утилиты sinit сначала определяется,  загружался
  ли образ с диска или через сеть.  Если образ загружался с диска, то
  sinit проверяет, загрузка нормальная или альтернативная. (Вы можете
  дополнительно выбрать альтернативную загрузку,  нажимая <Esc> после
  приглашения программы-загрузчика.) Исходя из этой информации, sinit
  пытается открыть один из двух файлов системной инициализации:

  ───────────────────────────────────────────────────────────────────
  Если Вы выбираете:           sinit пытается обнаружить и открыть:
  ───────────────────────────────────────────────────────────────────
  нормальная загрузка          /etc/config/sysinit.node
  (с диска или сети)           Если это не проходит,то:
                               /etc/config/sysinit

  альтернативная загрузка      /etc/config/altsysinit
  (только с диска)             Если это не проходит, то:
                               /etc/config/sysinit
  ───────────────────────────────────────────────────────────────────

       Утилита sinit  будет  пытаться  открыть  sysinit только тогда,
  когда она не может открыть первый файл.  Если она не может  открыть
  ни одного файла, sinit завершается и системная инициализация не бу-
  дет выполняться. Если открытие происходит, sinit заменяется команд-
  ным  интерпретатором  (/bin/sh) и передает ему имя открытого файла.
  Каждый из файлов системной инициализации, который может быть выпол-
  нен утилитой sinit, имеет конкретное назначение:

          sysinit.node
          sysinit
          altsysinit

       Файл sysinit.node

       Если Вы хотите перенастроить установку, то Вам следует модифи-
  цировать файл. Он содержит команды, необходимые для установки среды
  и сервисных функций для Вашей машины,  позволяя каждому узлу в сети
  иметь его собственную установку.  Суффикс "node", который использу-
  ется  sinit,  является логическим ID Вашей машины и может принимать
  значение в интервале от 1 до числа узлов  в  сети.  Файл  sysinit.1
  всегда  создается программой установки.  Начальное содержание файла
  отражает параметры установки, определяемые утилитой install.

                               - 38 -


       Настройка рабочих станций

       Узлы, которые загружаются через сеть с сервера (то есть  рабо-
  чие станции),  первоначально используют для загрузки, по умолчанию,
  файл sysinit. Для того, чтобы произвести настройку рабочей станции,
  Вы должны создать файл sysinit.node в сервере загрузки для этой ра-
  бочей станции.  Вы можете начать инсталляцию с файлом  sysinit.node
  для  другого  узла с аналогичной конфигурацией или Вы можете просто
  сделать копию файла sysinit,  который затем можно будет модифициро-
  вать:

            ср /etc/config/sysinit /etc/config/sysinit.node

       Запомните, что суффикс node должен быть логическим ID узла ра-
  бочей станции, который Вы настраиваете.

       Файл sysinit

       Этот файл выполняется,  если отсутствует файл sysinit.node. Он
  должен  содержать  сервисные функции,  которые выполняются на любой
  машине. Quantum поставляет общий файл, который должен загрузить лю-
  бую машину. Мы рекомендуем Вам делать небольшие или вовсе не делать
  никаких модификаций в этом файле.  Файл sysinit автоматически поме-
  щается в Вашу систему во время установки.

       ВНИМАНИЕ. Если Вы изменяете логический ID узла,  то машина бу-
                 дет искать другой файл sysinit.node.

       Файл altsysinit

       Этот файл служит для страховки на тот случай, если модификация
  в файле sysinit.node приводит к тому, что Вы не можете войти в сис-
  тему. Файл altsysinit выполняется только тогда, когда Вы определяе-
  те альтернативную загрузку при загрузке с локального диска (т.е. Вы
  нажимаете <Esc>, когда программа-загрузчик предлагает Вам альтерна-
  тивную загрузку). Файл altsysinit должен всегда содержать последнюю
  рабочую копию файла sysinit.node для машины,  которая загружается с
  локального жесткого диска. Так, прежде, чем сделать любые изменения
  в рабочем файле sysinit.node,  которые могли бы препятствовать заг-
  рузке с жесткого диска, Вам следует скопировать файл sysinit.node в
  altsysinit:

              сp /etc/config/sysinit.node /etc/confiq/altsysinit

                               - 39 -


       Мы рекомендуем корректировать файл altsysinit после любых  ус-
  пешных изменений в файле sysinit.node.

       4.4. Использование файла системной инициализации

       4.4.1. Основные сервисные средства

       Содержимое каждого  системного  файла  инициализации  отражает
  состав аппаратных средств этой машины и сервисные функции,  которые
  они  должны  обеспечивать.  Ниже  описан  основной состав сервисных
  средств, который содержит большинство файлов инициализации.

       ВНИМАНИЕ. Если различные машины будут использовать общий комп-
                 лект команд,  Вы можете установить команды в отдель-
                 ном файле командного интерпретатора  и  иметь  файл,
                 выполняемый  посредством команды (точка) встроенного
                 командного интерпретатора. Например, Вы создали файл
                 techies,  содержащий команды, используемые всеми ма-
                 шинами в Вашем техническом отделе.  Файл может  быть
                 выполнен  из  файла sysinit.node для каждой машины в
                 этом отделе следующей командой:

                  . /etc/config/techies

       Специфические команды для данного узла  добавляют  после  этой
  "точечной"  строки.  Дополнительную информацию о "точечной команде"
  смотрите в sh в "Utilities Reference".

       Установка часовых поясов

       Следующие командные строки позволяют установить  часовой  пояс
  (EST в этом случае) и получить время с часов реального времени. Эти
  две строки должны быть первыми в файле для машин,  которые загружа-
  ются с жесткого диска. Они являются необязательными в машине, кото-
  рая загружается через сеть,  т.к. машина наследует эту информацию с
  узла, с которого она загружается.

                  export TZ=EST5DST4,M4.1.0/3,M10.5.0/3
                  rtc hw

       Более полную информацию смотрите в следующем разделе  "Часовые
  пояса и часы реального времени".


                               - 40 -

       Запуск драйверов устройств

       Следующие командные строки запускают Администратор устройств и
  консольный драйвер с восемью виртуальными консолями,  затем  задают
  командному  интерпретатору  открыть стандартный ввод/вывод на новом
  консольном устройстве.

                  Dev &
                  Dev.con -n 8 &
                  reopen //0/dev/con1

       Следующие командные строки запускают другие драйверы,  которые
  могут понадобиться. Они запускают последовательный драйвер, который
  работает с COM1 и COM2, и параллельный драйвер. Эти драйверы завер-
  шаются, если они не смогут найти необходимые аппаратные средства.

                  Dev.ser &
                  Dev.par &

       После запуска Dev.ser,  Вы можете, используя утилиту stty, из-
  менить  принятую  по  умолчанию конфигурацию.  Например,  следующие
  строки изменяют скорость передачи в бодах на 19200:

                  stty baud=19200 </dev/ser1
                  stty baud=19200 </dev/ser2
                  и т.п....

       Запуск эмулятора процессора операций с плавающей запятой

       Если Ваши программы используют режим  вычислений  с  плавающей
  запятой  и  у Вас нет микросхемы 80x87,  Вы должны запустить эмулятор
   8процессора операций с плавающей запятой: 0

                  emu87 &

       Отображение загрузки узлов

       При загрузке узла в сети Вы должны выполнять  утилиту  netmap,
  которая информирует Сетевой администратор о распределении ID узлов.
  Вам следует установить следующую команду netmap в файле sysinit.no-
  de,  даже  если узел в настоящий момент не работает в сети (команда
  не влияет на работу машины с несетевой структурой):

                  netmap -f

                               - 41 -


       Имейте в виду,  что эта команда включается в стандартные файлы
  sysinit, поставляемые фирмой Quantum.

       Запуск сервера имен

       По крайней мере на одной машине в сети должен выполняться сер-
  вер глобальных имен. Вы можете запустить сервер имен на той машине,
  которая не перезагружается слишком часто:

                  nameloc &

       Вы можете  также  выполнить  nameloc на других узлах (не более
  10) для того,  чтобы обеспечить избыточность в  случае,  если  один
  узел, выполняющий nameloc, выйдет из строя.

       Инициализация терминалов

       Следующая командная строка запускает login на первой консоли и
  инициализирует все другие консоли:

                  tinit -T /dev/con* -t /dev/con1 &

       Для инициализации используется утилита  tinit.  Поэтому  файлы
  системной инициализации,  поставляемые фирмой Quantum, содержат ti-
  nit.

       ВНИМАНИЕ. В этом случае tinit должна быть последней  командой,
                 выполненной в файле системной инициализации.

       4.4.2. Дополнительные сервисные средства

        Вы можете заказать выполнение многих других сервисных функций
  в Вашем файле системной инициализации. Вам следует добавить эти ко-
  манды  перед строкой,  содержащей команду tinit.  Следующие примеры
  иллюстрируют использование дополнительных сервисных функций. Имейте
  в виду,  что эти утилиты поддерживают опции командной строки, моди-
  фицирующие их выполнение (эти опции описаны в документации для каж-
  дой утилиты).

       Определение внешних переменных

       Определите любые  внешние переменные,  которые должны наследо-
  ваться всеми процессами, запущенными из файла системной инициализа-

                               - 42 -

  ции:

                  export var=value

       Команда export описывается в sh в "Utilities Reference".

       Запуск драйвера флоппи-дисковода

       Запустите локальный  флоппи-драйвер (если файловая система QNX
  выполняется локально, не включайте первую строку):

                  Fsys &
                  Fsys.floppy &

       Если флоппи-драйвер выполняется, Вы можете использовать утили-
  ты vol и pax для управления специальным блочным  файлом  (например,
  /dev/fd0). Если Вы хотите обращаться к нему, как к файловой системе
  QNX, Вы должны задать его следующим образом (мы рекомендуем Вам ис-
  пользовать  pax,  чтобы  перемещать файлы между файловыми системами
  QNX):

                  mount /dev/fd0 /fd0

       Запуск файловой системы DOS

       Запустите файловую систему DOS,  чтобы получить доступ к флоп-
  пи-дискетам и разделам DOS.  Для этого необходимо,  чтобы  файловая
  система QNX работала с драйвером для флоппи и/или жесткого диска:

                  Dosfsys &

       Выбор сервера cron

       Если Вы считаете,  что машина редко будет перезагружаться,  Вы
  можете также запустить на ней сервер cron:

                  cron &

       Запуск часов

       Запустите часы,  которые всегда будут отображать время в верх-
  нем правом углу экрана:

                  clock -f green "+%X" &

                               - 43 -


       4.4.3. Поддержка не USA-клавиатуры

       По умолчанию, QNX консольный драйвер работает со 101-клавишной
  USA-клавиатурой.  Тем не менее, в QNX поддерживается целый ряд кон-
  фигураций, соответствующих клавиатурам, наиболее часто используемым
  в мире.  Если Вам требуется выбрать конфигурацию  с  альтернативной
  клавиатурой,  то Вы можете использовать утилиту kbd. Если при уста-
  новке QNX на жестком диске Вы выбираете не USA-клавиатуру, то соот-
  ветствующая  команда kbd будет добавлена в файл sysinit.node.  Если
  Вы устанавливаете рабочие станции, то Вы должны включить эту коман-
  ду в их файлы sysinit.node. Имейте в виду, что Вы можете также сге-
  нерировать заданные клавиатурные форматы утилитой kedit.

       4.5. Часовые пояса и часы реального времени

       Важно, чтобы при инициализации была установлена правильная да-
  та,  время и информация о часовом поясе.  Эти установки должны быть
  сделаны в начале Вашего файла  системной  инициализации.  Программа
  install считает, что аппаратные часы выдают правильную дату и время
  и запрашивают информацию о часовом поясе.  Непосредственно QNX  ис-
  пользует координатное универсальное время (UTC), которое часто име-
  нуется временем по Гринвичу.  Приложения и утилиты  преобразовывают
  его в локальное время, используя информацию о Вашем часовом поясе.

       ВНИМАНИЕ. Если  значение  часового  пояса не установлено,  QNX
                 считает,  что локальное время совпадает с координат-
                 ным универсальным временем. Проблемы возникают толь-
                 ко в том случае, если Вы захотите передавать файлы в
                 другую систему,  находящуюся в другом часовом поясе.
                 В этом случае даты в файле  окажутся  смещенными  на
                 разницу  между двумя часовыми поясами.  Часовой пояс
                 должен быть правильно установлен, если Вы планируете
                 использовать  систему модификации версий фирмы Quan-
                 tum при загрузке нового программного обеспечения.

       4.5.1. Установка часового пояса

       Информация о часовом поясе должна быть введена перед  установ-
  кой  текущей  даты  и времени.  Если часы реального времени в Вашем
  компьютере были установлены на местное время, то QNX необходима ин-
  формация о часовом поясе для того,  чтобы установить время по Грин-
  вичу.  В следующем примере часовой пояс,  а также правила изменения
  времени  устанавливаются  для Восточного Стандартного Времени в Се-

                               - 44 -

  верной Америке:

                  export TZ=EST5DST4,M4.1.0/3,M10.5.0/3

       где:

          export - команда командного  интерпретатора  для  установки
          внешней  переменной
          TZ     - имя переменной EST Восточное Стандартное Время
          5      - 5 часов до времени по Гринвичу
          DST    - летнее время
          4      - 4 часа до времени по Гринвичу
          M4.1.0/3  - первое воскресенье апреля в 15 часов
          М10.5.0/3 - последнее  воскресенье октября в 15 часов

       ВНИМАНИЕ. Дополнительную  информацию о часовых поясах смотрите
                 в Приложении В.

       4.5.2. Получение даты и времени с часов реального времени

       Если Вы загружаетесь с диска,  то Вам следует в первой  строке
    Вашего  файла  системной инициализации задать утилиту rtc,  чтобы
    установить текущую дату и время с часов реального времени. Следу-
    ющие две командные строки выполнят это:

                  export TZ=EST5DST4,M4.1.0/3,M10.5.0/3
                  rtc hw

       Эти команды установят дату и время в IBM АТ-совместимом компь-
  ютере.  Имейте в виду, что есть два возможных способа установки ча-
  сов реального времени в Вашей машине:
       - установка часов  реального времени по Гринвичу;
       - установка часов реального времени по местному времени.

       Мы рекомендуем, чтобы Вы устанавливали время в часах реального
  времени по Гринвичу.  Но,  если Вы также работаете с  операционными
  системами, которые устанавливают часы реального времени по местному
  времени (например, DOS), Вам следует использовать утилиту rtc с оп-
  цией -l ("эл"):

                  rtc -l hw

       Этот вызов rtc указывает,  что часы реального времени устанав-
  ливаются по местному времени.  Имейте в виду, что, когда Вы исполь-

                               - 45 -

  зуете местное время в часах реального времени,  Вы  должны  вручную
  изменить  значение  часов  реального времени при переходе c летнего
  времени на местное.

       ВНИМАНИЕ. Если время на Ваших  аппаратных  часах  неправильное
                 (возможно батарея была заменена),  Вам следует уста-
                 новить системное время,  используя утилиту date, за-
                 тем  установить  часы  реального времени,  используя
                 утилиту rtc с опцией -s.  Дополнительную  информацию
                 об этих утилитах смотрите в "Utilities Reference".

       Если Вы загружаетесь через сеть...

       Если Вы  загружаетесь  через сеть,  машина унаследует время по
    Гринвичу и значение часового пояса,  хранящееся во внешней  пере-
    менной из узла,  с которого загружаетесь.  Следовательно,  Вам не
    нужно вводить эту информацию в Ваш файл системной инициализации.

       4.6. Лицензирование

       4.6.1. Лицензирование операционной системы

       Для каждого  компьютера,  который работает с QNX,  должно быть
  получено разрешение.  Причем неважно, используете ли Вы 10 автоном-
  ных  машин или 10 машин с сетевой структурой.  В сети каждая машина
  называется "узлом" и каждому узлу присвоен логический ID узла.  Ло-
  гический  ID  узлов изменяется в пределах от 1 до общего количества
  узлов в сети.  Например, для сети имеются разрешения (лицензии) для
  трех узлов - логические ID узлов 1, 2 и 3. Вы устанавливаете размер
  сети,  выполняя утилиту license (смотрите раздел "Расширение  Вашей
  лицензии"). Для того, чтобы проверить лицензирование, Вы можете ис-
  пользовать команду  ls.  Следующий  рисунок  определит  одноузловую
  QNX-лицензию:

                         ls /etc/license
                         qnxO000178n001
                         ─┬─       ─┬──
                          │ ───┬─── │
                          │    │    │Номер узлов
                          │    │Серийный номер
                          │Продукт

       Если Вы установили другие QNX-приложения (например, Watcom C),
    их лицензии также будут отображаться на экране.

                               - 46 -


  4.6.2. Лицензирование приложений

       Приложения обычно  получают лицензии на узел или на параллель-
  ное использование.

       Лицензирование на узел

       Большинство приложений получают лицензии на  узел  в  QNX сети
  так  же,  как и операционная система.  Если у Вас есть приложение с
  лицензией,  скажем,  на три узла,  то Вы ограничены выполнением его
  только  на трех узлах сети.  (Ваш сетевой лицензионный размер может
  превысить лицензионный размер для приложения.) Вы можете  выполнять
  многочисленные вызовы приложения на каждом лицензионном узле. Когда
  Вы выполняете приложение с лицензией на узел, то узел будет исполь-
  зовать  одну  из  лицензий.  Лицензия останется с этим узлом до тех
  пор,  пока он не перезагружается.  По соглашению,  последовательные
  номера,  которые  завершаются комбинацией "nddd",  лицензируются на
  узел.

       Лицензия на параллельное использование

       Приложения могут также быть лицензированы на  несколько  копий
  для параллельного использования. Например, если приложение лицензи-
  руется на три копии, тогда одновременно может выполняться где угод-
  но в сети до трех копий.  Имейте в виду, что на несетевой одноузло-
  вой машине, можно выполнить только три параллельных вызова. По сог-
  лашению  серийные номера, оканчивающиеся на "uddd", задают лицензию
  на параллельное использование.

       4.6.3. Расширение Вашей лицензии

       Вы расширяете Ваш лицензионный объем для операционной  системы
  или приложения, используя утилиту license. Эта утилита устанавлива-
  ет лицензионные серийные номера с флоппи-дискет  на  жесткий  диск.
  Каждая  дискета загрузки QNX и прикладная дискета содержит серийный
  номер лицензии для одного узла (или для  одного  использования).  В
  следующем примере лицензия передается с накопителя на гибких дисках
  ("накопитель A:" в DOS-терминологии) на Ваш жесткий диск.  Имейте в
  виду, что флоппи-драйвер (Fsys.floppy), должен выполняться посредс-
  твом:

                  license


                               - 47 -

       ВНИМАНИЕ. После добавления новых серийных номеров в Ваш  комп-
                 лект лицензий Вы должны активизировать их. Для этого
                 Вы можете запустить license -r,  которая считает ли-
                 цензии из /etc/licenses на жестком диске и установит
                 их в лицензионную базу данных в памяти машины. В се-
                 ти Вы можете выполнить license -R node, чтобы прочи-
                 тать новые лицензии из текущей внутренней лицензион-
                 ной базы данных другого узла.

       Любые машины, загружающиеся через сеть, наследуют серийные но-
  мера машины,  с которой они загружались.  Если Вы хотите  загрузить
  машины, работающие в сети, с их локального жесткого диска, Вы долж-
  ны использовать утилиту license,  чтобы добавить серийные номера на
  каждый жесткий диск,  с которого Вы хотите загрузиться.  Как только
  Вы сделали это на одном жестком диске,  Вы можете использовать ути-
  литу license, чтобы скопировать серийные номера через сеть с одного
  жесткого диска на другой и,  таким образом, избежать повторной заг-
  рузки  с флоппи-дискеты.  Имейте в виду,  что лицензионные файлы не
  могут быть скопированы утилитой cp.  Дополнительную  информацию  об
  утилите license смотрите в "Utilities Reference".

       ВНИМАНИЕ. Для получения лицензии через сеть на сервере загруз-
                 ки (машина с лицензиями) должна выполняться  утилита
                 nameloc. Если машина имеет локальный жесткий диск (с
                 лицензиями) и сетевую плату,  но работает не в  сети
                 (например,  портативная),  на  ней также должна быть
                 выполнена утилита nameloc для получения лицензии.
.
                               - 48 -

                        Глава 5. УСТАНОВКА СЕТИ

       В этой главе...

       Об установке
       Выбор конфигурации сервера загрузки
       Выбор конфигурации рабочей станции

       5.1. Введение

       QNX - это сетевая распределенная операционная система.  Каждый
  компьютер,  на котором работает QNX, называется узлом. Единственный
  компьютер можно рассматривать, как одноузловую сеть.


       5.1.1. Логические узловые ID

       Каждому узлу  присваивается  уникальный логический узловой ID,
  представляемый положительным целым. Операционная система использует
  этот логический узловой ID, чтобы взаимодействовать с другими узла-
  ми, связанными сетью. Вам следует присваивать логические узловые ID
  в непрерывной последовательности,  начиная с 1-го (например,  1, 2,
  3, 4, 5,...).
       Для этого существует две причины:
       - получение лицензии для QNX основывается на общем числе логи-
  ческих узлов в сети. Пятиузловая сетевая лицензия позволяет взаимо-
  действовать узлам с 1-го по  n-й.  Узел будет игнорироваться,  даже
  если один из узлов с  1-го по  n-й был опущен.
       - в свою очередь отдельные значимые утилиты должны взаимодейс-
  твовать с каждым узлом сети. Они делают это с помощью посылки сооб-
  щений, начиная с  узла 1 и до узла n, где n - размер сетевой лицензии.
       Так работают утилиты nameloc, sin net и who -a.

       5.1.2. Логические сетевые ID

       Узлы связаны через одну или более сетей. Каждая сеть при уста-
  новке представляет собой отдельную коммуникационную связь,  и, сле-
  довательно, данные, передаваемые по одной сети, не должны быть вид-
  ны в другой сети.  Сетям,  подобно узлам,  присваиваются логические
  ID,  которые должны быть уникальными  при  установке.  Единственная
  сеть  (наиболее общий случай) по умолчанию имеет логический сетевой
  ID, равный 1 1.
.
                               - 49 -


       5.1.3. Физические узловые ID


       Хотя процессы QNX работают с логическими узловыми ID, сами се-
  тевые платы взаимодействуют по физическим узловым ID.  Эти физичес-
  кие ID обычно содержатся непосредственно  в  самой  сетевой  плате.
  Формат  физического  ID  зависит от типа сети (например,  Ethernet,
  Arcnet,  Token Ring) и невидим для большинства приложений. Физичес-
  кие  ID  должны быть уникальными в пределах сети,  но они не должны
  быть уникальными для всех сетей при установке.

       5.2. Об установке

       5.2.1. Сетевые драйверы

       Установка сети,  естественно, включает установку сетевой платы
  в  Ваш компьютер и соединение ее с платами других компьютеров сете-
  вым кабелем.  Ethernet,  Arcnet и Token Ring - являются популярными
  сетевыми  технологиями.  Для  того,  чтобы  использовать конкретную
  сеть, Вам нужна как соответствующая сетевая адаптерная плата, так и
  сетевой драйвер QNX, поддерживающий эту плату. В большинстве случа-
  ев,  платы от других поставщиков для той  же  самой  сетевой  среды
  (например, Ethernet) требуют свои собственные специальные драйверы.
  Иногда,  тем не менее,  драйвер может поддерживать платы более  чем
  одной компании,  если платы обеспечивают аналогичный аппаратный ин-
  терфейс.  Сетевые драйверы описаны в "Utilities  Reference",  и  их
  имена начинаются с "Net".

       ВНИМАНИЕ. Аппаратная установка сетевой платы и физическое сое-
                 динение между платами должны быть  описаны  в  руко-
                 водстве, поставляемом с платой.

       5.2.2. Определение физических узловых ID

       Физический узловой ID сетевой платы зависит от типа платы, ко-
  торую Вы используете.

       Ethernet & Token Ring

       Каждая Ethernet или Token Ring плата поставляется с его  собс-
  твенным физическим узловым ID, встроенным в плату. Этот ID, который
  является совершенно уникальным, имеет длину 48 битов для того, что-
  бы соответствовать стандарту IEEE8 802.  На платах Ethernet 0 Вы можете

                               - 50 -

  найти значение ID где-нибудь на плате или на упаковке. Формат адре-
  са ID может меняться.  Например, все следующие идентификаторы иден-
  тичны:

                  0000c0 4a9330
                  0000с04a9330
                  00 00 с0 4a 93 30
                  00:00:с0:4a:93:30
                  0000 с04a 9330

       Arcnet

  Каждая плата Arcnet требует, чтобы Вы задали физический узловой ID на
  плате.  В  зависимости  от  изготовителя,  это  делается  посредством
  dip-переключателя  или  записью в энергонезависимое ЗУПВ через интер-
  фейсное меню во время загрузки. Физический ID имеет длину 8 битов. Вы
  не можете  использовать  физический ID - 0,  который зарезервирован.
  При выборе физического узлового ID мы рекомендуем Вам для одной се-
  ти Arcnet физический узловой ID установить таким же, как логический
  узловой ID. Это упростит Вашу работу.

       5.2.3. Присвоение логических узловых ID

       Т.к. процессы  QNX  используют логические узловые ID,  Сетевой
  администратор должен преобразовывать логические ID в физические ID,
  используемые аппаратными средствами.  Это преобразование задается в
  файле /etc/config/netmap. Каждая строка в этом файле определяет для
  одного узла соответствие логического узлового и сетевого ID, за ко-
  торым следует физический узловой ID. Например, следующая строка ус-
  танавливает соответствие логического узла 8 48-битному физическому ID
   80000c4a9330: 0

                 8   1   0000c0 4a9330
                 │   │   └┬──────────┘
                 │   │    │Физический узловой ID (16-ричный)
                 │   │Логический сетевой ID
                 │Логический узловой ID

       Вы можете разделить логический и физический ID  пробелами  или
  табуляцией.  Логический ID - десятичный,  а физический ID - 16-рич-
  ный,  если ему не предшествует "t", в этом случае он также десятич-
  ный. Например, в случае Arcnet более удобно представлять физический
  узловой ID в десятичном виде:


                               - 51 -

                  15  1  t15

       Физический ID не может превысить 48 битов. Требуемое количест-
  во битов определяется сетевым аппаратным обеспечением.

       5.2.4. Серверы загрузки и рабочие станции

       Установка сети QNX выполняется в два этапа:
       1) Выбор конфигурации одного или более серверов загрузки;
       2) Выбор конфигурации рабочих станций.

       Компьютер может быть сконфигурирован для загрузки QNX с  жест-
  кого диска или,  если это узел в сети, через сеть. Для загрузки уз-
  лов через сеть необходимо сначала установить один узел (сервер заг-
  рузки),  с которого другие узлы могут загружаться.  Обычно сервером
  загрузки выбирается узел,  который редко перезагружается. Узлы, ко-
  торые загружаются через сеть,  называются рабочими станциями.  Т.к.
  загрузка рабочих станций происходит через сеть,  некоторые  рабочие
  станции не имеют жесткого диска.  Они называются бездисковыми рабо-
  чими станциями. Когда рабочая станция загружается через сеть, образ
  операционной  системы  загружается в ее память;  образ наследует из
  сервера загрузки следующее:
       - время;
       - список определителей  имен (смотри  утилиту  nameloc в "Uti-
  lities Reference");
       - лицензионные возможности.

       5.2.5. Планирование Вашей сети

       Если Вы устанавливаете небольшую сеть,  то, вероятно, потребу-
  ется только один сервер загрузки,  обычно узел 1. 0 Если же Вы устанав-
  ливаете  большую  сеть,  которая обслуживает различные отделы,  Вам
  следует устанавливать сервер загрузки для каждого отдела. Пользова-
  тели в каждом отделе смогут иметь доступ к файлам (в соответствии с
  атрибутами файлов) в других отделах.  Например,  предположим, у Вас
  есть три отдела: R&D, Маркетинг и Операции. Можно выполнять загруз-
  ку в каждом отделе с его собственного сервера загрузки, который мог
  бы  также выступить в качестве отдельского основного файлового сер-
  вера.  Эта установка создает отказоустойчивую среду - отказ в одном
  отделе не помешает другому отделу выполнить загрузку.  Для большого
  количества узлов это должно также уменьшить потенциально узкое мес-
  то загрузки,  когда служащие в офисе начинают свою работу с загруз-
  ки.  В этой главе описано,  как устанавливать один сервер загрузки.
  Если Вы хотите установить дополнительные серверы загрузки, смотрите

                               - 52 -

  главу 9 "Сложная сетевая конфигурация". 0

       Подготовка схемы

       Вам следует подготовить схему для Вашей сети,  подобную приве-
  денной  ниже.  На этой примерной схеме показана сеть,  состоящая из
  пяти узлов.  Один из узлов - сервер загрузки  и  четыре  -  рабочие
  станции,  которые будут загружаться и получат файлы от сервера.  Мы
  присвоили логические узловые ID каждому  узлу:  серверу  загрузки -
  узел 1 1.

  ┌───────────────────────────────────────────────────────────────┐
  │                                                               │
  │   <────┬─────────────┬──────────┬────────┬─────────┬──────>   │
  │        │             │          │        │         │          │
  │        │             │          │        │         │          │
  │      Узел 1      │ Узел 2     Узел 3   Узел 4    Узел 5 │     │
  │                  └──────────────────────────────────────┘     │
  │ СЕРВЕР ЗАГРУЗКИ               РАБОЧИЕ СТАНЦИИ                 │
  │                                                               │
  └───────────────────────────────────────────────────────────────┘

                                Рис.3.
       Пятиузловая сеть,  состоящая из сервера загрузки и четырех ра-
                             бочих станций


       5.3. Выбор конфигурации сервера загрузки

       ВНИМАНИЕ. Перед запуском Вы должны иметь компьютер,  загружае-
                 мый системой QNX с  жесткого  диска.  Дополнительную
                 информацию смотрите в главе "Базовая установка".

       Для того,  чтобы  преобразовать  компьютер,  который загружает
  QNX, в сервер сетевой загрузки, произведите следующие действия:

       Шаг 1. Установите Вашу сетевую плату

       ВНИМАНИЕ. Quantum выпускает технические заметки  по  установке
                 сетевых плат.  Эти  заметки,  которые  Вы  найдете в
                 /etc/readme/technotes,  имеют имена файлов, начинаю-
                 щиеся с Net (например,  Net.ether8003).  Перед уста-
                 новкой платы Вы должны прочитать техническую заметку
                 для типа платы, которую Вы используете.

                               - 53 -


       Выключите компьютер,  затем установите Вашу сетевую плату сог-
  ласно инструкциям,  прилагаемым к плате.  Если возможно, определите
  физический узловой ID платы.  Когда закончите, перезагрузите компь-
  ютер.


       Шаг 2. Установите Ваши сетевые лицензии

       Вам нужна сетевая лицензия для каждого узла Вашей сети.  Когда
  Вы установили QNX на жестком диске, лицензия создана по крайней ме-
  ре  для единственного узла.  Вы можете проверить эту лицензию,  ис-
  пользуя команду ls.  Из следующего примера видно, что имеется одно-
  узловая лицензия QNX:

                 ls /etc/licenses
                 qnx0000178n001
                    ───┬───
                 ─┬─   │   ──┬─
                  │    │     │Количество узлов
                  │ Серийный
                  │  номер
                Продукт

       Если Вы уже установили другие QNX-приложения  (например,  Wat-
  com C), то их лицензии также будут отображаться. QNX поставляет до-
  полнительные лицензии для QNX и приложений на дискетах,  помеченных
  "Сетевые расширения".  Для того,  чтобы добавить лицензии с дискеты
  сетевого расширения,  вставьте дискету, затем запустите утилиту li-
  cense  без  аргументов.  Повторите эту операцию для каждой из Ваших
  дискет расширения.  Для того,  чтобы  активизировать  лицензии,  Вы
  должны  выполнять команду license -r.  Для получения дополнительной
  информации смотрите раздел "Лицензирование" в главе, а также утили-
  ту license в "Utilities Reference".

       Шаг 3. Модифицируйте файл sysinit.node

       Если Вы  командой  install задаете,  что этот узел должен быть
  сервером загрузки,  install автоматически позаботится об этом шаге.
  Вы можете перейти к шагу 4 4.

       ВНИМАНИЕ. Если  Вы не задали командой install,  что эта машина
                 должна быть сервером загрузки, но впоследствии реши-
                 ли это исправить,  Вы должны:

                               - 54 -

                 1) Начать с команд, описанных в этом шаге;
                 2) Добавить команды  в  файл sysinit.node этого узла.

       Перед добавлением  любых команд в файл sysinit.node скопируйте
  его в файл altsysinit:

                  cp /etc/config/sysinit.node /etc/config/altsysinit

       Запуск Сетевого администратора и сетевого драйвера

       Сетевой администратор (Net) и сетевой драйвер для Вашей  платы
  должны быть запущены для обеспечения доступа к сети. Имена для всех
  сетевых драйверов имеют форму Net.xxx,  где xxx представляет  собой
  соответствующий драйверный суффикс. Например, если у Вас есть плата
  Ethernet серии 8003, необходимо ввести:

                  Net &
                  Net.ether8003 &

       Для того,  чтобы  выяснить,  какие сетевые драйверы доступны в
  Вашей системе, введите команду ls /bin/Net.*.

       Запуск nameloc

       Утилита nameloc должна работать в сети (даже если  это  единс-
  твенный узел) для того, чтобы могли работать лицензионные продукты:

                  nameloc &
       Запуск netboot

       При загрузке узел посылает запрос загрузки на его сервер  заг-
  рузки. Когда Сетевой администратор на сервере загрузки получает со-
  общение о запросе загрузки,  он передает этот запрос утилите netbo-
  ot, которая также должна работать на сервере загрузки:

                  netboot &

       Выполнив все вышеуказанные команды, Вы можете использовать Ваш
  узел,  как сервер загрузки.  Как только Вы добавили эти  команды  в
  файл sysinit.node,  они будут выполняться автоматически, когда узел
  перезагружается.

       ВНИМАНИЕ. Возможно теперь Вы захотите продолжить настройку Ва-
                 шего сервера загрузки.  Для получения дополнительной

                               - 55 -

                 информации смотрите раздел "Файл системной инициали-
                 зации" в главе 4.

       Шаг 4. Установите соответствие логических и физических ID узлов

       Если Вы  устанавливаете  сервер  загрузки  в единственной сети
  Arcnet (где физический узловой ID равен логическому  узловому  ID),
  дело сделано!  В противном случае  Вы должны выбрать логический уз-
  ловой ID для сервера загрузки.  Если это - Ваш  первый  (начальный)
  сервер,  мы  предлагаем для сервера загрузки выбрать логический ID,
  равный 1 1. 0 Для того, чтобы установить соответствие логического узло-
  вого ID, который Вы выбрали, с физическим узловым ID сетевой платы,
  Вы должны добавить строку в файле /etc/config/netmap. Например, для
  того, чтобы установить соответствие для узлов 1, 2, 3 и 4, Вам сле-
  дует добавить строки, подобные нижеприведенным, в netmap:

          1       1       physical_node_ID
          2       1       physical_node_ID
          3       1       physical_node_ID
          4       1       physical_node_ID

       Имейте в виду, что для единственной сети логический сетевой ID
  всегда равен 1 1.

       ВНИМАНИЕ. Если Вы не определили физический узловой ID при  ус-
                 тановке платы или ID не было на плате,  то, запустив
                 netmap без опций,  Вы узнаете Ваш физический узловой
                 ID.  Для получения дополнительной информации о файле
                 netmap смотрите утилиту netmap в "Utilities Referen-
                 ce".

       Шаг 5. Измените файл /etc/config/netboot

       Если Вы задали командой install,  что этот узел будет сервером
  загрузки, или, если Вы инсталлируете сервер загрузки в единственной
  сети Arcnet,  где физические узловые ID те же, что и логические уз-
  ловые ID,  дело сделано.  В противном случае  Вы должны  завершить
  этот шаг,  в котором Вы выбираете соответствующий файл формирования
  сетевой среды.  При ответе на запрос  загрузки  netboot  использует
  файл /etc/config/netboot, чтобы определить, какой файл формирования
  должен использоваться,  чтобы сгенерировать OS для требуемого узла.
  Мы  поставляем основные файлы формирования,  удобные для построения
  образов рабочей станции для разных сред,  таких как Arcnet  (напри-
  мер,   /boot/build/ws.arcnet)   и   Ethernet  (например,  /boot/bu-

                               - 56 -

  ild/ws.ether8003).  По умолчанию, файл /etc/config/netboot содержит
  строку:

                  * f=build/ws.arcnet

  для единственной сети Arcnet.
       Если Вы используете другой тип сети, Вам понадобится модифици-
  ровать строку f=,  чтобы указать, какой файл формирования использо-
  вать.  Например,  для сети Ethernet, использующей сетевые платы се-
  рии 8 8003, Ваша строка будет выглядеть следующим образом:

                  * f=build/ws.ether8003

       5.4. Выбор конфигурации рабочей станции

       Шаг 1. Установите Вашу сетевую плату

       ВНИМАНИЕ. Quantum выпускает  технические записки для установки
                 сетевых плат.  Эти записки,  которые  Вы  найдете  в
                 /etc/readme/technotes,  имеют имена файлов, начинаю-
                 щиеся с Net (например,  Net.ether8003).  Перед уста-
                 новкой  платы  Вам следует прочитать техническую за-
                 писку для типа платы, которую Вы используете.

       Установите Вашу сетевую плату в Ваш  компьютер  согласно  инс-
  трукции,  поставляемой с платой.  Не забудьте определить физический
  узловой ID платы. (Это - та же самая процедура, которую Вы делали в
  шаге 1 "Выбор конфигурации сервера загрузки".)

       ВНИМАНИЕ. Если Вашей плате нужно ПЗУ загрузки,  убедитесь, что
                 ПЗУ установлено. Плата Arcnet фирмы Quantum приходит
                 с  уже установленным ПЗУ загрузки.  При загрузке ПЗУ
                 загрузки выведет физический узловой ID.

       Шаг 2. Установите соответствие логических и физических ID узлов

       Мы рекомендуем, чтобы Вы присваивали рабочим станциям логичес-
  кие узловые ID - 2,  3, 4 и так далее. Для получения дополнительной
  информации смотрите шаг 4 "Выбор конфигурации сервера загрузки".

       Шаг 3. Загрузите рабочую станцию

       Рабочая станция должна теперь загружаться через сеть.  Если  у
  Вас есть какие-нибудь проблемы, задайте опцию -v Сетевому админист-

                               - 57 -

  ратору в файле формирования рабочей  станции  (например,  /boot/bu-
  ild/ws.arcnet).  При этом сетевые ошибки будут отображаться на кон-
  соли.  Кроме того,  Вы можете выполнить  утилиту  netinfo,  которая
  отобразит последние сетевые события.  Вам следует пользоваться этой
  утилитой всякий раз,  когда Вы хотите выполнить  диагностику  сети.
  Для  получения дополнительной информации о netinfo смотрите "Utili-
  ties Reference".

       ВНИМАНИЕ. Если Вы еще не установили среду и сервисные  функции
                 для Ваших  рабочих  станций,  смотрите  раздел "Файл
                 системной инициализации" в главе 4.
.
                               - 58 -


                Глава 6. ВВОД УЧИТЫВАЕМЫХ ПОЛЬЗОВАТЕЛЕЙ

       В этой главе...

       Безопасность
       Регистрационный файл

       6.1. Безопасность

       QNX предоставляет механизмы по управлению доступом к  ресурсам
  и критическим системным функциям.  Эти механизмы базируются на спо-
  собности системы определять конкретного пользователя.

       6.1.1. Утилиты управления доступом

       Утилиты управления доступом в QNX:

          login   вход в систему
          su      временное получение привилегий другого пользователя
          passwd  обеспечение учета/изменений паролей пользователей
          newgrp  переключение на другую группу

       Утилита login

       Утилита login  начинает  работу  при запуске tinit на все уст-
  ройства tty.  Утилита login запрашивает имя пользователя и  пароль,
  которые проверяются в базе данных пароля.  Если пользователь не мо-
  жет ввести за три  попытки  правильную  комбинацию  имя пользовате-
  ля/пароль,  утилита  заканчивает  работу,  обновляя cоответствующую
  считанную информацию.  Если пользователь введет правильную комбина-
  цию,  login запустит командный интерпретатор и загрузит среду поль-
  зователя.

       Утилита su

       Утилита su позволяет пользователю  временно  иметь  привилегии
  другого пользователя. Если пользователь - не суперпользователь (ro-
  ot), su запрашивает соответствующий пароль. Если введена правильная
  комбинация,  su выполнит exec() для создания командного интерпрета-
  тора для пользователя с соответствующим идентификатором ID группы и
  ID  пользователя.  При выходе из интерпретатора команд пользователь
  возвратится туда, где он был перед выполнением su.


                               - 59 -

       Утилита passwd

       Утилита passwd может использоваться для изменения  пароля  или
  ввода  нового  пользователя в систему.  Когда пользователь вызывает
  passwd,  чтобы изменить пароль,  passwd запрашивает у  пользователя
  старый пароль и новый пароль,  затем запрашивает снова новый пароль
  (чтобы проверить правильность его ввода). Если пользователь являет-
  ся суперпользователем,  старый пароль не запрашивается.  Только су-
  перпользователь (root) может ввести  нового  пользователя.  Утилита
  passwd использует файл /etc/default/passwd,  чтобы определить число
  символов в пароле,  диапазон изменений ID и  так  далее.  Например,
  чтобы  ввести нового пользователя с именем carol,  Вы должны задать
  команду:

                  passwd carol

       По умолчанию passwd затем запросит следующую информацию:
  - ID пользователя;
  - ID группы;
  - действительное имя пользователя;
  - рабочий каталог;
  - командный интерпретатор при входе;
  - пароль.
       По соглашению,  учитываемые пользователи имеют ID пользователя
  больше или равный 100. ID пользователя меньше 100 часто использует-
  ся системными процессами. Если ID группы не существует - не забудь-
  те скорректировать файл groups, который будет отображаться. Если ID
  группы существует, то этот пользователь будет добавлен в нее. Пара-
  метры рабочий каталог, командный интерпретатор при входе и пароль -
  необязательные:

  ───────────────────────────────────────────────────────────────────
  Если Вы не определите:                      Тогда:
  ───────────────────────────────────────────────────────────────────
  рабочий каталог            будет использоваться /home/username
                             (этот  каталог будет создан, если он не
                             существует)

  командный интерпретатор    по умолчанию будет использоваться коман-
                             дный интерпретатор при входе системы
                             (/bin/sh)

  пароль                     будет введен пользователь без пароля
  ───────────────────────────────────────────────────────────────────

                               - 60 -


       Если Вы  определяете  новый  пароль,  Вас  попросят ввести его
  дважды, чтобы проверить правильность ввода. Утилита passwd не обес-
  печивает исключение пользователя.  Эта функция может быть выполнена
  коррекцией файлов /etc/passwd,  /etc/group и /etc/shadow, используя
  текстовый редактор.

       Утилита newgrp

       Утилита newgrp  изменяет реальный ID группы текущего процесса.
  Если утилита вызвана без аргументов,  newgrp изменяет идентификацию
  группы  на группу,  определенную в базе данных паролей для текущего
  пользователя.  Группы, на которые конкретный пользователь может из-
  менить свой ID, определяются базой данных паролей.

       6.1.2. ID пользователя и группы

       При вводе в систему пользователю присваиваются:
  - ID пользователя;
  - ID группы.

       Они называются реальным ID пользователя и реальным ID  группы.
  ID пользователя должен быть уникальным. Никакие два пользователя не
  должны иметь один и тот же ID.  Это условие обеспечивается утилитой
  passwd, но суперпользователь может нарушить это условие, непосредс-
  твенно редактируя файл  password.  ID  группы  позволяет  различным
  пользователям объединяться в группы. Этот механизм позволяет исклю-
  чить доступ пользователей других  групп  к  ресурсам,  используемым
  пользователями данной группы.

       Эффективные ID пользователя и группы

       Процессы имеют два класса ID пользователя и группы: реальный и
  эффективный.  Когда процесс создан,  он автоматически наследует эти
  четыре ID от его источника (обычно от командного интерпретатора при
  входе):
       - реальный ID пользователя (uid)
       - реальный ID группы (gid)
       - эффективный ID пользователя (euid)
       - эффективный ID группы (egid)
       Эффективные ID пользователя и группы используются для проверки
  полномочий. Процесс может изменить свои эффективные ID пользователя
  или группы как раздельно,  так и оба одновременно, при этом они бу-
  дут  отличаться от их реальных аналогов.  Естественно,  это сделано

                               - 61 -

  для того,  чтобы получить доступ к недоступным ресурсам с реальными
  ID пользователя и группы.

  ───────────────────────────────────────────────────────────────────
  Чтобы модифицировать эффективный        Вы используете:
  ID группы и пользователя:
  ───────────────────────────────────────────────────────────────────
  из C-программ                       функции seteuid() и setegid()

  из командного интерпретатора        биты атрибутов доступа setuid и
                                      setgid файла
  ───────────────────────────────────────────────────────────────────

       Для получения  дополнительной информации о битах setuid и set-
 gid, смотрите следующий раздел "Атрибуты доступа файла".

       6.1.3. Атрибуты доступа файла

       В QNX каждый файл имеет атрибуты  доступа,  называемые  битами
  режима.  Эти  биты режима,  связанные с владельцем файла и группой,
  управляют доступом к файлу. Когда процесс открывает файл, эффектив-
  ный  ID пользователя процесса и эффективный ID группы становятся ID
  владельца и группы файла. Комплект битов режима также присваивается
  файлу  (это  описывается  в разделе "Как назначаются биты режима").
  Есть три класса битов режима:  владельца, группы и других пользова-
  телей.  Когда процесс пытается управлять файлом, Администратор фай-
  ловой системы анализирует соответствующий класс битов режима.
       Администратор файловой  системы  определяет  следующий порядок
  обработки битов режима:
       1) Эффективный ID пользователя запрашиваемого процесса сравни-
  вается с ID владельца файла.  Если они совпадают, то обрабатываются
  биты режима владельца.
       2) При несовпадении с ID владельца, эффективный ID группы зап-
  рашиваемого  процесса  сравнивается с ID группы файла.  Если эти ID
  групп совпадают,  то обрабатываются биты режима группы.
       3) При  несовпадении  с ID владельца и группы,  обрабатываются
  биты режима других пользователей.

       ВНИМАНИЕ. Как суперпользователь root (uid),  Вы можете  управ-
                 лять любым  файлом  для  чтения/записи независимо от
                 разрешений,  а также выполнять любой  файл,  который
                 имеет по крайней мере один бит режима разрешения вы-
                 полнения файла.


                               - 62 -

       Биты режимов файла загружаются в  16-битовую  область  st_mode
  каталога для файла;  доступ к файлу предоставляется, если соответс-
  твующий бит режима установлен в 1 1.

  ┌───────────────────────────────────────────────────────────┐
  │                          st_mode                          │
  │                                                           │
  │    15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0   │
  │   ┌──┬───┬───┬───┬───┬───┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐  │
  │   │                su  sg     r  w  x  r  w  x  r  w  x│  │
  │   ├──┴───┴───┴───┼───┴───┼──┼──┴──┴──┼──┴──┴──┼──┴──┴──┤  │
  │       тип файла    │   │   │ владелец  группа   другие    │
  │                    │   │   │                              │
  │                    │   │   │                              │
  │                    │   │   │                              │
  │                    │   │ резерв                           │
  │                    │ setgid                               │
  │                  setuid                                   │
  └───────────────────────────────────────────────────────────┘

                                Рис.4

       Следующая таблица иллюстрирует различие  в  атрибутах  доступа
  активизированных регулярных файлов и каталогов:

  ───────────────────────────────────────────────────────────────────
  Атрибуты         Тип доступа в зависимости от типа файла:
            Регулярный файл               Каталог
  ───────────────────────────────────────────────────────────────────
    r         Чтение файла    Проверка имен файлов в каталоге (напри-
                              мер, через утилиту ls)

    w         Запись в файл   Cоздание, удаление   и   переименование
                              файлов  в  пределах  каталога,  включая
                              подкаталоги

    x*        Выполнение      Просмотр каталога. Это означает, что Вы
                              можете изменить Ваш текущий каталог  на
                              этот каталог. Также, Вы можете включить
                              этот каталог в имя маршрута  (например,
                              в open(), stat(),...).

  * Атрибут на выполнение имеет значение только для каталогов и регу-
  лярных   файлов;   он   не   применяется  к  другим  типам  файлов.

                               - 63 -

  ───────────────────────────────────────────────────────────────────

       Просмотр атрибутов доступа

       Вы можете использовать команду ls -l,  чтобы увидеть  атрибуты
  доступа к файлу,  владельца и группу. Информация, выдаваемая по ко-
  манде ls -1 ("el") для файла alpha.c,  показывает,  что владелец  и
  кто-нибудь  из группы techies могут читать и записывать в файл alp-
  ha.c, при этом другие пользователи могут только читать этот файл:

       -rw-rw-r--  1 brianc   techies    8475 May 17  1991  alpha.c

       В следующем примере информация,выдаваемая  по  команде  ls -ld
  для  каталога /bin,  показывает,  что владелец и члены группы могут
  читать, записывать и просматривать каталог, при этом другие пользо-
  ватели  не  имеют разрешения на запись атрибутов доступа,  следова-
  тельно, не могут добавлять новые файлы в каталог:

         drwxrwxr-x  2 root   techies     2048 Sep 19  1990  bin

       Тем не менее,  другие пользователи могут просматривать или вы-
  полнять файлы в /bin. Допустимо, хотя и неестественно, иметь разре-
  шение читать каталог,  но не иметь возможность  просматривать  его.
  Это позволит работать команде ls в зависимости от опций, которые Вы
  указываете,  но не позволит Вам управлять любым файлом  в  каталоге
  или переходить по команде cd в этот каталог. Это может сбить с тол-
  ку.  Вам может показаться, что система ведет себя неправильно, т.к.
  вполне логично допустить,  что, если Вы можете увидеть наличие фай-
  ла,  то и имеете разрешение управлять им,  то есть,  если Вы можете
  посмотреть содержимое каталога,  то и можете сделать его текущим по
  команде cd.

       Как устанавливать биты режима

       Атрибуты доступа к файлу будут устанавливаться, как комбинация
  текущей маски umask созданного процесса и режима доступа,  устанав-
  ливаемого в функциях open()/creat().  Маска umask указывает,  какие
  биты режима должны быть исключены, если процесс определяет по умол-
  чанию атрибуты доступа при создании  файла,  каталога  или  очереди
  (смотрите umask в "Utilities Reference"). Эта маска обычно задается
  в 8-ричном виде (т.е., 0666, в двоичном виде - 110110110, что озна-
  чает следующие атрибуты: rw-rw-rw-). Далее следует пример использо-
  вания umask:


                               - 64 -

        Запрашивается режим:    110110110       (0666) = rw-rw-rw-
        Текущая маска umask:    000010010       (0022) = ----w--w-
        --------------------
        Результат:              110100100       (0644) = rw-r--r--

       Вы можете изменить атрибуты доступа к файлу следующим образом:

  ───────────────────────────────────────────────────────────────────
  Для того, чтобы изменить:       используйте:
  ───────────────────────────────────────────────────────────────────
  владельца и группу              утилиты chown и chgrp
                                  функцию chown() (C-программы)

  атрибуты доступа и              утилиту chmod
  биты режима setuid и setgid     функцию chmod() (C-программы)
  ───────────────────────────────────────────────────────────────────

       ВНИМАНИЕ. Для того, чтобы модифицировать владельца или атрибу-
                 ты доступа к файлу,  Ваш эффективный ID пользователя
                 должен совпадать с ID владельца файла. Если Вы изме-
                 няете владельца файла,  Ваш ID должен отличаться  от
                 ID владельца. При этом Вы больше не сможете изменять
                 атрибуты доступа владельца файла.  Суперпользователь
                 может модифицировать биты режима любого файла, неза-
                 висимо от его владельца.

       Setuid и setgid

       Иногда для того, чтобы выполнить определенные функции, пользо-
  ватель должен выполнять команду на уровне привилегий выше,  чем они
  у него есть.  Например,  пользователю может потребоваться выполнить
  утилиту passwd, чтобы модифицировать свой собственный пароль в базе
  данных пароля,  хотя обычные попытки записи в эту базу данных будут
  отвергаться.  Два бита режимов файлов позволяют пользователю выпол-
  нять команду на более высоком уровне привелегий: установка ID поль-
  зователя (setuid) и установка ID группы (setgid). Если эти биты ус-
  тановлены в 1,  исполняемый файл выполнится с полномочиями его вла-
  дельца и группы, а не с полномочиями процесса, который вызывает та-
  кой файл. Эти биты режима применяются только к исполняемым регуляр-
  ным файлам.  Когда файл загружается для выполнения и бит режима se-
  tuid установлен, эффективный ID пользователя нового процесса стано-
  вится таким же,  как у владельца файла. Аналогично, если бит режима
  setgid установлен,  эффективный ID группы становится таким же,  как
  номер группы файла.  Для того,  чтобы закрыть доступ к файлу,  биты

                               - 65 -

  setuid и setgid обнуляются всякий раз,  когда изменены владелец или
  группа файла.  Установка бита setuid защищает от записи пользовате-
  лями выполняемого файла на диск и, таким образом, изменяя владельца
  файла на root,  пользователь получает неограниченные системные пол-
  номочия.  Утилиты passwd, login, su и newgrp имеют владельцем файла
  суперпользователя root;  следовательно, эти программы выполняются с
  полномочиями суперпользователя.

       ВНИМАНИЕ. Принято,  что root - единственный пользователь с ну-
                 левым идентификатором  пользователя,  который  имеет
                 статус суперпользователя.  Что  касается  управления
                 доступом, Вы должны гарантировать, что только надеж-
                 ным, совершенно надежным программам можно установить
                 идентификатор суперпользователя.  Программа не полу-
                 чает никаких специальных полномочий,  когда ей уста-
                 навливают  идентификатор  группы  суперпользователя.
                 Т.к.  программы setuid наследуют  полномочия  супер-
                 пользователя,  Вам следует убедиться, что они не за-
                 писывают атрибуты доступа,  т.к. только суперпользо-
                 ватель может модифицировать программы.

       6.1.4. База данных паролей

       Три файла образуют базу данных паролей:

          /etc/passwd
          /etc/shadow
          /etc/group

       Доступ к этим файлам должен быть следующим образом:

  ───────────────────────────────────────────────────────────────────
  Файл         Владелец  Группа  Атрибуты доступа
  ───────────────────────────────────────────────────────────────────
  /etc/passwd     root    root    rw- r-- r--
  /etc/group      root    root    rw- r-- r--
  /etc/shadow     root    root    rw- --- ---
  ───────────────────────────────────────────────────────────────────

       Файл /etc/passwd содержит набор строк следующего формата:

                  username: haspw: userid: group: comment: homedir:
                  shell


                               - 66 -

  где:

          username  имя пользователя при входе в систему;
          haspw     если отсутствует, то пользователь не имеет ника-
                    кого пароля;    в   противном   случае  в  файле
                    /etc/shadow существует пароль;
          userid    числовой идентификатор пользователя;
          group     числовой идентификатор группы;
          comment   область комментария произвольного формата; не до-
                    лжна содержать ":";
          homedir   рабочий каталог этого пользователя (значение по
                    умолчанию - /);
          shell     инициализируемый командный интерпретатор (и аргу-
                    менты), запускаемые при входе (значение по  умол-
                    чанию   - /bin/sh).

       Файл /etc/group содержит строки следующего формата:

                  groupname: reserved: group: member[,member]*

  где:

          groupname       имя группы
          reserved        резерв для последующего использования
          group           числовой ID группы
          member          список имен пользователей, принадлежащих к
                          этой группе

       Файл /etc/shadow содержит строки следующего формата:

                  userid: password: reserved: reserved: reserved

  где:

          userid    имя пользователя
          password  закодированный пароль этого пользователя
          reserved  три числовые области резервируются для "старого  па-
                    роля"; для действующего они всегда равны 0.

       Вы можете обратить внимание, что из вышеуказанного списка раз-
  решений файл /etc/passwd - читаемый. Это позволяет стандартным ути-
  литам,  используя простой механизм, находить информацию о пользова-
  телях.  Т.к.  этот файл - читаемый, закодированный пароль не содер-
  жится в нем.  Закодированный пароль содержится в файле /etc/shadow,

                               - 67 -

  который имеет право читать только суперпользователь.  Это  защищает
  от несанкционированных попыток недоброжелательных пользователей де-
  кодировать пароли.  Как Администратору системы, Вам следует обеспе-
  чить эти права доступа. QNX загружен с базой данных пароля по умол-
  чанию,  которая  включает  файлы  /etc/passwd  и  /etc/group.  Файл
  /etc/shadow  не  загружен,  т.к.  учитываемые в нем пользователи не
  имеют паролей.

       6.1.5. Файлы паролей по умолчанию

       Файл /etc/passwd, который был загружен с Вашей QNX системой по
  умолчанию, содержит следующее:

                  root::0:0::/:/bin/sh

       По умолчанию /etc/group файл содержит следующее:

                  root::0:root

       6.2. Файл регистрации

       Регистрационная информация  записывается  в  файл /etc/acclog.
  Если этот файл не существует,  вся регистрационная информация будет
  потеряна.  Это - нормальный режим после того, как QNX была установ-
  лена.  Для большинства систем реального  времени  рекомендуется  по
  умолчанию  не  хранить регистрационную информацию.  Если у Вас есть
  модемная линия или если Вы используете QNX в сети со многими  поль-
  зователями, Вы можете изменить это, создав пустой файл /etc/acclog.

       6.2.1. Включение регистрации

       Для того, чтобы включить регистрацию, Вы должны создать пустой
  файл /etc/acclog. Для этого используйте утилиту touch:

                  touch /etc/acclog
                  chmod g=, o= /etc/acclog

       Регистрационная информация будет записываться в него.
       Имейте в виду, что только суперпользователь (ID пользователя -
  root) может создать и модифицировать этот файл.

       6.2.2. Формат записи

       Каждая запись в этом текстовом файле имеет следующую форму:

                               - 68 -


                  tttttttttt cc data...

       где tttttttttt - время в секундах с 1970 (в десятичном) виде. За
  ним всегда следует один пробел.  За временем следует двухсимвольный
  код cc.  За  этим кодом через пробел следуют данные,  специфические
  для каждого кода.  Запись завершается символом <конец строки>. Сле-
  дующие утилиты записывают регистрационную информацию.

  ───────────────────────────────────────────────────────────────────
  Утилиты     Назначения                       Запись
  ───────────────────────────────────────────────────────────────────
  login   вход пользователя           tttttttttt LO device uid gid uname
  login   неудачные попытки входа     tttttttttt LF uname
  modem   подключение модема          tttttttttt MO device
  su      переключение пользователя   tttttttttt SU device uid gid uname
  tinit   запуск команды              tttttttttt TS device command
  tinit   управление с устройства     tttttttttt TA device
  ───────────────────────────────────────────────────────────────────

       Типичный файл регистрации мог бы быть похож на этот:

                  670464500 TS //1/dev/ser1 modem -b 19200 -L
                  670464545 MO //1/dev/ser1 2400
                  670464550 LO //1/dev/ser1 100 101 steve
                  670465824 TS //1/dev/ser1 modem -b 19200 -L

       Эта запись показывает,  что tinit, запущенная с программой mo-
  dem,  ждет  вызовов.  Получен  вызов  и  выдан  ответ  на  скорости
  2400 бод,  и  пользователь с идентификатором steve вошел в систему.
  Имейте в виду,  что регистрация не показывает конец  сеанса.  Можно
  сделать вывод о конце сеанса,  т.к.  в последней строке tinit снова
  запускается с  программой  modem.  Общая  продолжительность  сеанса
  пользователя при успешном входе в систему может быть вычислена сле-
  дующим образом:

                  670465824 - 670464550 = 1274 секунды

       В базовой системе записи с многих  устройств  будут  распреде-
  ляться в файле регистрации.  Для того, чтобы сопоставить события на
  каждом устройстве,  Вы должны найти номер узла,  с которым  связано
  каждое  устройство.  Возможно проследить все устройства сети,  т.к.
  регистрационная информация находится в одном файле.  Вот  различные
  последовательности в общем случае:

                               - 69 -


          TS -> LO -> TS    начало и конец сеанса на выделенной линии.
          TS -> MO -> LO -> TS начало и конец сеанса на  подключаемой
                             линии.
          TA -> TS -> LO -> TA начало и конец сеанса на выделенной ли-
                            нии, управляемой нажатием клавиши.
          TS -> TS          неудачная попытка входа на выделенную ли-
                            нию.
          TS -> MO -> TS    неудачный вход на подключаемой линии.

       6.2.3. Очистка файла регистрации

       Как только Вы создаете файл /etc/acclog,  он начинает увеличи-
  ваться,  т.к. записи в нем постоянно добавляются. Если не управлять
  этим, то файл может занять значительное дисковое пространство, поэ-
  тому  Вам следует напечатать или архивизировать информацию из этого
  файла в регулярную базу. Можно автоматизировать эту работу, исполь-
  зуя утилиту cron (смотрите "Utilities Reference"). В следующем при-
  мере регистрационный файл переименовывается в файл,  называемый го-
  дом и месяцем и создается новый пустой регистрационный файл:

                  mv /etc/acclog /etc/acclogs/9106
                  touch /etc/acclog
                  chmod g=,o= /etc/acclog

       ВНИМАНИЕ. Т.к.  данные в этом файле - очень регулярные, Вы мо-
                 жете использовать  утилиту  сжатия  freeze,  которая
                 обеспечивает  очень высокие показатели сжатия файла.
                 Это может значительно уменьшить требования к  диско-
                 вому пространству,  если Вы сохраняете регистрацион-
                 ную информацию в работающей системе или  записываете
                 ее на гибкий диск. Не забывайте переименовывать файл
                 перед  его  сжатием.  Никогда   не   сжимайте   файл
                 /etc/acclog непосредственно.  Вот пример рекомендуе-
                 мой процедуры сжатия:

                  mv /etc/acclog /etc/logs/9106
                  touch /etc/acclog
                  chmod g=,o= /etc/acclog
                  freeze /etc/logs/9106

       Имейте в виду, что и другие утилиты (возможно третьей стороны)
  могут добавить  свои  собственные  регистрационные  записи  в  файл
  /etc/acclog. Утилиты могут также регистрировать проблемы или неожи-

                               - 70 -

  данно возникающие ситуации в текстовом файле /etc/syslog.
.
                               - 71 -


         Глава 7. ПОДКЛЮЧЕНИЕ ТЕРМИНАЛОВ, ПРИНТЕРОВ И МОДЕМОВ

       В этой главе...

       Запуск драйверов устройств
       Параллельные устройства
       Последовательные устройства

       7.1. Запуск драйверов устройств

  Система QNX  обычно содержит одно или более периферийных устройств.
  Все эти устройства управляются процессом Dev.  Этот процесс  должен
  быть запущен первым,  прежде чем будут запущены любые драйверы уст-
  ройства.

	/bin/Dev &	Администратор Устройства

       Как только Dev будет запущен,  один или более  драйверов  уст-
  ройства могут быть включены:

          /bin/Dev.con &  драйвер консольного устройства
          /bin/Dev.par &  драйвер устройства параллельного принтера
          /bin/Dev.ser &  драйвер последовательного устройства
          /bin/Dev.pty &  псевдо tty драйвер

       Каждый из этих драйверов описывается дополнительно в "Utiliti-
es Reference".

       7.2. Параллельные устройства

       Параллельные порты  обычно  используются  для взаимодействия с
  параллельными принтерами. Кроме запуска драйвера Вам необходимо вы-
  полнить еще некоторые действия до подключения принтера к машине.

       7.2.1. Единственный параллельный порт

       Если в  машине используется только один параллельный порт,  то
  никакие параметры не нужны:

                  Dev.par &

       Запущенный таким образом,  параллельный драйвер  создаст  уст-
  ройство,  названное /dev/par,  которое соответствует первому парал-

                               - 72 -

  лельному порту, обнаруживаемому BIOS (LPT1).

       7.2.2. Несколько параллельных портов

       Если Ваша машина имеет более чем один  параллельный  порт,  то
  Вам необходимо запустить Dev.par для каждого дополнительного порта.
  Вы должны обеспечить уникальное имя для  дополнительных  устройств.

       Например:

                  Dev.par &
                  Dev.par -b 2 -N laser &

       Эти команды создадут устройство, названное /dev/par на LPT1, и
  второе устройство, названное /dev/laser на LPT2.

       7.2.3. Буфера вывода

       При наличии памяти Вы могли бы, определив большие буфера выво-
  да, значительно сократить длительность цикла обработки при передаче
  данных на Ваш принтер. Вот пример параллельного устройства, создан-
  ного с буфером вывода в З0K:

                  Dev.par -O 30000 &

       7.3. Последовательные устройства

       7.3.1. Аппаратные адаптеры

       Адреса ввода/вывода

       Драйвер Dev.ser может  поддерживать  один или более последова-
  тельных портов.  Аппаратный интерфейс в компьютере состоит из  уни-
  версального  асинхронного  интерфейса для каждого последовательного
  порта.  Драйвер поддерживает любой или все из  семейств  последова-
  тельных  контроллеров 8250,  16450 или 16550.  Каждый универсальный
  асинхронный интерфейс использует восемь последовательных адресов  в
  массиве адресов ввода/вывода компьютера. Драйвер Dev.ser при запус-
  ке получает информацию о массиве адресов ввода/вывода  для  каждого
  универсального  асинхронного  интерфейса  из  аргументов  командной
  строки.

       Аппаратное прерывание


                               - 73 -

       Таким же важным, как адрес ввода/вывода, будет аппаратное пре-
  рывание, генерируемое каждым универсальным асинхронным интерфейсом.
  Большинство микро-ЭВМ  обеспечивают  различные  аппаратные  сигналы
  прерывания  на шине,  обозначаемые от IRQ2 до IRQ15 (за исключением
  прерываний 0,  1, 8, 9 и 13, которые используются непосредственно в
  собственных  платах  Системы).  Этими сигналами прерывания являются
  логические сигналы,  возбуждаемые  высоким  уровнем  сигнала TTL  в
  ISA-шинах,  которые означают,  что Вы можете подключить только одну
  адаптерную плату на каждый сигнал прерывания.  Архитектура микрока-
  нала (MCA-шина) не имеет такого ограничения. Платы последовательных
  адаптеров бывают различных конфигураций.  Адаптерные платы только с
  одним последовательным портом естественно предлагают только ограни-
  ченный выбор адресов ввода/вывода и аппаратного прерывания. Следую-
  щая  таблица представляет некоторые обычно используемые комбинации,
  но мы рекомендуем Вам внимательно прочитать аппаратную документацию
  на аппаратуру, чтобы выбрать комбинацию, соответствующую адаптерной
  плате данного изготовителя:

  ───────────────────────────────────────────────────────────────────
          Имя     Адрес   Прерывание
  ───────────────────────────────────────────────────────────────────
          COM1    3F8     IRQ4
          COM2    2F8     IRQ3
          COM3    3E8     изменяется
          COM4    2E8     изменяется
  ───────────────────────────────────────────────────────────────────

       Многопортовые последовательные адаптеры

       Вы можете  сконфигурировать   многопортовые   последовательные
  адаптеры так,  чтобы они соответствовали большому диапазону адресов
  ввода/вывода. Эти адаптеры могут также дать Вам широкую возможность
  выбора  аппаратных  прерываний.  Большой выбор адресов ввода/вывода
  находится в диапазоне от 280 до BF.  Из-за ограниченного числа возмож-
  ных  аппаратных  прерываний,  эти платы будут преобразовывать набор
  линий с  сигналами  прерывания  от  индивидуального  универсального
  асинхронного  интерфейса  посредством  логического  сложения (OR) в
  единственное прерывание,  выдаваемое в шину. QNX допускает совмест-
  ное  использование одного и того же прерывания для множества после-
  довательных портов,  т.к.  Dev.ser  проверит  каждый  универсальный
  асинхронный интерфейс, который использует это прерывание.

       Типичная инсталляция аппаратных средств


                               - 74 -

       На рис.5  показана  обычная конфигурация последовательных адап-
  терных плат в системе QNX.

  ┌──────────────────────────────────────────────────────────────────┐
  │                                                                  │
  │        Шина                                                      │
  │    центрального                                                  │
  │     процессора                                                   │
  │        ┌──┐        Адаптерные платы       Последовательные       │
  │        │  │                                  устройства          │
  │        │  │         ┌────────────┐                               │
  │    3F8 │  │═══════│    COM1    ├────────────────────────       │
  │   IRO4 │  │<────────└────────────┘                               │
  │        │  │                                                      │
  │        │  │         ┌────────────┐                               │
  │    2F8 │  │═══════│    COM2    ├────────────────────────       │
  │   IRO3 │  │<────────└────────────┘                               │
  │        │  │         ┌────────────┐                               │
  │    280 │  │═══════│            │                               │
  │        │  │         │            │                               │
  │    288 │  │═══════│            ├────────────────────────       │
  │        │  │         │ 8-портовая ├────────────────────────       │
  │     .  │  │    .    │ последова- ├────────────────────────       │
  │        │  │         │  тельная   ├────────────────────────       │
  │     .  │  │    .    │   плата    ├────────────────────────       │
  │        │  │         │  адаптера  ├────────────────────────       │
  │     .  │  │    .    │            ├────────────────────────       │
  │        │  │         │            ├────────────────────────       │
  │        │  │         │            │                               │
  │    2B8 │  │═══════│            │                               │
  │   IRQ5 │  │<────────│            │                               │
  │        │  │         └────────────┘                               │
  │        └──┘                                                      │
  │                                                                  │
  └──────────────────────────────────────────────────────────────────┘

                               Рис. 5

       ВНИМАНИЕ. В  конкретном  случае  каждый последовательный канал
                 должен иметь уникальный адрес ввода/вывода, и каждая
                 адаптерная  плата должна использовать уникальное ап-
                 паратное прерывание.

       7.3.2. Последовательный протокол RS-232

                               - 75 -


       Протокол асинхронной связи RS-232C определяет электрический  и
  физический  интерфейс между терминальным оборудованием пользователя
  (терминалами) и оборудованием передачи данных (модемами).

       Электрический интерфейс

       На рис.6 6 показана развязка кабеля стыка RS-232.

  ┌───────────────────────────────────────────────────────────┐
  │                                                           │
  │          ┌──────┐                      ┌──────┐           │
  │   ──────>│2  Tx │──────>       <───────│1  CD │<───────   │
  │ Т <──────│3  Rx │<──────     Т <───────│2  Rx │<───────   │
  │ Е ──────>│4  RTS│──────> М   Е ───────>│3  Tx │───────> М │
  │ Р <──────│5  CTS│<────── О   Р ───────>│4  DTR│───────> О │
  │ М <──────│6  DSR│<────── Д   М ────────│5  Gnd│──────── Д │
  │ И ───────│7  Gnd│─────── Е   И <───────│6  DSR│<─────── Е │
  │ Н <──────│8  CD │<────── М   Н ───────>│7  RTS│───────> М │
  │ А ──────>│20 DTR│──────>     А <───────│8  CTS│<───────   │
  │ Л <──────│22 RI │<──────     Л <───────│9  RI │<───────   │
  │          └──────┘                      └──────┘           │
  │                                                           │
  │    25-штырьковый разъем           9-штырьковый разъем     │
  └───────────────────────────────────────────────────────────┘

                               Рис. 6


       Главный компьютер  обычно  рассматривается,  как  терминальное
  устройство.  Мы допускаем, что компьютер будет подключаться к моде-
  му. Сигналы RS-232 имеют следующие названия:

          Tx      передача данных
          Rx      прием данных
          RTS     запрос для посылки
          CTS     очистка для посылки
          DSR     готовность набора данных
          DTR     готовность терминальных данных
          CD      обнаружение несущей
          RI      индикатор кольца

       Последовательный протокол


                               - 76 -

       Данные передаются асинхронно,  используя битовый протокол, как
  показано на рис.7.

  ┌────────────────────────────────────────────────────────────┐
  │                                                            │
  │              <------------------                           │
  │ 1     ┌───┬──┬──┬──┬──┬──┬──┬──┬──┬───┐             Mark   │
  │       │ 1 │D0│D1│D2│D3│D4│D5│D6│D7│Par│ 0                  │
  │ 0 ────┘   └──┴──┴──┴──┴──┴──┴──┴──┴───┴────         Space  │
  │        Бит           Биты          Бит  Бит                │
  │       старта        данных         чет- оста-              │
  │                                   ности нова               │
  └────────────────────────────────────────────────────────────┘

                               Рис. 7

       Обычно, строка  данных RS-232 находится в состоянии SPACE (0).
  Переданный символ состоит из битов, передаваемых в следующем поряд-
  ке: I) бит START (всегда 1)(младший бит - первый); 2) от 5 до 8 би-
  тов данных (наименее значимый - первый бит);  3) бит четности  (до-
  полнительный); 4) один или более битов STOP (0). Длительность пере-
  дачи каждого бита определена скоростью передачи в бодах,  указываю-
  щей количество битов в секунду,  которое может быть передано. Приз-
  нак четности - необязательный,  но,  если он имеется, то может быть
  одним из следующих:

          odd     сумма битов данных плюс бит четности - нечетная
          even    сумма битов данных плюс бит четности - четная
          mark    всегда 1
          space   всегда 0

       Управление сеансом

       RS-232 использует линии DTR и DSR для управления сеансами свя-
  зи.  Терминал  поднимает уровень сигнала в DTR,  когда он включен и
  доступен. Аналогично, модем поднимает уровень в DSR, когда он вклю-
  чен  и  доступен  (но необязательно подключен к удаленному модему).
  Связь не допускается,  если в линиях DTR или DSR уровень не поднят.
  Терминал указывает, что он больше не передает данные, сбрасывая ли-
  нию DTR,  что заставляет большинство модемов  отключать  телефонную
  линию, таким образом освобождая соединение. Модем указывает, что он
  установил соединение,  выставляя CD. Некоторые модемы также укажут,
  что они обнаружили поступающий вызов, выставляя RI (но еще не отве-
  тили).

                               - 77 -


       Управление потоком данных

       Линии RTS и CTS управляют потоком данных  между  терминалом  и
  модемом. Терминал выставляет RTS, когда он способен получать данные
  по линии Rx.  Аналогично, модем выставляет CTS, когда он может при-
  нять данные по линии Tx.

       7.3.3. Выбор конфигурации последовательных портов

       Утилита stty позволяет  установить  четыре основных параметра,
  которые определяют стык RS-232.

       Биты данных

       QNX поддерживает четыре размера для символа. Вы выбираете раз-
  мер символа данных одной из следующих команд stty:

                  stty bits=5
                  stty bits=6
                  stty bits=7
                  stty bits=8 (значение по умолчанию)

       Этот параметр определяет,  сколько битов, следующих за старто-
  вым  битом,  будет  использоваться,  чтобы сформировать минимальную
  порцию для приема символа.

       Биты останова

       Данные можно передать,  если за ними следуют один или два бита
  останова. Два бита останова используются только для замедления всей
  передачи данных так,  чтобы удаленный конец мог поддерживать связь.
  Используя stty, Вы определяете одну из следующих команд:

                  stty stopb=1 (значение по умолчанию)
                  stty stopb=2

       Четность

       Для того, чтобы заблокировать передачу битов четности и исклю-
  чить  проверку  (в  аппаратных средствах) принимаемых битов на чет-
  ность, Вы задаете:

                  stty par=none (значение по умолчанию)

                               - 78 -


        Если четность используется,  Вы должны выдать одну из следую-
  щих команд:

                  stty par=odd
                  stty par=even
                  stty par=mark
                  stty par=space

       Скорость передачи в бодах

       Вы можете определить скорость  передачи  в  бодах  опцией  ba-
  ud=number утилиты stty:

                  stty baud=number

       QNX определяет   по   умолчанию   скорость   передачи,  равную
  9600 бод.

       7.3.4. Соединение последовательных устройств

       Быстродействующие ECC-модемы

       Быстродействующие модемы  с  исправлением  ошибок   становятся
  очень сложными устройствами - они работают наилучшим образом, когда
  задействованы все сигналы аппаратного квитирования связи. Эти моде-
  мы часто взаимодействуют с главным компьютером на фиксированной вы-
  сокой скорости передачи  (например,  38400 бод)  и  используют  ли-
  нии RTS/CTS  квитирования  связи,  чтобы отрегулировать фактический
  поток данных через линию связи.  QNX идеально подходит для работы с
  такими  модемами.  Простой многожильный кабель используется,  чтобы
  соединить модем и компьютер.
.
                               - 79 -


  ┌────────────────────────────────────────────────────┐
  │  ┌─────────┐                       ┌───────────┐   │
  │  │         │ ─────────Gnd───────── │           │   │
  │  │         │ ──────────Tx───────── │           │   │
  │  │         │ ──────────Rx───────── │           │   │
  │  │         │ ─────────RTS───────── │   Высоко- │   │
  │  │         │ ─────────CTS───────── │ скоростной│   │
  │  │Компьютер│ ─────────DSR───────── │   модем   │   │
  │  │         │ ─────────DTR───────── │           │   │
  │  │         │ ──────────CD───────── │           │   │
  │  │         │ ──────────RI───────── │           │   │
  │  │         │                       │           │   │
  │  └─────────┘                       └───────────┘   │
  └────────────────────────────────────────────────────┘

                               Рис.8.
          Разводка кабеля для соединения компьютера и
                  быстродействующего модема

       Используя утилиту stty, Вы можете установить аппаратное квити-
  рование связи в обоих направлениях и заблокировать его:

		stty +ihflow +ohflow +lkhflow </dev/ser1

       Иначе, Вы  могли бы установить и заблокировать аппаратное кви-
  тирование связи при запуске Dev.ser:

                  Dev.ser -f 3f8, 4 &

       Стандартные модемы

       Более старые модемы - менее сложные устройства. После установ-
  ления один раз канала связи на одну из скоростей передачи,  поддер-
  живаемых этим модемом,  вся последующая связь  через  линию  модема
  происходит только с этой скоростью передачи.  Другими словами,  все
  передаваемые данные просто пропускаются по линии модема  с  той  же
  самой скоростью,  которая установлена.  Хотя эти модемы естественно
  не поддерживают аппаратное управление потоком данных,  они не будут
  функционировать правильно, пока все четыре линии управления потоком
  данных не связаны. Вам не нужно использовать опции управления пото-
  ком данных stty при использовании этих модемов.  Для соединения мо-
  дема и компьютера используется плоский многожильный кабель.


                               - 80 -

  ┌────────────────────────────────────────────────────────────┐
  │                                                            │
  │     ┌─────────────┐                     ┌────────────┐     │
  │     │             │ ────────Gnd──────── │            │     │
  │     │             │ ─────────Tx──────── │            │     │
  │     │             │ ─────────Rx──────── │            │     │
  │     │  Компьютер  │ ────────RTS──────── │ Стандартный│     │
  │     │             │ ────────CTS──────── │   модем    │     │
  │     │             │ ────────DSR──────── │            │     │
  │     │             │ ────────DTR──────── │            │     │
  │     │             │ ─────────CD──────── │            │     │
  │     │             │ ─────────RI──────── │            │     │
  │     └─────────────┘                     └────────────┘     │
  │                                                            │
  └────────────────────────────────────────────────────────────┘

                               Рис.9.
  Разводка кабеля для соединения компьютера и стандартного модема


       Последовательные принтеры

       Последовательные принтеры - обычно двунаправленные устройства.
  Данные передаются из компьютера на принтер,  но,  т.к.  принтеры не
  могут работать синхронно с  главным  компьютером,  последовательные
  принтеры  часто  используют  программное управление потоком данных,
  чтобы отрегулировать поток данных.  Другими словами,  они  передают
  символы СТАРТ-СИГНАЛ и СТОП-СИГНАЛ в компьютер.  Некоторые принтеры
  используют аппаратные линии подтверждения  установления  связи  для
  этой  цели,  а  некоторые поддерживают обе формы управления потоком
  данных. Для безопасности, Вам следует соединить все девять сигналь-
  ных линий, хотя принтеры, которые используют только программное уп-
  равление потоком данных  могут  функционировать  так  же  хорошо  с
  трехпроводным кабелем (Rx,  Tx и Gnd).  Кроме того,  т.к.  принтеры
  обычно включены в конфигурацию, как Терминальное Оборудование Поль-
  зователя,  подобно главному компьютеру,  Вы можете использовать ка-
  бель нуль-модема.
.
                               - 81 -


  ┌─────────────────────────────────────────────────────────────────┐
  │      ┌────────┐                   ┌───────┐       ┌───────┐     │
  │      │        │ ───────Gnd─────── │───────│ ───── │       │     │
  │      │        │ ────────Tx─────── │─     ─│ ───── │       │     │
  │      │        │ ────────Rx─────── │─     ─│ ───── │       │     │
  │      │        │ ───────RTS─────── │-     -│ ───── │       │     │
  │      │        │ ───────CTS─────── │-     -│ ───── │       │     │
  │      │        │ ───────DSR─────── │-     -│ ───── │       │     │
  │      │        │ ───────DTR─────── │-     -│ ───── │       │     │
  │      │        │ ────────CD─────── │───────│ ───── │       │     │
  │      │        │ ────────RI─────── │───────│ ───── │       │     │
  │      └────────┘                   └───────┘       └───────┘     │
  │       Компьютер                     Кабель      Последовательный│
  │                                   нуль-модема      принтер      │
  │                                                                 │
  └─────────────────────────────────────────────────────────────────┘

                               Рис.10.
        Разводка кабеля для соединения компьютера и посимвольного
                       печатающего устройства



  ────────────────────────────────────────────────────────────────────
  Если принтер использует:                    Вы используйте:
  ───────────────────────────────────────────────────────────────────
  программное управление потоком данных   stty +osflow </dev/ser1

  аппаратное управление потоком данных    stty +ohflow </dev/ser1

  программное и аппаратное управление
  потоком данных                          обе опции stty
  ───────────────────────────────────────────────────────────────────

       Терминалы

       Терминалы работают с управлением потоком данных или без управ-
  ления и с фиксированной скоростью передачи.  В отличие от принтеров
  терминалы могут работать синхронно с главным компьютером на поддер-
  живаемой скорости передачи. Таким образом, достаточно трехпроводно-
  го кабеля,  хотя Вы можете также использовать  девятипроводной  ка-
  бель.  Подобно главному компьютеру, терминалы включены в конфигура-
  цию,  как Терминальное Оборудование Пользователя,  так  что  обычно

                               - 82 -

  требуется кабель нуль-модема.

  ┌──────────────────────────────────────────────────────────────┐
  │  ┌────────┐                    ┌─────────┐        ┌────────┐ │
  │  │        │                    │         │        │        │ │
  │  │        │ ───────Gnd──────── │─────────│ ────── │        │ │
  │  │        │ ────────Tx──────── │─       ─│ ────── │        │ │
  │  │        │ ────────Rx──────── │─       ─│ ────── │        │ │
  │  │        │ -------RTS-------- │─       ─│ ------ │        │ │
  │  │        │ -------CTS-------- │─       ─│ ------ │        │ │
  │  │        │ -------DSR-------- │─       ─│ ------ │        │ │
  │  │        │ -------DTR-------- │─       ─│ ------ │        │ │
  │  │        │ --------CD-------- │─────────│ ------ │        │ │
  │  │        │ --------RI-------- │─────────│ ------ │        │ │
  │  └────────┘                    └─────────┘        └────────┘ │
  │   Компьютер                      Кабель            Терминал  │
  │                                нуль-модема                   │
  └──────────────────────────────────────────────────────────────┘

                               Рис.11.
              Разводка кабеля для соединения компьютера
                             и терминала

       Если Ваш терминал поддерживает программное управление  потоком
  данных (например,  VT100),  то рекомендуется установить программное
  управление и блокировки выходного потока данных:

                  stty +osflow +lksflow </dev/ser1

       Как альтернативу, Вы могли бы использовать опцию -x при запус-
  ке Dev.ser.

       7.3.5. Выбор  конфигурации последовательных линий для термина-
  лов и пользователей

       QNX может использоваться в качестве системы разделения времени
  с  полным набором функциональных возможностей.  Многие пользователи
  могут быть подключены к нескольким компьютерам  в  сети  QNX  через
  устройства  типа терминала или через модемные линии к терминалам на
  удаленных вычислительных центрах.  Предположим,  что терминал/модем
  правильно  включен  в конфигурацию,  Вам нужно обеспечить в системе
  механизм, позволяющий пользователям "входить в систему".

       Простой пример

                               - 83 -


       Рассмотрим терминал, правильно включенный в конфигурацию через
  последовательный  порт  /dev/ser1.  Самый  простой способ разрешить
  пользователю этого терминала войти в систему - использовать  коман-
  ду:

                  ontty /dev/ser1 login

       Пользователь сможет войти в систему и выполнять команды. Одна-
  ко после выхода из системы (то есть, как только пользователь завер-
  шит этот сеанс работы), он не сможет снова зарегистрироваться.

       Автоматизированный вход

       Для того,  чтобы автоматизировать процесс входа, Вы можете ис-
  пользовать утилиту tinit.  Эта утилита  проследит  за  определенным
  устройством,  ожидая нажатия любой клавиши на этом терминале. Затем
  login выполнится автоматически.  Когда пользователь вошел в систему
  и затем вышел снова,  tinit будет ждать нажатия другой клавиши. Для
  запуска login от нажатия клавиш  данных  на  двух  последовательных
  устройствах,  названных /dev/ser1 и /dev/ser2,  Вы можете использо-
  вать следующую команду:

                  tinit -T /dev/ser1 /dev/ser2 &

       Допустим, взамен Вы захотели, чтобы login автоматически выпол-
  нялись без ожидания нажатия клавиши пользователем.  Вам следует ис-
  пользовать опцию -t:

                  tinit -t /dev/ser1 /dev/ser2 &

       Запуск заданных приложений

       Вы не должны всегда запускать login.  Вы можете определить лю-
  бую  программу  или даже определить разные программы на каждое уст-
  ройство.  В некоторых средах "закрытое" приложение всегда ожидается
  на данном терминале. Для получения дополнительной информации, смот-
  рите tinit в "Utilities Reference".

       Доступ к модему

       Довольно легко компоновать аппаратные средства типа терминала,
  т.к. все возможные значения параметров - известны. Модемы, с другой
  стороны,  создают особые проблемы, т.к. они могут иметь разные кон-

                               - 84 -

  фигурации в разное время.  Например, большинство модемов ответят на
  вызов по одной из нескольких скоростей (300, 1200, 2400 и т.п.). Вы
  не можете всегда знать заранее скорость передачи поступающего вызо-
  ва.  Специальная утилита, названная modem, предназначена для работы
  с модемами.  Используемая с tinit,  modem может обеспечить отличные
  коммутируемые возможности.  Типичная коммутируемая система, исполь-
  зующая   QNX,  могла  бы  иметь  различные  последовательные  порты
  (/dev/ser1, /dev/ser2 и т.п.) и могла бы использовать следующую ко-
  манду,  чтобы разрешить подключаемый доступ через Hayes-совместимые
  модемы:

                  tinit -c modem -t /dev/ser1 /dev/ser2 &

       Чтобы подключить модем,  который использует фиксированную ско-
  рость передачи, Вы могли бы использовать следующую команду:

                  tinit -c "модем -b 38400 -L" -t /dev/ser1 &

       Утилита tinit  автоматически запустит modem для каждой из пос-
  ледовательных линий.
       Когда связь установлена,  утилита modem:
       - ответит на телефонный звонок;
       - определит и установит соответствующую скорость  передачи;
       - выполнит login.
       Когда пользователь или завершает сеанс или отключается,  tinit
  снова  запустит утилиту modem,  которая будет ждать другого вызова.
  Для получения дополнительной информации смотрите modem в "Utilities
  Reference".
       Следует отметить,  что Вам не нужно выделять  последовательную
  линию  для поступающих вызовов.  Эмулятор терминала qtalk проверяет
  свободна ли линия и,  если так,  подключит modem,  позволяя принять
  поступающий вызов. Когда сеанс qtalk будет завершен, управление бу-
  дет снова передано утилите modem,  которая будет ждать прихода пос-
  тупающих вызовов.  Для получения дополнительной информации смотрите
  qtalk в "Utilities Reference".

       База данных terminfo

       Полноэкранные программы в QNX имеют доступ к базе данных  опи-
  сания терминалов,  известной, как база данных terminfo, которая вы-
  полнена, как набор файлов в каталоге /usr/lib/terminfo. Для каждого
  терминала,  поддерживаемого в QNX,  существует отдельный файл. Т.к.
  эти файлы имеют промышленный стандартный  формат,  они  могут  быть
  распространены  между  различными системами UNIX.  Ваша система QNX

                               - 85 -

  должна будет загрузить некоторые из этих файлов со следующими  име-
  нами:

          /usr/lib/terminfo/q/qnx         (консоль QNX)
          /usr/lib/terminfo/v/vt100       (терминал VT100)

       Программа QNX получает доступ к соответствующему файлу в базе
  данных  при  условии,  что внешняя переменная TERM была определена.
       Если у Вас нет terminfo файла для Вашего типа терминала, то Вы
  можете попытаться сделать следующее:
       - получить доступ к Quantum Update Service (QUICS) и загрузить
  terminfo файл (если он существует);
       - получить доступ к другой системе UNIX и подыскать подходящий
  terminfo файл;
       - использовать  infocmp  и  tic,  чтобы настроить Ваш terminfo
  файл в соответствии с информацией из справочника для Вашего  терми-
  нала.

       Определение типа терминала

       Полноэкранные программы используют  внешнюю  переменную  TERM,
  чтобы определить, какой тип терминала в настоящее время использует-
  ся. Они также автоматически контролируют их работу, чтобы правильно
  отображать  данные и интерпретировать клавиши для этого типа терми-
  нала.  Это будет работать при условии,  что внешняя переменная TERM
  правильно определена. Для аппаратных средств типа терминалов, рабо-
  тающих под управлением закрытых приложений,  Вы можете проинициали-
  зировать эту внешнюю переменную, когда приложение запускается. Нап-
  ример:

                  TERM=vt100 ontty /dev/ser1 custom_application

       Однако, вход пользователей  в  систему  через  login  и  tinit
  представляет  специальную  проблему.  Если  тип терминала известен,
  тогда с помощью tinit можно определить эту внешнюю переменную перед
  запуском login:

                  tinit -c login -t /dev/ser1 TERM=vt100 &

       Если Вы ограничиваете коммутируемый доступ только к конкретно-
  му типу терминала,  тогда пользователи модема должны выполнить спе-
  циальную программу,  чтобы запросить пользователя о типе его терми-
  нала.  В QNX такая программа предусмотрена,  она имеет имя termdef.
  Эта программа отобразит все типы терминалов,  поддерживаемые в этой

                               - 86 -

  системе и предложит пользователю выбрать один из них.  После выбора
  типа  терминала termdef соответственно установит внешнюю переменную
  TERM, затем выполнит login.

                  tinit -c "modem -c termdef" -t /dev/ser1 &

       7.3.6. Проблемы тестирования последовательных устройств

       Следующая таблица предлагает Вам выполнить действия,  если  Вы
  встретите некоторые общие проблемы при подключении последовательных
  устройств.

  ───────────────────────────────────────────────────────────────────
  Проблема            Возможная причина              Средство
  ───────────────────────────────────────────────────────────────────
  Не распознаются      Неправильно установ-    Используйте утилиту stty
  символы данных       лены скорость передачи  для установки правильной
                       или признак четности    скорости передачи и/или
                                               признака четности
  ───────────────────────────────────────────────────────────────────
  Некоторые символы    Неправильно установлен  Попробуйте изменить приз-
  отображаются хоро-   признак четности        нак  четности, используя
  шо, некоторые нет                            утилиту stty
  ───────────────────────────────────────────────────────────────────
  Нельзя ни передать,  Неисправен кабель       Проверьте  кабель,  если
  ни принять данные    нуль-модем              потребуется, используйте

  Неисправны порты   Проверьте аппаратные установки и параметры Dev.ser
  ввода/вывода

  Конфликт прерываний    Измените прерывание или адаптерную плату
  ───────────────────────────────────────────────────────────────────
  Данные принимаются   Конфликт прерываний     Проверьте аппаратные пре-
  и передаются, толь-                          рывания  и  параметры за-
  ко когда использу-                           пуска Dev.ser. Убедитесь,
  ется другой после-                           что два последовательных
  довательный порт                             адаптера  не   используют
                                               одно    и   то   же   IRQ
  ───────────────────────────────────────────────────────────────────
  Случайные потери     Поддерживается управ-   Определите тип управления
  данных               лением потоком, но      потоком,  поддерживаемого
                       оно отключено           устройством   и  включите
                                               его утилитой  stty  (ihf-
                                               low,   ohflow,  isflow  и

                               - 87 -

                                               osflow)

  Управление потоком   Уменьшите скорость передачи и/или увеличьте коли-
  не поддерживается    чество стоп-битов; если теряются только принимае-
                       мые данные,  увеличьте входной буфер для  Dev.ser
                       (опция -I)
  Проблемы с кабелем   Убедитесь, что  кабель хорошо заземлен и не слиш-
                       ком длинный.  Также убедитесь,  что  все  провода
                       стыка RS-232 подключены.
  ───────────────────────────────────────────────────────────────────
.
                               - 88 -


              Глава 8. УСТАНОВКА ВТОРОЙ ФАЙЛОВОЙ СИСТЕМЫ

       В этой главе...

       Разделение пространства полных имен
       Установка файловой системы DOS

       8.1. Введение

       Файловая система,  определяемая корнем (/),  может состоять из
  одной или более физических файловых систем,  скомпонованных вместе.
  Физическая  файловая система - это отдельный диск или раздел.  Одна
  из физических файловых систем, естественно, должна быть корнем (/),
  тогда как другие файловые системы устанавливаются, как подкаталоги.
  Эти подкаталоги могут существовать или на диске,  как  в  случае  с
  символическими связями,  или в независимом пространстве,  названном
  деревом префиксов.  Дерево префиксов отображает полные имена  адми-
  нистраторам ввода/вывода,  которые в свою очередь устанавливают со-
  ответствие с дисками и устройствами.  Во всех примерах в этой главе
  дерево  префиксов  используется  для разделения пространства полных
  имен.  Для получения дополнительной информации о  дереве  префиксов
  смотрите в "Архитектуре системы" главу "Пространство имен ввода/вы-
  вода".

       8.2. Разделение пространства полных имен

       Следующие примеры  должны  помочь  разъяснить,  как  разметить
  пространство имен маршрутов.  Мы рассмотрим следующие конфигурации:
  - жесткий диск и флоппи-дискета; - два жестких диска; - два или бо-
  лее QNX-разделов; - локальные и удаленные жесткие диски.

       ВНИМАНИЕ. В  этих примерах,  мы предполагаем,  что Fsys также,
                 как и соответствующие драйверы,  запущены и что  ко-
                 манда mount -p была выдана на Ваш жесткий диск.

       8.2.1. Жесткий диск и флоппи-дискета

       Жесткий диск  монтируется,  как наклонная черта вправо (/),  и
  формируется корень файловой системы.  Флоппи-дискета устанавливает-
  ся, как /fd0:

                  mount /dev/hd0t77 /
                  mount /dev/fd0 /fd0

                               - 89 -


       Любая ссылка на полное имя, начинающееся с /fd0, будет направ-
  ляться к файловой системе QNX на флоппи-дискету. Например, команда:

                  ls -aR /fd0

  отображает все файлы на флоппи-дискете.

       8.2.2. Два жестких диска (на одном узле)

       Первый жесткий  диск  смонтирован,  как  наклонная черта впра-
  во (/),  и формируется корень файловой системы. Второй жесткий диск
  установлен, как /home2:

                  mount /dev/hd0t77 /
                  mount /dev/hd1t77 /home2

       Любая ссылка на полное имя,  начинающееся с /home2, будет нап-
  равляться к файловой системе QNX на втором жестком диске. Например,
  команда:

                  ls -aR /home2

  отображает все файлы на втором жестком диске.

       8.2.3. Два или более разделов QNX

       Вы можете иметь три раздела QNX на одном жестком диске. Первый
  раздел должен иметь тип 77 (смотрите утилиту fdisk в "Utilities Re-
  ference"). Второму разделу должен быть назначен тип 78 и третьему -
  тип 79.

       Например:

                  mount /dev/hd0t77 /
                  mount /dev/hd0t78 /home2

       Любая ссылка на полное имя,  начинающееся с /home2 будет  нап-
  равляться к файловой системе QNX во втором разделе.  Например,  ко-
  манда:

                  ls -aR /home2

  отображает все файлы во втором разделе.

                               - 90 -

       8.2.4. Локальные и удаленные жесткие диски

       В сети Вы можете иметь диски с файловой системой QNX  в  более
  чем  одной  машине.  Вы можете скомпоновать их так, чтобы они были:
       - независимыми;
       - первичными/вторичными;
       - связно-независимыми.

       ВНИМАНИЕ. В следующих примерах локальные файловые системы свя-
                 зываются с  блочными специальными файлами (например,
                 /dev/hd0t77),  а удаленные файловые системы связыва-
                 ются  с  отображениями  префиксов полных имен.  Этот
                 префикс переназначает запросы к  удаленной  файловой
                 системе,  которая  будет связана с удаленным блочным
                 специальным файлом.

       Независимая

       В этой конфигурации Вы рассматриваете каждую машину, как неза-
  висимую,  с замкнутой файловой системой.  Для того, чтобы управлять
  файлом в удаленной машине, Вы должны в начале полного имени указать
  номер узла удаленной машины. Например:

          /etc/motd       файл локальной файловой системы
          //10/etc/motd   файл удаленной файловой системы (узел 10)

       Определение файловой системы  для  конкретного  узла  работает
  всегда, как наиболее общий механизм для доступа к удаленным файлам.

       Первичная/вторичная

       В этой  конфигурации  Вы рассматриваете одну файловую систему,
  как первичную, и устанавливаете вторую файловую систему, как подка-
  талог в первичной.  Например, предположим, что узел 1 имеет первичную
  файловую систему,  а узел 2 - вторичную,  установленную,  как /home2.
  Узел 1 загружен с жесткого диска и имеет корень, установленный на его
  локальном диске утилитой mount и построенный в образе  операционной
  системы (с Fsys и драйвером).  Его файл системной инициализации вы-
  зывает утилиту prefix,  чтобы установить удаленную файловую систему
  следующим образом:

                  prefix -A /home2=//2/home2

       Узел 2 загружается через сеть из узла 1 и имеет корень  файло-

                               - 91 -

  вой системы, установленный /=//1/, используя утилиту sinit с опцией
  -r операционной системы.  Его файл системной инициализации вызывает
  утилиту mount,  чтобы установить локальную файловую систему следую-
  щим образом:

       mount /dev/hd0t77 /home2

       Администратор файловой системы (Fsys) и его драйвер могут быть
  включены в образ,  но более предпочтительно запускать их  из  файла
  системной инициализации.  Другими словами,  узел  2  загружен,  как
  простая бездисковая рабочая станция, которая стартует со своей фай-
  ловой системой после загрузки.  Оба узла 1 и 2 будут иметь  доступ  к
  файловой системе на узле 1, как /, а на узле 2, как /home2.

       Связно-независимая

       В этой конфигурации Вы рассматриваете каждую машину, как неза-
  висимую,  с замкнутой файловой системой, но Вы компонуете их вместе
  через утилиту prefix.  Например,  допустим, что файловая система на
  узле 1 имеет каталог /home1, а файловая система на узле 2 имеет ка-
  талог /home2.  Вы могли бы отобразить каждый каталог home в область
  другой файловой системы следующим образом:

          В узле 1:                       В узле 2:

          prefix -А /home2=//2/home2      prefix -A /home1=//1/home1

       Вместе с  тем,  каждая  файловая  система  автономна со своими
  собственными копиями /bin и т.п.  Преимущество -  большая  избыточ-
  ность: если один отдел использует узел 2, и узел 1 отключается, от-
  дел,  используя  узел  2,  может продолжать работу (кроме файлов из
  /home1, которые не будут доступны).

       ВНИМАНИЕ. Вместо  использования  префиксов в разделении прост-
                 ранства полных имен, Вы можете использовать символи-
                 ческие связи.  Более полное описание смотрите в "Ар-
                 хитектуре системы" в главе 5 "Администратор файловой
                 системы".

       8.3. Установка файловой системы DOS

       Администратор файловой  системы Dosfsys обеспечивает полностью
  прозрачный доступ к файлам DOS и каталогам,  которые  находятся  на
  диске DOS. Dosfsys может поддерживать до восьми накопителей. Вы мо-

                               - 92 -

  жете создавать файлы на дисках DOS, читать, записывать и удалять их
  c  использованием большинства программ QNX.  Вы можете также созда-
  вать, читать и удалять каталоги на дисках DOS стандартными утилита-
  ми QNX,  такими как, например, mkdir, ls и rmdir. Большинство стан-
  дартных утилит QNX будут работать с файлами DOS  при  условии,  что
  структура файлов DOS соответствует функциональному запросу утилиты.
  Ваши собственные программы также смогут обрабатывать файлы DOS точ-
  но  так же,  как они обрабатывают файлы QNX,  используя стандартные
  функции ввода/вывода open(),  read(),  write(),  close(),  seek() и
  т.п. Когда Вы читаете каталоги DOS, они представлены в формате QNX.

       8.3.1. Режимы вызова

       Dosfsys имеет четыре режима вызова:

       Dosfsys [-S|s] [-e] [-m] [-t] [dos_drive=qnx_drive[,R]]... &
       Dosfsys -i [-n node] [dos_drive_path]...
       Dosfsys -o [-n node]
       Dosfsys -x [-n node]

       Опция -i позволяет Вам получать информацию о накопителях  DOS,
  установленных  в  настоящее  время.  Опция -o позволяет Вам увидеть
  имена любых файлов,  открытых к настоящему времени на  каждом  уст-
  ройстве.  Опция -x завершает работу сервера Dosfsys. Если Вы не за-
  даете -i,  -o или -x,  Dosfsys будет запускаться и пытаться настро-
  иться на определенные накопители.  Для того, чтобы запустить сервер
  Dosfsys или завершить его работу,  Вы должны войти в  систему,  как
  суперпользователь (root).

       8.3.2. Запуск Dosfsys

       Когда Вы запускаете Dosfsys, он:
       - открывает определенный накопитель(накопители);
       - принимает имя /dos, как корень DOS;
       -регистрирует имя qnx/dosfsys в локальном Администраторе  про-
  цессов.
       Если никакие опции не были определены  или  если  было  задано
  -S или -s,  Dosfsys просматривает каталог /dev для настройки на за-
  данные накопители DOS. Если в командной строке ничего дополнительно
  не  указано,  Dosfsys настраивается максимум на восемь накопителей.
  Первичные разделы DOS (/dev/hd0t1,  /dev/hd0t4,  /dev/hd0t6,...)  и
  разделы  расширения  (/dev/hd0t1.1,  /dev/hd0t1.2,...) монтируются,
  начиная с накопителя C (/dos/c). Накопители на гибких дисках монти-
  руются следующим образом:

                               - 93 -


                  /dev/fd0 ───> /dos/а
                  /dev/fd1 ───> /dos/b

       8.3.3. Восприятие имен Dosfsys

       Dosfsys может настраиваться максимум  на  восемь  накопителей.
  Как отмечалось выше, Dosfsys принимает имя /dos, как системный пре-
  фикс.  Он также будет управлять каждым специфическим именем накопи-
  теля, таким как /dos/а, /dos/b и т.п. Эти имена не регистрируются в
  системном префиксном дереве,  но содержатся непосредственно в Dosf-
  sys. Это обеспечивает прозрачный доступ пользователю за исключением
  того, что пользователь не может создавать файлы или каталоги в кор-
  не /dos.

       8.3.4. Устройства DOS

       Устройством DOS может быть одно из следующих:
       - раздел DOS на жестком диске;
       - флоппи-дискета;
       - образ раздела DOS или дискеты.
       Для того, чтобы создать образ дискеты DOS или раздела DOS, ис-
  пользуйте утилиту cp QNX. Например, для того, чтобы скопировать об-
  раз флоппи DOS на Ваш накопитель на гибких дисках, используйте сле-
  дующее:

                  cp /dev/fd0                     /usr/qnx/dosa

  и затем вызывайте Dosfsys следующим образом:

                  Dosfsys a=/usr/qnx/dosa &

       То же самое можно сделать с разделом жесткого  диска.  Dosfsys
  будет оперировать с этими образами также, как и с фактическими уст-
  ройствами.  Для всех несменных устройств Dosfsys немедленно  читает
  блок параметров загрузки DOS (BPB), а также начальную часть таблицы
  размещения записей файла (FAT). Для сменных устройств BPB и FAT чи-
  тается только тогда, когда накопитель доступен. Когда Dosfsys имеет
  открытое несменное устройство,  устройство  блокируется  на  запись
  так,  что  никакой  другой  процесс не может ничего записать на это
  устройство,  минуя Dosfsys. Сменные устройства остаются открытыми и
  блокированными только в момент обращения (например,  в течение чте-
  ния или записи на диск).  Имейте в виду,  что если Вы не задали оп-
  цию R, все накопители имеют доступ на чтение/запись.

                               - 94 -


       8.3.5. Поддерживаемые версии DOS

       Администратор Dosfsys поддерживает все разделы DOS, форматиру-
  емые в DOS 2.1 или выше,  включая стандартные начальные разделы  DOS,
  большие разделы DOS (DOS 4.0 и DOS 5.0 >32M), и расширенные разделы
  DOS (тип 5). Поддержаны жесткие диски, флоппи-дискеты 5 1/4 дюйма и
  3 1/2 дюйма.

       Типы разделов DOS

       Стандартные типы разделов жесткого диска DOS:

  ───────────────────────────────────────────────────────────────────
  Тип раздела:    Описание:
  ───────────────────────────────────────────────────────────────────
          1       Начальный раздел DOS (12-бит FAT)
          4       Начальный раздел DOS (16-бит FAT;  7, 032M)
          5       Расширенный раздел DOS (DOS 3.3 или старше)
          6       Начальный раздел DOS (DOS 4.0 или старше; >32M)
  ───────────────────────────────────────────────────────────────────

       8.3.6. Текстовые файлы DOS

       Структура текстовых  файлов  DOS отличается от структуры,  ис-
  пользуемой в  QNX  (под  текстовым  файлом  понимаются  строки  AS-
  CII-текста, разделяемые последовательностями разделителей строк). В
  DOS каждая строка текстового файла завершается  последовательностью
  возврат каретки/перевод строки (CR/LF),  в то время, как в QNX каж-
  дая строка завершена символом перевода  строки (LF).
       Администратор Dosfsys не  преобразует  эти  файлы.  Все  файлы
  рассматриваются "так, как есть".
       Таким образом, Вы должны использовать утилиту textto QNX, что-
  бы преобразовать Ваши текстовые файлы перед копированием их на (или
  из) QNX и DOS-диски.
       Имейте также в виду то, что текстовые файлы, создаваемые неко-
  торыми программами DOS могут содержать символ (^z),  как  последний
  символ файла. Это также рассматривается так, как есть.

       8.3.7. Двоичные файлы DOS

       Т.к. Dosfsys не преобразует содержимое файлов,  двоичные файлы
  будут скопированы на (или из) QNX/DOS разделов без изменения.


                               - 95 -

       8.3.8. Преобразование символов и имен из QNX в DOS

       В DOS Вы не можете включить никакой из  этих  символов  в  имя
  файла:

                  / \ [ ] : * | + = ; , ?

       Также Вы не можете использовать следующие имена файлов:

          CLOCK$  CON     PRN
          NUL     AUX     COM1
          COM2    COM3    COM4
          LPT1    LPT2    LPT3

       Если Вы пытаетесь создать файл, который содержит один из недо-
  пустимых  символов DOS или он имеет запрещенное имя файла,  то Ваша
  попытка будет отвергнута.  Т.к.  все имена файлов и все  символы  в
  имени файла в QNX допустимы, никаких разрешений на эти имена файлов
  не требуется.  DOS также отображает все алфавитные символы на верх-
  нем  регистре,  поэтому при создании имени файла Dosfsys отображает
  эти символы на верхнем регистре;  DOS при возврате в приложение QNX
  имя файла отображает на нижнем регистре.

       Преобразование имен файлов QNX

       Если Вы задаете -t при запуске Dosfsys, сервер переведет и/или
  исключит любые имена файлов QNX,  которые не соответствуют правилам
  присваивания имен в DOS.  Следующая таблица описывает, как преобра-
  зовываются имена:

  ───────────────────────────────────────────────────────────────────
  Если имя файла QNX:                 Dosfsys будет:
  ───────────────────────────────────────────────────────────────────
  начинается с точки: .       точка изменяется на $

  содержит несколько точек    изменяются все точки на $, кроме
                              последней

  имеет префикс длиннее       преобразует префикс в восемь символов
  восьми символов

  имеет суффикс длиннее       преобразует суффикс в три символа
  трех символов
  ───────────────────────────────────────────────────────────────────

                               - 96 -


       Вот некоторые примеры:

  ─────────────────────────────────────────────────
  Имя файла QNX:                  Имя файла DOS:
  ─────────────────────────────────────────────────
  .profile                        $profile
  a.b.c.d                         $a$b$c.d
  longfilename                    longfile
  longfilename.extension          longfile.ext
  a..b..c.def.g.h                 a$$b$$c$.h
  ─────────────────────────────────────────────────

       8.3.9. Метки тома DOS

       DOS использует понятие метки тома,  которое является фактичес-
  ким входом в корневой каталог файловой системы DOS. Для того, чтобы
  отличать метки тома от фактического файла DOS, Dosfsys устанавлива-
  ет знак равенства (=) первым символом в имени метки  тома.  Dosfsys
  рассматривает  эту метку тома,  как файл с нулевой длиной,  который
  открыт только на чтение и доступ к которому не может быть изменен.

       8.3.10. Преобразование атрибутов доступа DOS/QNX

       DOS не использует все биты доступа, которые имеются в QNX. DOS
  рассматривает биты доступа следующим образом:

                  READ_ONLY - только для чтения
                  HIDDEN - скрытый
                  SYSTEM - системный
                  VOLUME_LABEL - метка тома
                  DIRECTORY - каталог
                  ARCHIVE - архивный

       Преобразование битов-атрибутов

       Dosfsys использует следующую логику,  чтобы преобразовать  би-
  ты-атрибуты из QNX в DOS: - если на входе - каталог, устанавливает-
  ся бит DIRECTORY DOS - если на входе - файл и, если все биты записи
  QNX отсутствуют, то устанавливается бит READ_ONLY

       Преобразование битов доступа

       Используется следующая логика, чтобы преобразовать биты досту-

                               - 97 -

  па из DOS в QNX:

       - в QNX устанавливается бит "чтение" для пользователя,  группы
  и других пользователей;

       - если  на  входе  не метка тома и если обращение не только на
  чтение, в QNX устанавливается бит разрешения записи для пользовате-
  ля, группы и других пользователей;

       - если на входе каталог,  в QNX устанавливаются биты "каталог"
  и "выполняемый" для пользователя, группы и других пользователей;

       - если на входе файл,  в QNX устанавливается  бит  "регулярный
  файл".

       ВНИМАНИЕ. Если  файл  записывается,  в DOS устанавливается бит
                 "архивный". Если Dosfsys стартовала  с  опцией -e,
                 все  файлы и каталоги DOS будут иметь в QNX бит "вы-
                 полняемый",  установленный для группы/владельца/дру-
                 гих пользователей.

       8.3.11. Владелец файла

       Хотя файловая система DOS не поддерживает идентификаторы поль-
  зователя и группы, Dosfsys не возвращает код ошибки, если была сде-
  лана  попытка изменить ID группы или ID пользователя утилитой chown
  или библиотечной функцией chown(). Поэтому много утилит, использую-
  щих  библиотечную  функцию chown(),  которая  могла бы в результате
  дать много сообщений об ошибке,  работают без  выдачи  ошибок.  Все
  файлы  под  Dosfsys,  принадлежащие суперпользователю (uid=0,  gro-
  up=0), доступны всем.

       8.3.12. Завершение Dosfsys

        Опция -x завершает работу сервера Dosfsys.  Если  Вы  задаете
  -x,  никакие  новые  запросы open() приниматься не будут,  и сервер
  закрывает все активные файлы (то есть файлы,  которые все еще оста-
  ются открытыми).

       8.3.13. Коды ошибок, возвращаемые Dosfsys

       Если запрос, сделанный приложением, не поддерживается Dosfsys,
  возвращается код ошибки EOPNOTSUPP.  Примеры запросов, не поддержи-
  ваемые Dosfsys, приведены ниже:

                               - 98 -


                  LINK
                  BLOCK_READ
                  BLOCK_WRITE
                  MOUNT_PARTITION
                  MOUNT_RAMDISK
                  PIPE
                  DISK_GET_ENTRY
                  RECORD LOCKING
                  SYMBOLIC LINK

       Если Dosfsys обнаружит искажения файловой системы,  он возвра-
  щает код EBADFSYS,  после чего Вы можете  выполнить  утилиту CHKDSK
  под DOS, чтобы скорректировать искажения. Структура файловой систе-
  мы DOS такая,  что размер корневого каталога фиксируется  во  время
  форматирования и не может меняться.  Если корневой каталог перепол-
  няется, выдается ошибка (ENOSPC).
.
                               - 99 -


                  Глава 9. РАЗВИТИЕ КОНФИГУРАЦИИ СЕТИ

       В этой главе...

       Множество серверов загрузки
       Многосвязная сеть
       Выбор конфигурации многосвязной сети

       9.1. Введение

       В этой  главе Вы узнаете об установке нескольких серверов заг-
  рузки;  Вы также узнаете о выборе конфигурации  нескольких  сетевых
  связей на одном компьютере. Прежде чем выполнить любую из описанных
  здесь операций, Вы должны сначала установить сеть QNX, которая име-
  ет сервер загрузки (смотри главу 5  0"Установка сети").

       9.2. Множество серверов загрузки

       Вы можете установить в Вашей сети несколько серверов загрузки,
  чтобы обеспечить отказоустойчивость в случае, если откажет Ваш сер-
  вер первичной загрузки, и также, чтобы распределить ресурсы загруз-
  ки для расшивки узких мест процесса загрузки.  Прежде  чем  сделать
  это,  Вы должны понять различие между двумя методами, которые может
  использовать сетевая плата, чтобы оповестить сервер загрузки о том,
  что ее компьютеру требуется загрузка.
       При использовании первого метода сетевая плата посылает  зап-
  рос загрузки в конкретный сервер загрузки;
       при втором методе плата передает запрос загрузки на все узлы и
  ожидает,  что сервер загрузки ответит на запрос.
       Плата Arcnet фирмы Quantum,  имеющая энергонезависимое ЗУПВ, в
  которое  может  быть загружен узловой ID сервера,  использует метод
  конкретной загрузки.
       Большинство других сетевых плат не имеют средств, чтобы загру-
  зить физический узловой ID сервера и должны использовать  широкове-
  щательный метод.

       9.2.1. Широковещательная загрузка с ПЗУ QNX

       Для того, чтобы загрузить QNX с сетевой платы, отличной от Qu-
  antum Arcnet (например, Ethernet, Token Ring), Вы должны установить
  ПЗУ загрузки QNX в гнездо на плате,  как указано в документации се-
  тевой платы. Когда ПЗУ загрузки QNX начинает загружаться, оно пере-
  дает запрос загрузки в сервер,  который имеет символическое имя "A"

                               - 100 -

  (первичный сервер);  если оно не получает никакого ответа, ПЗУ нач-
  нет  транслировать запрос загрузки в сервер "B" (вторичный сервер),
  и,  наконец, в сервер "C" (третичный сервер). При широковещательной
  загрузке утилита netboot должна знать в качестве какого сервера она
  выступает в отношении каждого узла (первичного, вторичного или тре-
  тичного).  Утилита определяет это, открывая файл /etc/config/netbo-
  ot,  в котором каждая строка определяет логический узловой ID,  имя
  файла,  определяющее образ загружаемой операционной системы и режим
  сервера (дополнительно):

       logicai_node_lD   f=buildfile | F=imagefile   [server_mode]

       Если server_mode не задан, netboot выступит в качестве сервера
  первичной  загрузки  для  задаваемого узла.  Возможные значения для
  server_mode:

          A       первичный сервер (значение по умолчанию)
          B       вторичный сервер
          C       третичный сервер

       В следующем примере задается,  что данный  компьютер  является
  первичным сервером для всех узлов, за исключением узла, для которо-
  го он является вторичным сервером:

          4       f=build/ws.arcnet       B
          *       f=build/ws.arcnet       A

       9.2.2. Выполнение утилиты netboot

       Т.к. при широковещательном методе загрузки доступны все узлы в
  сети,  Вы можете запускать netboot на  нескольких  узлах,  создавая
  несколько серверов загрузки. Это позволит Вам задавать разным груп-
  пам узлов разные серверы  загрузки.
       Хотя каждый процесс netboot обычно получает запрос широковеща-
  тельной загрузки, он реагирует только в соответствии с его уникаль-
  ным файлом /etc/config/netboot, который определяет отношение к каж-
  дому запрашивающему узлу (например,  "Я - вторичный сервер загрузки
  для  узла  5") 5. 0  Никакие два сервера загрузки не могут иметь один и
  тот же server_mode для любого данного логического узлового ID. Если
  это правило не выполняется,  то каждый сервер загрузки с тем же са-
  мым server_mode для данного логического узлового ID ответит на этот
  запрос узловой загрузки.
       Давайте теперь рассмотрим 15-узловую сеть Ethernet,  в которой
  узлы с 1 по 9 принадлежат к техническому отделу,  а узлы с 10 по 15

                               - 101 -

  принадлежат к отделу маркетинга.  Если Вы захотели сделать  узел  1
  первичным сервером загрузки для техотдела, а узел 10 первичным сер-
  вером загрузки для отдела маркетинга, Вам следует выполнить утилиту
  netboot  на  обоих узлах,  каждую с ее собственным конфигурационным
  файлом:

       На узле 1   (//1/etc/config/netboot):

          2         f=build/ws.ether8003 A
          3         f=build/ws.ether8003 A
          4         f=build/ws.ether8003 A
          5         f=build/ws.ether8003 A
          6         f=build/ws.ether8003 A
          7         f=build/ws.ether8003 A
          8         f=build/ws.ether8003 A
          9         f=build/ws.ether8003 A
          *         f=build/ws.ether8003 B

       На узле 10   (//10/etc/config/netboot):

          2         f=build/ws.ether8003 B
          3         f=build/ws.ether8003 B
          4         f=build/ws.ether8003 B
          5         f=build/ws.ether8003 B
          6         f=build/ws.ether8003 B
          7         f=build/ws.ether8003 B
          8         f=build/ws.ether8003 B
          9         f=build/ws.ether8003 B
          *         f=build/ws.ether8003 A

       В этом случае Вы также сделали узел 10 вторичным сервером заг-
  рузки для техотдела, а узел 1 - вторичным сервером загрузки для от-
  дела маркетинга.

       9.3. Многосвязная сеть

       9.3.1. Преимущества

       Как указано в "Архитектуре системы",  более чем  одна  сетевая
  связь на компьютере обеспечивает отказоустойчивость, большую произ-
  водительность,  а также дополнительную связность (то есть Вы можете
  иметь доступ к узлам, непосредственно не подключенным к Вашей сети,
  через удаленные узлы,  которые имеют доступ к Вашей сети  и  другим
  сетям).

                               - 102 -


       9.3.2. Коммуникация через сети

       В QNX узел может одновременно взаимодействовать со многими се-
  тями. Однако, узел может взаимодействовать только с узлами, к кото-
  рым  он непосредственно подключается.  Рассмотрите следующую схему,
  где четыре компьютера связаны через две сети:

  ┌────────────────────────────────────────────────────────────────┐
  │                                                                │
  │ Сеть 1 <═════╦═══════════╦══════════╦══════════╦═══════>       │
  │              ║           ║          ║          ║               │
  │ Сеть 2 <─────╫─┬─────────╫─┬────────╫─┬────────╫─┬─────>       │
  │              ║ │         ║ │        ║ │        ║ │             │
  │              ║ │         ║ │        ║ │        ║ │             │
  │            Узел 1      Узел 2     Узел 3     Узел 4            │
  │                                                                │
  └────────────────────────────────────────────────────────────────┘

                               Рис.12

       В этой  отказоустойчивой  сети  каждый  из четырех узлов может
  взаимодействовать непосредственно с любым другим узлом через сеть 1
  или сеть 2.
       Сравните это со следующей схемой,  где узлы 1 и 3 подключаются
  к разным сетям, а узел 2 является общим для обеих сетей. Узлы 1 и 3
  не могут непосредственно взаимодействовать друг с  другом,  но  оба
  узла имеют доступ к узлу.

  ┌───────────────────────────────────────────────────────────────┐
  │                                                               │
  │ Сеть 1 <═════════════════╦═══════════════╦═════════>          │
  │                          ║               ║                    │
  │                          ║               ║                    │
  │                          ║             Узел 3                 │
  │ Сеть 2 <─────┬───────────╫─┬───────────────────────>          │
  │              │           ║ │                                  │
  │              │           ║ │                                  │
  │            Узел 1      Узел 2                                 │
  │                                                               │
  └───────────────────────────────────────────────────────────────┘

                               Рис.13


                               - 103 -

       В этой конфигурации следующая команда,  запущенная на узле  1,
  не выполнится, т.к. узел 1 не может связаться непосредственно с уз-
  лом 3:

                  sin -n 3

       Однако, т.к.  QNX обеспечивает прозрачное удаленное выполнение
  процесса, следующие команды могут быть успешно выполнены на узле 1 1:

                  //2 sin -n 3
  или
                  //2 sh
                  sin -n 3
                  exit

       Во втором примере начинается удаленный сеанс на узле 2.  После
  этого все последующие команды по умолчанию будут выполняться на уз-
  ле 2 до тех пор, пока не выполнится команда exit.

       9.4. Выбор конфигурации многосвязной сети

       Чтобы установить несколько сетевых связей на одном компьютере,
  Вы должны сначала выбрать уникальный логический сетевой ID для каж-
  дой сети, которые Вы будете компоновать.
       Затем Вам следует:
       - установить сетевые платы;  - запустить соответствующие сете-
  вые  драйверы;
       - отредактировать  файлы /etc/config/netmap и /etc/config/net-
  boot.
       В этом разделе мы рассмотрим эти задачи и примеры типичных ус-
  тановок многосвязной сети.

       9.4.1. Установка сетевых плат

       ВНИМАНИЕ. Фирма Quantum выпускает технические заметки по уста-
                 новке сетевых плат.  Файлы, в которых содержатся эти
                 заметки,  находящиеся в каталоге /etc/readme/techno-
                 tes,  имеют имена, начинающиеся с префикса Net (нап-
                 ример,  Net.ether8003).  Перед установкой  платы  Вы
                 должны прочитать техническую заметку для типа платы,
                 которую Вы используете.

       Вам следует установить каждую сетевую плату согласно  инструк-
  циям, прилагаемым к плате. Не забывайте определить физический узло-

                               - 104 -

  вой ID платы. Для того, чтобы использовать сетевую плату, Вам пона-
  добится запустить дополнительный сетевой драйвер.

       ВНИМАНИЕ. Сетевая плата,  ПЗУ которой использует высшие адреса
                 памяти, обнаруживается последней при выполнении пос-
                 ледовательности самотестирования,  выполняемой BIOS.
                 Обычно это та плата,  которая  будет  использоваться
                 Вашим компьютером для загрузки через сеть.

       9.4.2. Запуск сетевых драйверов

       Узел может входить в одну или несколько сетей;  для каждой се-
  тевой конфигурации Вы должны запустить сетевой  драйвер.  Запускать
  или  нет  сетевой драйвер зависит от того,  является ли он основным
  драйвером.

       Основные драйверы

       Основной драйвер - это сетевой драйвер в образе загрузки,  ко-
  торый  позволяет  рабочей станции взаимодействовать с сервером заг-
  рузки и получать доступ к файлу sysinit.node на жестком диске  сер-
  вера.  Основные драйверы нужны только рабочим станциям.  Образ заг-
  рузки рабочей станции или файл формирования (как определено в файле
  /etc/config/netboot)  должен  всегда  включать подходящие драйверы,
  чтобы связаться с сервером загрузки.
       Например, файл формирования /boot/build/ws.arcnet по умолчанию
  включает драйвер сети Arcnet (Net.arcnet) как часть образа, переда-
  ваемого  в загружаемую рабочую станцию.
       Если сервер загрузки  имеет  более  одного  элемента  в  файле
  /etc/config/netboot для конкретной рабочей станции,  указывая,  что
  файл рабочей станции sysinit.node может быть передан  через  многие
  сетевые  связи,  то этот рабочий образ должен иметь сетевой драйвер
  для каждой сетевой связи,  которую сервер загрузки может  использо-
  вать.  Эти  сетевые драйверы считаются основными и,  следовательно,
  должны быть добавлены в файл формирования рабочей  станции.  Вместо
  модификации  заданного  по умолчанию файла формирования Вам следует
  сделать копию со значимым именем, как например, файл ws.arc_eth8003
  будет содержать сетевые драйверы как Arcnet, так и Ethernet 8003, а
  затем модифицировать новый файл.
       Имейте в виду,  что опция -d потребуется для Net, если исполь-
  зуются более чем два сетевых драйвера.  Мы  также  рекомендуем  Вам
  посмотреть netmap в "Utilities Reference",  чтобы знать, как маски-
  ровать узлы.


                               - 105 -

       Дополнительные драйверы

       Дополнительными драйверами называются такие драйверы,  которые
  не требуются для загрузки узла. Подобно другим программам, Вы обыч-
  но добавляете эти драйверы в файл  sysinit.node.  Например,  сервер
  загрузки загружается с диска,  и в его файл sysinit.node включается
  Администратор сети и соответствующие драйверы для обеспечения взаи-
  модействия с сетями.

       Определение логических сетевых ID

       По умолчанию сетевые драйверы подключаются к логическому сете-
  вому ID 1,  что упрощает установку односвязной сети.  Тем не менее,
  при объединении многих сетей Вы должны задать логический сетевой ID
  каждому сетевому драйверу,  который не принадлежит  сети  1.  Чтобы
  сделать это,  необходимо использовать опцию -l (эл) при запуске се-
  тевого драйвера.  Например,  следующие три команды  в  файле  sysi-
  nit.node  сервера  загрузки запустят Ethernet-драйверы для двух се-
  тей:

       Net &   Сетевой администратор

       Net.ether8003 -p 220 & сетевой драйвер для логической сети 1
  (значение по умолчанию)

      Net.ether8003 -p 340 -1 2 &  сетевой  драйвер  для логической
  сети 2

       Имейте в виду,  что,  когда Вы устанавливаете две  аналогичные
  платы в одной и той же машине,  Вы не можете использовать автомати-
  ческое определение прерываний,  портов  ввода/вывода  и  т.п.,  что
  обычно  обеспечивается  этими сетевыми драйверами.  Вместо этого Вы
  должны задать часть  этой  информации,  используя  опции  командной
  строки.  Вы должны также включить платы в конфигурацию так, чтобы у
  них не было аппаратных конфликтов.

       ВНИМАНИЕ. Если Вы должны запустить более двух сетевых  драйве-
                 ров,  Вам понадобится использовать опцию -d для Net,
                 чтобы задать количество драйверов, которое нужно ис-
                 пользовать  (например,  -d3  для трех сетевых драйве-
                 ров). Т.к. Net запускается из файла формирования ра-
                 бочих  станций  и  из файла sysinit.node для сервера
                 загрузки, Вам понадобится модифицировать оба файла в
                 части добавления опции -d при запуске Администратора

                               - 106 -

                 сети.

  9.4.3. Редактирование файла netmap

       Файл /etc/config/netmap является по умолчанию файлом соответс-
  твия  идентификаторов сети и узлов и используется утилитами netboot
  и netmap. Этот файл устанавливает соответствие физического узлового
  ID,  логического  узлового ID и логического сетевого ID для каждого
  узла.  По умолчанию этот файл устанавливается для инсталляции одной
  сети Arcnet,  для которой физический узловой ID тот же, что и логи-
  ческий узловой ID. В нем используется взаимно-однозначное соответс-
  твие,  чтобы сделать логический узловой ID таким же, как физический
  узловой ID.
       Если Вы уже установили сеть, для которой логические и физичес-
  кие ID отличаются,  Вам следует сделать изменения в этом файле, оп-
  ределяя физические узловые ID для Ваших узлов.  Например,  возможно
  Вы установили сеть Ethernet:

          1       1       0000C0  7B7113
          2       1       0000C0  164C2D

       Для единственной сети логический сетевой ID равен 1 по умолча-
  нию. Но, когда Вы имеете дело с несколькими сетями, Вы должны опре-
  делить каждый компьютерный логический узел и логический сетевой ID,
  а также его физический узловой ID. Для получения дополнительной ин-
  формации, смотрите раздел 9.4.5 "Примеры". Для того, чтобы узнать о
  маскировании,  демаскировании и удалении узлов,  смотрите  описание
   9netmap в "Utilities Reference". 0

       9.4.4. Редактирование файла netboot

       Когда рабочая  станция  посылает запрос загрузки в сервер заг-
  рузки,  сетевой администратор,  получив запрос,  передает следующую
  информацию о загрузке узла утилите netboot:
       - узловой физический ID (определяемый аппаратными средствами);
       - логический сетевой ID для драйвера (параметр, задаваемый для
  драйвера при запуске).
       Имея эту информацию,  утилита netboot использует файл установ-
  ления соответствия, по умолчанию, /etc/config/netmap, чтобы опреде-
  лить логический узловой ID загружаемой машины. Затем утилита netbo-
  ot использует файл /etc/config/netboot, чтобы определить, какой об-
  раз  передавать  в  узел,  который послал запрос на загрузку.  Файл
  /etc/config/netboot определяет, какой файл образа или файл построе-
  ния  должен  использоваться для загрузки рабочих станций.  Возможно

                               - 107 -



  потребуется отредактировать этот файл,  если сервер загрузки должен
  поддерживать разные сети. Например, элемент:

       * f=build/ws.arcnet

  использует один  и  тот  же файл построения для всех узлов.
       В случае смешанной сети Вы должны для некоторых  узлов  задать
  другие файлы построения.
       Предположим, что у Вас есть восьмиузловая сеть Arcnet, которая
  работает  с используемыми по умолчанию элементами netboot,  а затем
  Вы добавили три узла сети Ethernet. Чтобы загрузить эти узлы с того
  же  самого  сервера (предполагая,  что сервер имеет плату и драйвер
  Ethernet),  Вы должны модифицировать Ваш  файл  /etc/config/netboot
  следующим образом:

          9       f=build/ws.ether8003
          10      f=build/ws.ether8003
          11      f=build/ws.ether8003
          *       f=build/ws.arcnet

       9.4.5. Примеры

       Теперь, когда мы обсудили, что входит в установку многосвязной
  сети,  давайте рассмотрим, как:
       - добавить несколько узлов сети Ethernet к сети Arcnet;
       - установить  отказоустойчивую  сеть  Ethernet;
       - установить частную сетевую связь.

       Добавление нескольких узлов сети Ethernet к сети Arcnet

       Предположим, имеется следующая схема сети:
.
                               - 108 -


  ┌──────────────────────────────────────────────────────────────────┐
  │                                                                  │
  │ Логическая <═══╦══════╦═══════╦═══════╦═══════╦══════╦════╦═>    │
  │ сеть 1         ║      ║       ║       ║       ║      ║    ║      │
  │ (Arcnet)       ║     P=2     P=3     P=4     P=5     ║   P=7     │
  │                ║     L=2     L=3     L=4     L=5     ║   L=7     │
  │                ║                                     ║           │
  │ Логическая <───╫─┬────────┬────────┬────────┬────────╫─┬────>    │
  │ сеть 2         ║ │        │        │        │        ║ │         │
  │ (Ethernet)     ║ │        │        │        │        ║ │         │
  │                ║ │ P=0000C0 7B7113 │ P=0000C0 DC5E08 ║ │         │
  │                ║ │       L=8       │       L=10      ║ │         │
  │                ║ │                 │                 ║ │         │
  │                P=1          P=0000C0 164C2D          ║ │         │
  │          P=0000C0 0D9E40          L=9                ║ │         │
  │                L=1                                   P=6         │
  │                                                 P=0000C0 064A2D  │
  │          СЕРВЕР ЗАГРУЗКИ                             L=6         │
  │                                                                  │
  │ P= физический ID узла                                            │
  │ L= логический ID узла                                            │
  └──────────────────────────────────────────────────────────────────┘
                               Рис.14

       Как Вы помните,  формат файла /etc/config/netmap выглядит сле-
  дующим образом:

  logical_node_ID       logical_network_ID           physical_node_ID

       Для этого примера файл будет содержать следующие данные:

          1       1       1
          1       2       0000C0 0D9E40
          2       1       2
          3       1       3
          4       1       4
          5       1       5
          6       1       6
          6       2       0000C0 064A2D
          7       1       7
          8       2       0000C0 7B7113
          9       2       0000C0 164C2D
          10      2       0000C0 DC5E08

                               - 109 -

       Имейте в  виду,  что логические узловые ID уникальны для обеих
  взаимосвязанных сетей. Для загрузки рабочих станций утилите netboot
  требуется,  чтобы  каждый  узел имел образ ОС или связыванный с ним
  файл построения. Рабочие станции, загружаемые через сеть Arcnet, не
  используют файлы построения рабочих станций,  загружаемых через Et-
  hernet.  Следовательно,  файл /etc/config/netboot  будет  содержать
  следующие данные:

          2       f=build/ws.arcnet
          3       f=build/ws.arcnet
          4       f=build/ws.arcnet
          5       f=build/ws.arcnet
          6       f=build/ws.arc_ether8003
          7       f=build/ws.arcnet
          8       f=build/ws.ether8003
          9       f=build/ws.ether8003
          10      f=build/ws.ether8003

       Узел 1 не имеет своего элемента, т.к. он загружается с жестко-
  го диска.  Однако, из его файла sysinit.node должен запускаться как
  драйвер Arcnet, так и драйвер Ethernet.
       Обратите внимание,  что узел 6 можно загру 6зить либо через Arc-
   6net, либо  через  Ethernet  (выбор сети,  через которую загружается
   6узел 0 6 6,  зависит от того,  какая сетевая плата обнаружена последней
   6во  время  сканирования ПЗУ при включении питания;  при этом 0 плата,
  описанная в самых верхних адресах,  всегда  обнаруживается  послед-
  ней).
       В этом примере мы задали загрузку узла 6   6через  Arcnet.  Т.к.
   6узел  06   6находится  как в сети Arcnet,  так и Ethernet,  Вам следует
   6создать специальный файл построения,  который будет 0  содержать  как
  Net.arcnet,  так и Net.ether8003 (например, cp ws.arcnet ws.arc_et-
  her8003),  а затем добавить в файл драйвер Ethernet.  Это обеспечит
  передачу  сервером  загрузки файла sysinit.node по каждой сети.
       Из файла ws.arcnet будет запущен Администратор  сети,  который
  по умолчанию поддерживает максимум два драйвера. Если сетевых драй-
  веров больше двух, то Вы должны добавить опцию -d в Net.

       Установка отказоустойчивой сети Ethernet

       Допустим, имеется следующая схема сети:
.
                               - 110 -

  ┌──────────────────────────────────────────────────────────────────┐
  │                                                                  │
  │ Логическая <═══╦══════════╦═══════════╦══════════╦═══════>       │
  │ сеть 1         ║          ║           ║          ║               │
  │ (Ethernet)     ║          ║           ║          ║               │
  │                ║          ║           ║          ║               │
  │ Логическая <───╫─┬────────╫─┬─────────╫─┬────────╫─┬─────>       │
  │ сеть 2         ║ │        ║ │         ║ │        ║ │             │
  │ (Ethernet)     ║ │        ║ │         ║ │        ║ │             │
  │                ║ │        ║ │         ║ │        ║ │             │
  │                ║ │        ║ │         ║ │        ║ │             │
  │         P1=0000C0 0D9E40  ║ │  P1=0000C0 164C2D  ║ │             │
  │         P2=0000C0 064A2D  ║ │  P2=0000C0 5C9A40  ║ │             │
  │               L=1         ║ │         L=3        ║ │             │
  │         СЕРВЕР ЗАГРУЗКИ   ║ │                    ║ │             │
  │                      P1=0000C0 7B7113       P1=0000C0 DC5E08     │
  │                      P2=0000C0 109E40       P2=0000C0 129E40     │
  │                            L=2                    L=4            │
  │                                                                  │
  │ P= физический ID узла                                            │
  │ L= логический ID узла                                            │
  └──────────────────────────────────────────────────────────────────┘

                               Рис.15

       Соответствующий файл /etc/config/netmap будет содержать следу-
  ющие данные:

          1       1       0000C0 0D9E40
          1       2       0000C0 064A2D
          2       1       0000C0 7B7113
          2       2       0000C0 l09E40
          3       1       0000C0 164C2D
          3       2       0000C0 5C9A40
          4       1       0000C0 DC5E08
          4       2       0000C0 129E40


       Соответствующий файл /etc/config/netboot мог бы содержать сле-
  дующий элемент:

                  * f=build/ws.eth8003x2

       Т.к. требуется дополнительный драйвер Ethernet, Вы должны соз-

                               - 111 -

  дать специальный файл построения (например,  ws.eth8003x2) и  доба-
  вить в файл вторую копию драйвера Net.ether8003.

       Установка частной сетевой связи

       Если между  определенными  узлами  сети существует напряженный
  трафик,  Вы можете объединить эти узлы частной сетью, чтобы разгру-
  зить коммуникационный поток основной сети. Например:

  ┌──────────────────────────────────────────────────────────────────┐
  │                                                                  │
  │                                                                  │
  │ Логическая <════╦══════════╦═══════════╦══════════╦═════════>    │
  │ сеть 1          ║          ║           ║          ║              │
  │ (Ethernet)      ║          ║           ║          ║              │
  │                 ║          ║           ║          ║              │
  │ Логическая <────╫──────────╫─┬─────────╫─┬────────╫─────────>    │
  │ сеть 2          ║          ║ │         ║ │        ║              │
  │ (Ethernet)      ║          ║ │         ║ │        ║              │
  │                 ║          ║ │         ║ │        ║              │
  │          P1=0000C0 0D9E40  ║ │  P1=0000C0 164C2D  ║              │
  │                L=1         ║ │  P2=0000C0 5C9A40  ║              │
  │          СЕРВЕР ЗАГРУЗКИ   ║ │        L=3         ║              │
  │                                                                  │
  │                    P1=0000C0 7B7113         P1=0000C0 DC5E08     │
  │                    P2=0000C0 109E40               L=4            │
  │                            L=2                                   │
  │ P= физический ID узла                                            │
  │ L= логический ID узла                                            │
  └──────────────────────────────────────────────────────────────────┘

                               Рис.16
.
                               - 112 -

                    Глава 10. БУФЕРИЗАЦИЯ ПЕЧАТИ

       В этой главе...

       Использование утилит буферизации
       Архитектура системы буферизации
       Файл установки буферизации
       Использование файла установки
       Примеры файлов установки
       Доступ к системам буферизации и очередям

       10.1. Введение

       10.1.1. Разделение ресурсов в сети

       QNX обеспечивает  распределение ресурсов сети с некоторыми ис-
  кусственными ограничениями. Каждое устройство (диск, модем, принтер
  и т.п.), подключенное к компьютеру по умолчанию является коллектив-
  ным ресурсом.
       Таким образом, программа, работающая на любом компьютере, име-
  ет равный доступ к любому устройству в сети,  независимо  от  того,
  подключено устройство к тому же самому компьютеру (локальное) или к
  другой машине (удаленное).
       Хотя пользователь,  в принципе,  может получить доступ к любым
  ресурсам в сети,  Системный администратор, вероятно, должен принять
  меры,  чтобы  контролировать  доступ к определенным типам ресурсов.
       Принтеры и модемы, например, могут использоваться в данный мо-
  мент только одним пользователем (в отличие от жестких дисков, с ко-
  торыми могут работать параллельно многие пользователи) и,  следова-
  тельно, требуется организовать формирование очереди, чтобы избежать
  конфликтов.
       Для обеспечения  удобного доступа к этим распределенным ресур-
  сам в системе QNX имеется множество сервисных средств буферизации.

       10.1.2. Буферизация

       Система буферизации - механизм,  который принимает  запросы  к
  ресурсу и затем распределяет использование ресурса в соответствии с
  инструкцией,  которая была задана.
       Для того,  чтобы понять, как использовать систему буферизации,
  давайте рассмотрим,  как система буферизации управляет  доступом  к
  принтеру.
       Принтер должен быть постоянно доступен пользователям,  хотя он
  может  выполнять в данный момент только одно задание.  Если имеется

                               - 113 -

  система буферизации, то пользователи могут послать данные через эту
  систему,  а не непосредственно на принтер. Получая данные, предназ-
  наченные для принтера, система буферизации записывает эти данные во
  временный файл, а не передает их немедленно на принтер. Позже, ког-
  да принтер становится доступным,  система буферизации передает дан-
  ные на принтер.
       Таким образом, многие пользователи могут свободно подавать за-
  дания на печать,  даже если существует только один физический прин-
  тер. QNX поддерживает буферизацию с помощью именованных очередей, к
  которым обращается набор утилит "lp";  эти очереди также существуют
  в файловом пространстве в каталоге /dev/spool.
       Данные, записанные  в очередь,  будут помещаться во внутренний
  список и в конце концов передаваться на определенное устройство вы-
  вода. Сервер буферизации QNX:

                  lpsrvr

       Этот сервер может поддерживать несколько очередей буферизации.
  Следующие утилиты работают с очередями буферизации:

          lp      помещает файлы в очереди буферизации
          lprm    удаляет задания из очередей буферизации
          lpc     управляет очередями буферизации
          lpq     отображает состояние очередей буферизации

       Для получения дополнительной информации об этих утилитах смот-
  рите "Utilities Referencе".

       10.2. Использование утилит буферизации

       10.2.1. Запуск системы буферизации

       Прежде чем любая буферизация cможет  осуществиться  в  системе
  QNX, Вы должны запустить сервер буферизации lpsrvr:

                  lpsrvr &

       Для того,  чтобы определить,  какие ресурсы доступны и как уп-
  равлять ими,  утилита lpsrvr сначала ищет файл установки  с  именем
  /etc/config/lpsrvr.node  (где  node - ID узла,  на котором работает
  lpsrvr).  Если файл установки с расширением node не  обнаруживается,
  lpsrvr будет использовать файл /etc/config/lpsrvr.  Этот файл нахо-
  дится на стандартных дистрибутивных дискетах QNX.


                               - 114 -

       10.2.2. Представление заданий на буферизацию

       Следующая команда lp поставит файл report в очередь  буфериза-
  ции  по умолчанию (дополнительно об этой очереди смотрите в разделе
  "Установка файла буферизации") и в конце концов распечатает его:

                  lp report

       В системах,  где имеется более одной очереди  буферизации,  Вы
  можете определить имя очереди.  Следующая команда включает report в
  очередь буферизации с именем txt:

                  lp -P txt report

       Для записи непосредственно в файл очереди Вы также можете  ис-
  пользовать команду cp:

                  cp /dev/spool/txt

       10.2.3. Организация очереди на буферизацию

       Для того,  чтобы проверить очередь буферизации,  Вы можете ис-
  пользовать утилиту lpq. Ниже приведен пример выводимой утилитой lpq
  информации:

          1:      steve   [job #39]       1400 bytes      lalist.doc
          2:      aboyd   [job #42]       2312 bytes      netdrvr.c

       Эта утилита позволит Вам определить,  когда были завершены по-
  данные на выполнение задания;  она также позволит определить ID за-
  дания буферизации для использования его другими утилитами lp.

       10.2.4. Отмена заданий на буферизацию

       Утилита lprm позволяет Вам удалять задания из очереди  буфери-
  зации.  Вы можете удалить задание явно, указав его ID. Для очереди,
  показанной выше,  задание steve (#39) может быть отменено следующей
  командой:

                  lprm 39

       Если задание  #39  в данный момент времени обрабатывается,  то
  оно будет завершено.  Успешность завершения текущих заданий буфери-
  зации может зависеть от типа устройства вывода,  который Вы исполь-

                               - 115 -

  зуете: некоторые принтеры имеют большие внутренние буфера.

       Суперользователь может также удалить все задания, принадлежащие конк-
  ретному пользователю. Например, все задания steve могут быть отменены
  следующей командой:

                  lprm steve

       10.2.5. Управление очередями на буферизацию

       Утилита lpc - системное административное средство для управле-
  ния  системами буферизации.  Она позволяет Вам выполнять многие уп-
  равляющие функции, например, открытие или закрытие очереди.
       Обеспечиваются следующие базовые функции:
       - приостановить/возобновить включение  заданий  в  очередь;
       - приостановить/возобновить удаление заданий из очереди;
       - приостановить/возобновить  выполнение  текущего  задания;
       - удалить текущее задание;  - перестроить задания в очереди;
       - переместить задания в другую очередь;
       - отобразить состояние очередей.

       Имейте в виду,  что функциональные возможности lpc перекрывают
  возможности lpq и lprm.  Это удобно,  т.к. в отличие от lpq и lprm,
  lpc может использоваться в диалоговом режиме.

       10.3. Архитектура системы буферизации

       В основе системы буферизации QNX лежат два объекта:  очереди и
  адресаты. Они работают друг с другом, обеспечивая гибкий метод пре-
  образования данных и организации очередей.
       Очередь - это внутренний список  задержанных  данных,  которые
  нужно послать адресату.
       Как отмечалось ранее,  каждая очередь  получает  имя,  которое
  пользователи определяют при запуске заданий.  Адресат связывается с
  физическим устройством вывода (например, принтером) и удаляет зада-
  ния из очередей.  Вы можете соединить выход очереди с одним или бо-
  лее адресатами или соединить несколько очередей с единственным  ад-
  ресатом.
       Однако, Вы можете соединить выход адресата только с одним уст-
  ройством.
       Очереди могут иметь дополнительные атрибуты,  называемые филь-
  трами.
       Есть два типа фильтров:
       - входные фильтры (copy-in) (ci), которые выполняют операции с

                               - 116 -

  данными прежде, чем они скопируются в очередь (например, форматиро-
  вание);
       и выходные фильтры (copy-out) (со), которые оперируют с данны-
  ми после исключения из очереди.
       Адресаты могут  иметь  дополнительную  управляющую   программу
  (cp),  которая позволяет,  если потребуется,  инициализировать уст-
  ройство вывода между заданиями.
       Например, если  выполнение задания преждевременно прекратилось
  и устройство необходимо снова перевести в исходное состояние, прог-
  рамма, управляющая устройством, должна обнаружить SIGTERM и опреде-
  лить, какое действие необходимо выполнить, чтобы перевести устройс-
  тво в устойчивое состояние.
       Следующие схемы иллюстрируют, каким образом могут быть скомпо-
  нованы очереди,  фильтры и адресаты,  чтобы работать друг с другом.
  Необязательные элементы выделены курсивом.

       Одна очередь для одного адресата

       Следующая конфигурация может использоваться там, где есть один
  принтер  и  требуется одна (или никакая) передача данных (например,
  точечный матричный принтер):

  ┌──────────────────────────────────────────────────────────────────┐
  │                                                                  │
  │                очередь                            адресат        │
  │     ┌────────────────────────────┐          ┌────────────────┐   │
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐          ┌───┐                │
  │ ───>│ci ├───>│   │   │   ├───┤co ├──────────┤cp ├─────>устройство│
  │     └───┘    └───┴───┴───┘   └───┘          └───┘                │
  │                                                                  │
  │                                                                  │
  └──────────────────────────────────────────────────────────────────┘

                               Рис.17

       Несколько очередей для одного адресата

       У одного адресата может быть несколько очередей. В этом случае
  адресат выберет из всех заданий в очередях подходящее задание,  ос-
  новываясь  на  приоритете очереди и времени ожидания (то есть самое
  задержанное задание).
.
                               - 117 -

  ┌──────────────────────────────────────────────────────────────────┐
  │                                                                  │
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐         ┌───┐                 │
  │ ───>│ci ├───>│   │   │   ├───┤co ├─────────┤cp ├─────>устройство │
  │     └───┘    └───┴───┴───┘   └───┘        └───┘                 │
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐     │                         │
  │ ───>│ci ├───>│   │   │   ├───┤co ├─────┘                         │
  │     └───┘    └───┴───┴───┘   └───┘                               │
  │                                                                  │
  └──────────────────────────────────────────────────────────────────┘

                               Рис. 18

       В конце  этой главы Вы найдете несколько примеров файлов уста-
  новки.
       Вышеуказанная конфигурация  используется в примере,  в котором
  одна очередь преобразует ASCII в PostScript, а другая - просто оче-
  редь PostScript.  Обе очереди имеют один и тот же адресат,  который
  посылает данные на лазерный принтер PostScript.

       Одна очередь для нескольких адресатов

       Если выход очереди передается на несколько адресатов,  система
  буферизации выберет любой доступный адресат.
       Следующая конфигурация пригодна в том случае, если имеется три
  принтера и не имеет значения, какой из них печатает Ваше задание.

  ┌──────────────────────────────────────────────────────────────────┐
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐          ┌───┐                │
  │ ───>│ci ├───>│   │   │   ├───┤co │──────────┤cp │─────>устройство│
  │     └───┘    └───┴───┴───┘   └───┘         └───┘                │
  │                                       │     ┌───┐                │
  │                                       ├─────┤cp │─────>устройство│
  │                                       │     └───┘                │
  │                                       │     ┌───┐                │
  │                                       └─────┤cp │─────>устройство│
  │                                             └───┘                │
  └──────────────────────────────────────────────────────────────────┘

                               Рис. 19

       Несколько очередей для нескольких адресатов

       Следующая конфигурация - комбинация двух предшествующих приме-

                               - 118 -

  ров.
       Третья очередь  имеет отдельный канал для одного из адресатов.
  Этот канал используется, чтобы гарантировать передачу заданий всег-
  да на третий принтер (например, принтер имеет цветные возможности).

  ┌──────────────────────────────────────────────────────────────────┐
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐          ┌───┐                │
  │ ───>│ci ├───>│   │   │   ├───┤co │─────┬────┤cp │─────>устройство│
  │     └───┘    └───┴───┴───┘   └───┘    │    └───┘                │
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐  │  │                         │
  │ ───>│ci ├───>│   │   │   ├───┤co │──┘  │                         │
  │     └───┘    └───┴───┴───┘   └───┘     │                         │
  │                                        │    ┌───┐                │
  │                                        ├────┤cp │─────>устройство│
  │                                        │    └───┘                │
  │                                        │    ┌───┐                │
  │                                        └────┤cp │─────>устройство│
  │                                            └───┘                │
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐      │                        │
  │ ───>│ci ├───>│   │   │   ├───┤co │──────┘                        │
  │     └───┘    └───┴───┴───┘   └───┘                               │
  └──────────────────────────────────────────────────────────────────┘

                               Рис. 20

       Сцепление очередей

       Выход очереди обычно подключается к одному или более адресатам
  и, кроме того, существует возможность подключения его к другой оче-
  реди. При сцеплении выход одной очереди подключается непосредствен-
  но ко входу другой очереди, в результате чего не нужны никакие опе-
  рации с входными фильтрами для этой очереди.  Если конечная очередь
  в цепи имеет выходной фильтр, то он и будет использоваться.
  ┌──────────────────────────────────────────────────────────────────┐
  │     ┌───┐    ┌───┬───┬───┐   ┌───┐                               │
  │ ───>│ci ├───>│   │   │   ├───┤co │─────┐                         │
  │     └───┘    └───┴───┴───┘   └───┘     │                         │
  │           ┌────────────────────────────┘                         │
  │           │                                                      │
  │     ┌───┐   ┌───┬───┬───┐   ┌───┐          ┌───┐                │
  │ ───>│ci ├───>│   │   │   ├───┤co │──────────┤cp │─────>устройство│
  │     └───┘    └───┴───┴───┘   └───┘          └───┘                │
  └──────────────────────────────────────────────────────────────────┘
                               Рис. 21

                               - 119 -

       10.4. Файл установки буферизации

       После запуска система буферизации обращается  к  файлу,  чтобы
  получить  информацию  о конфигурации.  Если никакой файл не задан в
  командной строке,  то система буферизации использует файл /etc/con-
  fig/lpsrvr.  Этот  файл определяет очереди,  адресаты и связь между
  ними.

       10.4.1. Синтаксические определения

       Очереди и адресаты имеют символические имена, а также комплект
  атрибутов. Каждый элемент файла установки имеет следующий формат:

          [name]
                  attribute
                  attribute
                  .
                  .
                  .

       Определение очереди или адресата начинается с директивы [name]
  и включает до следующей директивы [name] все допустимые технические
  спецификации.
       Все начальные пробелы игнорируются.
       Строки комментариев начинаются со знака #.  Если один  атрибут
  занимает  две  строки,  то последним символом перед символом <конец
  строки> должен быть:  <\>.
       Имя может  иметь до 48 символов и может содержать только текс-
  товые символы.
       Если описываемый объект - адресат, то перед именем должно быть
  тире (-). Тире не считается частью имени. Каждый атрибут состоит из
  двухсимвольного ключа в одной из следующих форм:
          key     логическая величина
          key#number      числовая
          key=string      символьная
       Все числа считаются десятичными, если они не начинаются с нуля
  (означающего 8-ричное представление) или с комбинацииx  (означающей
  16-ричное представление).
       Все строки содержат печатные символы.
       Обратная косая  черта (\) -"специальный" символ.  Он может ис-
  пользоваться для перехода на другие символы.
       Например, "реальная"  обратная  косая черта должна быть предс-
  тавлена как:  \.
       Следующая таблица описывает все заданные ключи, включая значе-

                               - 120 -

  ния,  используемые по умолчанию для каждого ключа,  если его  соот-
  ветствующий атрибут не определен.

  ───────────┬────────────────────────┬────────────────────────┬─────
  Ключ:      │Описание                │ По умолчанию           │Исп.*
  ───────────┼────────────────────────┼────────────────────────┼─────
  ab=string  │Выполняется, когда адре-│ Пустая строка;  никакая│  T
             │сат  прекращает выполне-│ команда не выполняется │
             │ние команды по какой-ни-│                        │
             │будь причине            │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  af=string  │Файл регистрации,  кото-│ Регистрация не выполня-│  Q
             │рый  могут  использовать│ ется                   │
             │команды                 │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  cd=string  │Каталог, в котором нахо-│ /usr/spool/lp          │  G
             │дятся   временные  файлы│                        │
             │буферизации             │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  ci=string  │Команда copy-in; исполь-│ Двоичное  копирование  │  Q
             │зуется перед постановкой│ задания                │
             │задания  в  очередь  без│                        │
             │преобразования          │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  co=string  │Команда copy-out;исполь-│ Двоичное копирование за│  Q
             │зуется  при удалении за-│ дания  без преобразова-│
             │дания из очереди        │ ния                    │
  ───────────┼────────────────────────┼────────────────────────┼─────
  cp=string  │Программа управления ус-│ Двоичная копия задания.│  T
             │тройством; используется │ Без преобразования     │
             │адресатом               │                        │
             │                        │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  dv=string  │Устройство, которое  ис-│ Направляется на стан-  │ Q,T
             │пользует адресат        │ дартный вывод lpsrvr   │
  ───────────┼────────────────────────┼────────────────────────┼─────
  mn#numeric │Минимальное   количество│ 0; очереди разгружаются│  Q
             │заданий  в  очередях  до│ как только возможно    │
             │начала разгрузки        │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  mx#numeric │Максимальное  количество│ Без ограничения;  огра-│  Q
             │заданий,  которое содер-│ ничение   -   имеющаяся│
             │жит очередь             │ оперативная и  дисковая│
             │                        │ память                 │

                               - 121 -

  ───────────┬────────────────────────┬────────────────────────┬─────
  Ключ:      │Описание                │ По умолчанию           │Исп.*
  ───────────┼────────────────────────┼────────────────────────┼─────
  na=string  │Имя; строка,    которая │ Пустая строка          │ Q,T
             │описывает   очередь  или│                        │
             │адресата                │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  ok=string  │Команда, выполняемая при│ Пустая строка;  никакие│  T
             │нормальном    завершении│ действия не выполняются│
             │работы адресата         │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  pr#numeric │Приоритет     выполнения│ 50                     │  Q
             │данной  очереди (1-100);│                        │
             │100 - самый высокий     │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  qn=string  │Очередь, в которую уста-│ Пустая строка;  задание│  Q
             │навливается задание пос-│ удаляется из буфера    │
             │ле извлечения из буфера │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  sp=string  │Регистрация имени систе-│ Регистрируется /qnx/   │  G
             │мы буферизации, содержа-│ spooler, если не зада- │
             │щей данную очередь      │ но другое имя очереди  │
  ───────────┼────────────────────────┼────────────────────────┼─────
  ta=string  │Адресат, связанный с    │Стандартный вывод lpsrvr│  Q
             │этой очередью           │                        │
  ───────────┼────────────────────────┼────────────────────────┼─────
  wa#numeric │Задержка задания на ука-│ 0; задания  извлекаются│  Q
             │занное количество секунд│ из буфера немедленно   │
             │перед извлечением его из│                        │
             │буфера                  │                        │
  ───────────┴────────────────────────┴────────────────────────┴─────
  * Q=очередь; T=адресат; G=глобально

        Т.к. ключи зависят от регистра клавиатуры,  то Quantum резер-
  вирует все ключи, сформированные на нижнем регистре. Вы можете сами
  формировать пользовательские расширения,  используя верхний регистр
  или комбинацию верхнего и нижнего регистра. Утилиты системы буфери-
  зации игнорируют любые опции, которые они не понимают.

       10.4.2. Глобальные ключевые слова

       Два ключевых слова sp и cd, могут определять глобальную инфор-
  мацию для системы буферизации.  Для того,  чтобы указать,  что  они
  применяются глобально,  этим ключевым словам предшествует пара пус-

                               - 122 -

  тых скобок ([]).

       Регистрация имен - sp

       Т.к. система буферизации всегда настроена на пространство имен
  файла /dev/spool, то на каждом узле может работать только одна сис-
  тема буферизации.  Вы можете запустить несколько систем буферизации
  в Вашей сети, если каждая система буферизации будет регистрировать-
  ся под разными глобальными именами. В противном случае, каждая сис-
  тема  буферизации  будет  пытаться регистрироваться под принятым по
  умолчанию одним и тем же глобальным именем: /qnx/spooler.
       При наличии  нескольких  систем буферизации можно использовать
  такие имена,  как, например, /qnx/spooler2, /qnx/spooler3 и так да-
  лее.
       Для того,  чтобы определить глобальное имя,  которое нужно ре-
  гистрировать  для системы буферизации,  необходимо использовать ко-
  манду sp в файле установки.  Имя всегда должно начинаться с наклон-
  ной черты вправо (/).
       Если ключевое слово sp не определено,  то по умолчанию регист-
  рируется глобальное имя /qnx/spooler (то есть во всей сети).

       Определение временного каталога для файлов буферизации - cd

       Ключевое слово cd позволяет Вам определить каталог, используе-
  мый для создания временных файлов буферизации.  По умолчанию,  вре-
  менные файлы создаются в каталоге /usr/spool/lp. Эти файлы удаляют-
  ся, когда они больше не требуются. Любой путь, который Вы определя-
  ете в ключевом слове cd должен начинаться с ведущей наклонной черты
  вправо.  Имейте в виду,  что задаваемый каталог должен иметь  соот-
  ветствующие  права  доступа.  В следующем примере в файле установки
  регистрируется имя системы буферизации /qnx/spooler2, а также уста-
  навливаются временные файлы в каталог /tmp/spool2:

       # Глобальные переменные системы буферизации

  []
          sp=/qnx/spooler2
          cd=/tmp/spool2

       # Текстовая очередь
  [txt]....
.
                               - 123 -

       10.4.3. Метапеременные

       Система буферизации устанавливает следующие метапеременные:

  ───────────────────────────────────────────────────────────────────
  Переменная:     Описание:
  ───────────────────────────────────────────────────────────────────
  $(file)         Имя подаваемого файла или "--standardinput--", если
                  имя не определено

  $(fname)        Полное имя подаваемого на вход файла или "--standar-
                  dinput--", если никакое имя не определено

  $(spfile)       Имя буферного файла данных

  $(username)     Входное имя пользователя, который запустил задание

  $(userid)       ID пользователя, который запустил задание

  $(queue)        Имя очереди, в которую в настоящее время устанавли-
                  вается задание

  $(target)       Имя адресата, к которому в настоящее время направ-
                  ляется задание

  $(device)       Имя устройства, для которого планируется выполнение
                  задания

  $(ncopies)      Количество копий, запрашиваемых пользователем

  $(jobid)        ID этого задания
  ───────────────────────────────────────────────────────────────────

       Кроме того,  все  определенные выше ключи можно рассматривать,
  как метапеременные.  Например,  $ (ci) расширяется  в  имя  команды
  входного фильтра: ci=string.

       10.4.4. Действия по умолчанию

       Команда cat  используется  по умолчанию в качестве фильтрующих
  команд входного и выходного фильтров. Если не указано особо в файле
  установки,  то  стандартный ввод и стандартный вывод команд фильтра
  автоматически подключается,  по умолчанию,  к файлам или процессам.
  Значение по умолчанию для входного фильтра следующee:

                               - 124 -


          cat < $(fname) > $(spfile)

       Есть две возможности для выходного фильтра,  которые определя-
  ются наличием управляющей программы (то есть, cp):

          cat < $(spfile) > $(device)

          cat < $(spfile) | $(cp) > $(device)

       Например, следующий файл установки:

          [txt]
                  ta=lpt
                  ci=pr -f -h
                  co=txt2ps
                  cp=init_printer
          [-lpt] dv=/dev/par

  в результате дает следующие подстановки:

          pr -f -h < $(fname) > $(spfile)
          txt2ps < $(spfile) | init_printer > /dev/par

       10.5. Использование файлов установки

       10.5.1. Очереди и адресаты

       В файле установки Вы определяете каждую очередь,  давая ей имя
  и дополнительный список параметров;  Вы определяете каждый адресат,
  начиная его имя с тире (-).
       Для того, чтобы проиллюстрировать это, рассмотрим простой файл
  установки:

          [txt]
                  ta=lpt
          [-lpt]
                  dv=/dev/par

       В этом файле у нас есть очередь с именем txt и адресат с  име-
  нем  lpt.  Когда  данные посылаются в очередь буферизации txt,  они
  сохраняются во временном буферном  файле  и  именуются  "заданием."
  Когда система буферизации удаляет задание из очереди, задание пере-
  дается адресату lpt, который затем направляет данные в параллельный

                               - 125 -

  порт /dev/par.

       10.5.2. Фильтры

       Часто приходится  фильтровать буферизованные данные,  для чего
  lpsrvr имеет механизмы входного и выходного фильтрования.  Как было
  упомянуто выше, входное фильтрование выполняется до размещения дан-
  ных в очереди,  а выходное - после того,  как данные  удаляются  из
  очереди.
       Имейте в виду,  что,  если несколько очередей передают  данные
  одному  адресату  и одна из очередей имеет входной фильтр,  который
  требует длительного выполнения,  то адресат будет временно недосту-
  пен для остальных очередей,  если такая очередь выбрана (для полу-
  чения дополнительной информации смотрите раздел "Примеры файлов ус-
  тановки".)

       ВНИМАНИЕ. Рекомендуется метапеременные заключать в двойные ка-
                 вычки, чтобы обеспечить их защищенность для команды.

       Использование входного фильтра

       Ниже приведен  пример использования входного фильтра при пере-
  даче данных через pr для форматирования:

          [txt]
                  ci=pr -f -h "$(file)"
                  ta=lpt

          [-lpt]
                  dv=/dev/par

       Использование выходного фильтра

       Вы могли бы использовать выходной фильтр, например, для однов-
  ременной работы с лазерными принтерами PostScript и HP.  Два выход-
  ных  фильтра  могут сгенерировать соответствующие выходные форматы.
  Скажем,  у Вас есть две программы: txt2ps, которая генерирует Post-
  Script и txt2hpgl, которая генерирует hpgl:

          [ps ]
                  ta=lpt1
                  co=txt2ps
          [hp]
                  ta=lpt2

                               - 126 -

                  co=txt2hpgl
          [-lpt1]
                  dv=/dev/ser
          [-lpt2]
                  dv=/dev/par

       ВНИМАНИЕ. Не кодируйте жестко устройство вывода в  определении
                 выходного фильтра; используйте для этой цели адреса-
                 ты.  Адресаты должны иметь исключительное право дос-
                 тупа к устройству и должны быть единственными средс-
                 твами доступа в пределах системы буферизации.

       10.5.3. Сцепление очередей

       Очереди могут быть сцеплены,  это позволяет перемещать задания
  из очереди в очередь. Ниже приведен простой пример сцепления с оче-
  редью с именем tmp, которая посылает данные в адресат lpt:

          [txt]
                  qn=tmp
          [tmp]
                  ta=lpt
          [-lpt]
                  dv=/dev/par

       10.5.4. Регистрация информации

       Ключевое слово  af позволяет определить имя файла,  к которому
  команды могут получить доступ через $(af) и,  таким образом,  запи-
  сать любую информацию, которую они хотят зарегистрировать.

       10.5.5. Трактовка ошибок

       Ошибки ввода.  Утилита lp дает некоторые ошибки, которые появ-
  ляются во время ввода данных в очередь. Если Вы вводите данные, за-
  писывая  их  непосредственно  в буферный файл в каталог /dev/spool,
  ошибки появляются в том случае, если что-либо препятствует успешной
  записи в очередь.

       Ошибки вывода. Вы можете использовать ключевое слово ab, чтобы
  определить команду для выполнения в случае,  если адресат отказыва-
  ется от задания. Следующая команда будет информировать пользователя
  об ошибке через сообщение почты:


                               - 127 -

          ab=echo lpsrvr print job $(jobid), file $(file) failed \
          | mailx $(username)

       10.6. Примеры файлов установки

       10.6.1. Несколько очередей к одному адресату

       В следующем примере показано несколько очередей, которые имеют
  один общий адресат. Три очереди названы:

          txt     (ASCII текстовые файлы)
          ps      (файлы PostScript)
          gif     (файлы графического формата)

       Конфигурация выглядит следующим образом:

  ┌─────────────────────────────────────────────────────────────────┐
  │ (txt) ┌───────┐    ┌───┬───┬───┐                (lpt)           │
  │──────>│text2ps├───>│   │   │   ├───────┬─────────────>/dev/par  │
  │       └───────┘    └───┴───┴───┘       │                        │
  │ (ps)               ┌───┬───┬───┐       │                        │
  │───────────────────>│   │   │   ├───────┤                        │
  │                    └───┴───┴───┘       │                        │
  │ (gif) ┌───────┐    ┌───┬───┬───┐       │                        │
  │──────>│gif2ps ├───>│   │   │   ├───────┘                        │
  │       └───────┘    └───┴───┴───┘                                │
  └─────────────────────────────────────────────────────────────────┘

                               Рис. 22

       Файл, определяющий эту установку, имеет следующий вид:

          # ASCII в очередь PostScript:
          [txt]
                  ta=lpt
                  ci=text2ps
          pr#50

          # прямая очередь PostScript:
          [ps]
                  ta=lpt
                  pr#60

          # GIF в очередь Postscript:

                               - 128 -

          [gif]
                  ta=lpt
                  ci=gif2ps
                  pr#5

          # принтер адресата:
          [-lpt]
                  dv=/dev/par

       В этом  примере пользователи,  используя утилиту lp,  посылают
  файлы в соответствующую очередь с входным фильтром,  который преоб-
  разовывает файл (за исключением очереди ps). Затем очередь передает
  преобразованные данные адресату /dev/par.  Т.к.  для гипотетических
  фильтрующих  программ  text2ps и gif2ps может потребоваться большое
  количество времени для выполнения задания, то вместо выходных филь-
  тров используются входные фильтры.  На время работы выходного филь-
  тра адресат блокируется, тем самым задерживая извлечение других за-
  даний из очереди.  Выбранная конфигурация позволяет посылать другие
  задания адресату, пока генерируется перевод в PostScript. Кроме то-
  го,  т.к. графические файлы имеют большой размер, им назначен более
  низкий приоритет, чем другим.

       10.6.2. Несколько очередей к трем адресатам

       Следующий пример  является  дальнейшим  развитием   установки,
  рассмотренной выше, с некоторыми дополнительными особенностями, не-
  обходимыми для расширенной конфигурации.  Теперь имеется три лазер-
  ных  принтера  PostScript,  расположенные  в  разных  частях здания
  (подключенные к //1/dev/ser1,  //2/dev/ser1 и //3/dev/ser1). Конфи-
  гурация будет выглядеть следующим образом:

  ┌─────────────────────────────────────────────────────────────────┐
  │ (txt) ┌───────┐    ┌───┬───┬───┐             (lp1)              │
  │──────>│text2ps├───>│   │   │   ├──────┬────┬──────>//1/dev/ser1 │
  │       └───────┘    └───┴───┴───┘      │    │                    │
  │ (ps)               ┌───┬───┬───┐      │    │ (lp2)              │
  │───────────────────>│   │   │   ├──────┤    ├──────>//2/dev/ser1 │
  │                    └───┴───┴───┘      │    │                    │
  │ (gif) ┌───────┐    ┌───┬───┬───┐      │    │ (lp3)              │
  │──────>│gif2ps ├───>│   │   │   ├──────┘    └──────>//3/dev/ser1 │
  │       └───────┘    └───┴───┴───┘                                │
  └─────────────────────────────────────────────────────────────────┘

                               Рис. 23

                               - 129 -


       Файл для такой установки имеет вид:

  # ASCII в очередь PostScript:
  [txt]
          ta=lp1,lp2,lp3
          ci=text2ps
          pr#50

  # прямая очередь PostScript:

          [ps]
          ta=lp1,lp2,lp3
          pr#60

  # GIF в очередь PostScript:
  [gif]
          ta=lp1,lp2,lp3
          ci=gif2ps
          pr#5

  # принтеры адресата:

  [-lp1]
          dv=//1/dev/ser1
          ok=echo file $(fname) sent to $(target) | mailx $(username)

          ab=echo file $(fname) did not get printed | mailx
          $(username)

  [-lp2]
          dv=//2/dev/ser1
          ok=echo file $(fname) sent to $(target) | mailx $(username)
          ab=echo file $(fname) did not get printed | mailx
          $(username)

  [-lp3]
          dv=//3/dev/ser1
          ok=echo file $(fname) sent to $(target) | mailx $(username)
          ab=echo file S(fname) did not get printed | mailx
          $(username)

       Вышеуказанная конфигурация использует те же три очереди  (txt,
  ps,  и gif), описанные раньше, но теперь они выходят на три отдель-

                               - 130 -

  ных адресата.
       Система буферизации выбирает первый доступный адресат из набо-
  ра адресатов (lp1,  lp2,  lp3) и посылает данные на соответствующий
  принтер. Выбор из очереди производится сначала по приоритету, затем
  по времени нахождения задания в очереди.  В этом примере инициатору
  задания посылается почтовое сообщение,  информируя его о нормальном
  или ненормальном завершении задания.

       10.7. Доступ к программам буферизации и очередям

       Многие системы  буферизации  могут работать в сети,  каждая из
  них может поддерживать несколько очередей. Для того, чтобы связать-
  ся с любой системой буферизации, утилиты lp сначала определяют уни-
  кальное глобальное имя системы буферизации,  с которым она была за-
  регистрирована  (смотрите раздел "Глобальные ключевые слова").  При
  использовании любой утилиты lp Вы можете определять систему буфери-
  зации и очередь различными путями.
       Вы можете:
       - не задавать имя каксистемы буферизации,  так и очереди;
       - задавать имя только системыбуферизации;
       -  задавать имя только очереди;
       - задавать имена как системы буферизации так и очереди.

       Если Вы не задаете имя системы буферизации в командной строке,
  то утилита lp проверяет внешнюю переменную LPSRVR, которая содержит
  имя системы буферизации, принятое по умолчанию. Однако, если LPSRVR
  не определена,  то утилита lp будет использовать систему  буфериза-
  ции, которая зарегистрирована по умолчанию под глобальным именем:

                  /qnx/spooler

       Если утилита lp успешно определила систему буферизации,  но Вы
  не  задали  в командной строке имя очереди,  то утилита lp проверит
  внешнюю переменную LPDEST,  которая содержит имя очереди,  принятое
  по умолчанию.  Однако, если LPDEST не определена, то утилита lp бу-
  дет использовать первую очередь в файле установки для уже  заданной
  системы буферизации.

       10.7.1. Переменные LPSRVR и LPDEST

       Внешние переменные LPSRVR и LPDEST используются,  когда инфор-
  мация командной строки,  передаваемая утилитам lp, полностью не оп-
  ределяет, какую систему буферизации или очередь использовать.


                               - 131 -

       LPSRVR определяет  имя  системы  буферизации,  принимаемое  по
  умолчанию. Следующее определение LPSRVR задает одну систему буфери-
  зации с именем /qnx/spooler2:

                  export LPSRVR=/qnx/spooler2

       Имя, определенное в LPSRVR, должно всегда начинаться с ведущей
  наклонной черты вправо. LPSRVR никогда не должна содержать имя оче-
  реди.

       LPDEST определяет  имя очереди,  принимаемое по умолчанию.  Вы
  можете использовать LPDEST двумя способами.  Вы можете только опре-
  делить очередь:

                  export LPDEST=waybills

       Или Вы можете определить систему буферизации и очередь:

         export LPDEST=/qnx/spooler2/waybills
          ──────┬─────  ───┬───
                │          │Очередь
                │Система
                │буферизации

       Если Вы  определяете  систему буферизации в переменной LPDEST,
  то переменная LPSRVR игнорируется, даже если она и определена.

       ВНИМАНИЕ. Если LPDEST не определена, то для совместимости ути-
                 литы lp смотрят на традиционную UNIX-переменную
                 PRINTER.

       10.7.2. Примеры

       Рассмотрим несколько простых примеров,  которые показывают не-
  которые  способы  задания  систем буферизации и очередей.  Для этих
  примеров предположим, что имеется две системы буферизации, каждая с
  двумя очередями. Первая система буферизации использует по умолчанию
  глобальное имя /qnx/spooler;  его очереди названы txt и ps.  Вторая
  система буферизации использует имя /qnx/spooler2,  его очереди наз-
  ваны cheques и waybills.
.
                               - 132 -

          Первая система буферизации:     Вторая система буферизации:

          /qnx/spooler/txt                /qnx/spooler2/cheques
          /qnx/spooler/ps                 /qnx/spooler2/waybills

       Имена системы буферизации и очереди не заданы

       Скажем, Вы  вводите следующую команду lp,  не задавая имена ни
  системе буферизации, ни очереди:

                  lp test.dat

       Сначала утилита будет пытаться определить систему буферизации,
  проверяя LPSRVR.  Если эта переменная не определена, то утилита оп-
  ределит для системы буферизации принятое  по  умолчанию  глобальным
  имя /qnx/spooler.  Затем утилита будет пытаться определить имя оче-
  реди, проверяя LPDEST. Если эта переменная не определена, то утили-
  та выберет первую очередь, определенную в файле установки для ранее
  определенной системы буферизации.

       Задано только имя системы буферизации:

       Если Вы определяете строку,  которая начинается с ведущей нак-
  лонной черты вправо,  то строка всегда считается именем системы бу-
  феризации.  Таким образом,  если Вы введете следующую  команду,  то
  утилита рассмотрит имя /qnx/spooler2, как имя системы буферизации:

                  lp -P /qnx/spooler2 test.dat

       Т.к. вторая  система  буферизации имеет имя /qnx/spooler2,  то
  эта система буферизации и будет определена. Затем утилита будет пы-
  таться  получить  имя очереди из переменной LPDEST.  Если LPDEST не
  определена, то задание передается очереди cheques, т.к. она являет-
  ся первой очередью в файле установки /qnx/spooler2.

       Задано только имя очереди:

       Если Вы  определяете  строку,  которая не начинается с ведущей
  наклонной черты вправо,  то строка всегда считается именем очереди.
  Таким  образом,  если  Вы введете следующую команду,  то утилита lp
  рассмотрит txt, как очередь:

                  lp -P txt test.dat


                               - 133 -

       Утилита lp сначала будет пытаться определить систему буфериза-
  ции, проверяя LPSRVR. Если эта переменная не определена, то утилита
  lp будет использовать первую систему буферизации,  т.к. эта система
  зарегистрировала  глобальное имя /qnx/spooler,  принятое по умолча-
  нию.

       Заданы имена как системы буферизации, так и очереди:

       В следующем примере как системе  буферизации,  так  и  очереди
  присвоены имена.  Т.к.  строка начинается с ведущей наклонной черты
  вправо,  утилита lp сначала будет пытаться обнаружить систему буфе-
  ризации с именем /qnx/spooler2/waybills.

                  lp -P /qnx/spooler2/waybills test.dat

       Однако, т.к.  системы  буферизации с именем /qnx/spooler2/way-
  bills не существует, утилита будет рассматривать данную строку, как
  имя системы буферизации,  за которой следует имя очереди.  При этом
  будет определена система буферизации с именем /qnx/spooler2,  и за-
  дания  будут передаваться очереди waybills в этой системе буфериза-
  ции.

       10.7.3. Файлы инициализации

       Можно сформировать несколько систем буферизации, задаваемых по
  умолчанию,  если, например, Ваши отделы маркетинга, продаж и техот-
  дел имеют свои системы буферизации:

          LPSRVR=/qnx/spooler     отдел маркетинга
          LPSRVR=/qnx/spooler2    отдел продаж
          LPSRVR=/qnx/spooler3    техотдел

       Вы должны присвоить значения внешним переменным в файлах  сис-
  темной инициализации.  Для этого можно использовать один из следую-
  щих файлов:

          /etc/config/sysinit.node           выполняется при загрузке;
          /etc/default/login          выполняется при входе в систему;
          /etc/profile       выполняется при каждом запуске  командно-
                             го интерпретатора.
.
                               - 134 -


     Глава 11. ПОСТРОЕНИЕ ЗАДАННОГО ОБРАЗА ОПЕРАЦИОННОЙ СИСТЕМЫ 

       В этой главе...

       Создание файла построения

       11.1. Введение

       QNX - модульная операционная система, состоящая из микроядра и
  одного  или более процессов,  которые обеспечивают сервисные функции.
  Например,  процесс с именем Fsys обеспечивает  обслуживание  файловой
  системы,  а процесс с именем Dev обеспечивает обслуживание устройств.
  Когда Вы формируете образ операционной  системы,  Вы  должны  выбрать
  сервисные функции, которые Вы хотите иметь доступными немедленно пос-
  ле загрузки,  и включить процессы, которые обеспечивают этот сервис в
  построенном образе операционной системы.  Этот образ создается утили-
  той buildqnx.  Образ может быть загружен с диска программой-загрузчи-
  ком раздела QNX или загружен через сеть утилитой netboot.

       11.2. Создание файла построения

       Утилита buildqnx берет текстовый файл,  содержащий список имен
  процессов, как входные данные, и создает файл бинарного образа, со-
  держащий эти процессы, как выходные данные. Входной файл называется
  файл построения.  Файлы построения содержатся в каталоге  /boot/bu-
  ild,  а файлы образа содержатся в каталоге /boot/images.  Вы можете
  создать образ,  вызывая buildqnx непосредственно или используя ути-
  литу make и Makefile в каталоге /boot.  Например, Вы можете исполь-
  зовать:

                  buildqnx build/hard.1 images/hard.1
  или
                  make b=hard.1

       Каждая программа, которую Вы хотите включить в создаваемый об-
  раз,  занимает две строки в файле построения. Пустые строки игнори-
  руются.  Первая строка - полное имя программы,  которую  Вы  хотите
  включить.  Вторая строка начинается с $,  за которым следует число,
  представляющее размер  памяти  (в  динамической  области),  которая
  должна использоваться, затем - команда.
.
                               - 135 -

       11.2.1. Установка размеров памяти в динамической области

       Когда образ  создается для процесса,  в сегменте данных образа
  резервируется пространство для локального распределения памяти. Ес-
  ли  это  пространство  устанавливается  слишком маленьким,  система
  должна динамически увеличить размер сегмента данных при выполнении,
  в результате чего уменьшается фрагментация памяти.  Если пространс-
  тво устанавливается слишком большим,  у Вас будет  неиспользованная
  память. Для получения дополнительной информации об установке подхо-
  дящих размеров распределяемой памяти смотрите Proc в "Utilities Re-
  ference".

       11.2.2. Установка приоритетов

       Вы можете дополнительно установить начальный приоритет процес-
  са,  для этого за размером распределяемой памяти через ":" указыва-
  ется желаемый приоритет. Например, следующая команда запустит Адми-
  нистратор устройств (Dev) с объемом памяти 4К и приоритетом 24:

                  /bin/Dev
                  $ 4000:24 Dev

       Устанавливая приоритет таким образом,  Вы можете управлять по-
  рядком запуска процессов.

       11.2.3. Выбор процессов для образа

       Процессы, которые Вы включаете в образ  операционной  системы,
  определяются  некоторыми  факторами.
       Образы делятся на три класса:
       - образы, которые загружаются с диска;
       - образы, которые загружаются через сеть;
       - образы для встроенных систем.

       Для образов,  которые  загружаются с диска или через сеть,  Вы
  можете запустить большинство процессов после загрузки,  размещая их
  в командной строке в файле системной инициализации, который QNX вы-
  полняет после загрузки (смотрите раздел "Файл системной инициализа-
  ции" в главе 4).  Это позволит Вам держать образ загрузки небольшим
  и простым.
       Когда Вы строите образ,  запомните,  что есть два обязательных
  процесса:
       -  Администратор  процессов/Микроядро  (/boot/sys/Proc),
       -  системная разделяемая библиотека (/boot/sys/Slib)

                               - 136 -


       11.2.4. Образы диска

       Для загрузки с жесткого диска Вы должны включить:
       - два обязательных системных процесса (Proc и Slib),
       - Администратор файловой системы (Fsys),
       - драйвер, необходимый для доступа к накопителю (Fsys.driver)

       ВНИМАНИЕ. Для получения дополнительной информации смотрите bu-
                 ildqnx и sinit в "Utilities Reference".

       Makefile для загрузки с диска

       Makefile в каталоге /boot содержит информацию  для  выполнения
  общей загрузки с жесткого диска.  Вы можете задать макроопределение
  в командной строке, чтобы изменить значения по умолчанию:

  ───────────────────────────────────────────────────────────────────
  Макрокоманда    Аргумент make   По умолчанию      Описание
  ───────────────────────────────────────────────────────────────────
          $b      b=buildfile     no default        файл построения
          $d      d=driver        Fsys.wd           дисковый драйвер
          $h      h=hard disk     /dev/hd0          жесткий диск
          $i      i=imagefile     images/buildfile  файл образа
          $p      p=parameters    no default        параметры жестко-
                                                    го диска
  ───────────────────────────────────────────────────────────────────

       Далее следует пример содержания makefile:

          FILES = @build/$b

          # Определяет некоторые значения по умолчанию, которые могут
          быть переопределены # посредством h=xx и d=xx

          d       = Fsys.wd
          h       = /dev/hd0
          i       = $b

          $b:     images/$b

          # Каждый файл образа операционной системы зависит от входя-
  щих в него модулей ядра
          images/$b: build/$b $(FILES)

                               - 137 -

                  buildqnx -v d=$d h=$h p=$p build/$b images/$i

       Примеры

       Следующие примеры  помогут  разъяснить использование Makefile:
  Используйте файл построения  /boot/build/hard.1  и  создайте  образ
  /boot/images/hard.1, который содержит драйвер Western Digital и ко-
  манду mount,   которая   устанавливает   файловую    систему    QNX
  на /dev/hd0t77:

                  make b=hard.1

       Используйте файл  построения /boot/build/hard.1 и cоздайте об-
  раз /boot/images/hard.1,  который содержит драйвер PS/2 SCSI вместо
  драйвера  Western  Digital  и команду mount,  которая устанавливает
  файловую систему QNX на SCSI ID 6:

                  make b=hard.1 d=Fsys.ps2s h=/dev/hd6

       Используйте файл построения /boot/build/hard.1 и cоздайте  об-
  раз  /boot/images/ps2s,  который  содержит драйвер PS/2 SCSI вместо
  драйвера Western Digital и  команду  mount,  которая  устанавливает
  файловую  систему QNX на SCSI ID 6.  Образ записывается в файл 0 образа
  ps2s,  а не в файл по умолчанию,  который имеет имя в  опции b=  (в
  этом случае hard.1).

                  make b=hard.1 d=Fsys.ps2s h=/dev/hd6 i=ps2s

       Копирование образа в /.boot

       Сформированный Вами  образ не станет образом новой загрузки до
  тех пор,  пока Вы не скопируете его в файл /.boot.  Однако, прежде,
  чем сделать это, Вам следует сохранить текущий файл /.boot, копируя
  его в файл /.altboot:

                  cp /.boot /.altboot

       Если по некоторой причине Ваш новый образ  не  будет  работать
  правильно, Вы можете нажать <Esc> после подсказки во время процесса
  загрузки и загрузить файл /.altboot вместо файла /.boot.  Когда  Вы
  выберете образ альтернативной загрузки,  обычная проверка для файла
  /etc/config/sysinit.node заменяется проверкой для  файла  /etc/con-
  fig/altsysinit. Вам следует убедиться, что файл altsysinit содержит
  самую последнюю копию Вашего работающего файла sysinit:

                               - 138 -


                  cp /etc/config/sysinit.nodе /etc/config/altsysinit

       Имейте в виду,  что файл построения hard.1 не  содержит  Адми-
  нистратор устройств /bin/Dev. Администратор устройств и его драйве-
  ры обычно запускаются из файла системной инициализации  после  заг-
  рузки системы.

       ВНИМАНИЕ. Если  файл  системной  инициализации не выполняется,
                 Администратор устройств не запустится. В результате,
                 Ваша клавиатура и системная консоль не будут функци-
                 онировать.

       11.2.5. Сетевые образы

       Для загрузки через сеть Вы должны включить:
       - два необходимых системных процесса (Proc и Slib),
       - Сетевой Администратор (Net),
       - драйвер, необходимый для доступа в сети (Net.driver).

       Makefile для сетевой загрузки

       Makefile в  /boot  содержит информацию для выполнения загрузки
  рабочей станции.  Следующий пример использует файл построения  /bo-
  ot/build/ws.arcnet и создает образ /boot/images/ws.arcnet:

                  make b=ws.arcnet

       Когда Вы загружаетесь через сеть,  Вы можете загрузить заранее
  сформированный образ или сформировать его в процессе загрузки. Если
  Вы формируете образ в процессе загрузки,  что рекомендуется, то Вам
  не требуется формировать его вручную, как показано выше. Этот вари-
  ант  задается  в  файле /etc/boot/netboot и регистрируется утилитой
  netboot.

       ВНИМАНИЕ. Когда утилита netboot вызывает buildqnx, чтобы пост-
                 роить образ в процессе загрузки,  файл образа не за-
                 писывается на диск.

       11.2.6. Встроенные образы

       Встроенной системе не требуется файловая система  или  Сетевой
  администратор. Поэтому образ должен содержать все процессы, необхо-
  димые для работы системы.  Этот образ затем должен быть передан  во

                               - 139 -

  встроенную систему (наиболее вероятно, в ПЗУ).
.
                               - 140 -

         Глава 12. ИСПОЛЬЗОВАНИЕ СИСТЕМЫ УПРАВЛЕНИЯ ВЕРСИЯМИ

       В этой главе...

       Что такое  система управления версиями - RCS (Revision Control
       System)?
       Подготовка к работе
       Автоматическая идентификация
       Фор-мат RCS-файлов
       Команды RCS

       12.1. Что такое RCS?

       RCS помогает Вам управлять множеством версий текстовых файлов.
  RCS автоматизирует хранение, поиск, регистрацию, определение и объ-
  единение версий. RCS полезна для любого текста, который часто меня-
  ется,  включая программы,  документацию,  графику, статьи и форматы
  писем.
       Точнее говоря, RCS позволяет Вам делать следующее:
       - Хранить и отыскивать множество версий текста - В RCS измене-
  ния не уничтожают подлинник; предшествующие версии остаются доступ-
  ными.  Вы можете отыскать версии в диапазоне по числу  исправлений,
  символическим  именам,  дате,  авторам и состоянию.
       - Поддерживать полную историю изменений - RCS регистрирует все
  изменения  автоматически.  Кроме  того,  в тексте каждой версии RCS
  хранит имя автора,  дату, время регистрации и регистрационное сооб-
  щение,  суммирующее изменения. Регистрация облегчает выяснение, что
  случилось с модулем,  не делая сравнения исходных распечаток  и  не
  беспокоя расспросами коллег.
       - Решать конфликты доступа - Когда два или более  программиста
  пытаются  изменить одну и ту же версию,  RCS предупреждает програм-
  мистов и предохраняет одну модификацию от искажения другой.
       - Поддерживать  дерево версий - RCS может поддерживать отдель-
  ные строки разработки для каждого модуля.  Система загружает древо-
  видную  структуру,  которая представляет собой предшествующие связи
  между версиями.
       - Объединение  версий и разрешение конфликтов - Вы можете объ-
  единить две отдельные строки разработки для  модуля.  Если  версии,
  которые  нужно объединить,  относятся к одному и тому же коду,  RCS
  предупреждает Вас о перекрытии версий.
       - Управление  версиями  и конфигурациями - Вы можете присвоить
  символические имена версиям и отметить версии,  как выходные,  ста-
  бильные, экспериментальные и т.п. Таким способом конфигурация моду-
  лей может быть описана просто  и  непосредственно.

                               - 141 -

       - Автоматически  опознавать  каждую версию - RCS позволяет Вам
  присвоить каждой версии имя, номер версии, время создания, автора и
  т.п.  Идентификация  - подобно метке,  которую Вы можете вставить в
  соответствующее место текста версии. Идентификация упрощает опреде-
  ление того, какие версии каких модулей создают данную конфигурацию.
       - Минимизировать вторичную  память - RCS  необходим  небольшой
  дополнительный объем памяти для версий, т.к. хранятся только разли-
  чия. Если промежуточные версии удаляются, то соответствующие данные
  сжимаются.

       12.2. Подготовка к работе

       Базовый интерфейс  с пользователем для RCS прост для изучения.
  Вы можете выполнить большинство основных функций с  помощью  только
  двух команд:
       - команда ci - "check-in".  Эта команда  размещает  содержимое
  файла в архивном файле, названном RCS-файлом. RCS-файл содержит все
  версии конкретного файла;
       - команда co - "check-out". Эта команда отыскивает исправления
  в RCS-файле, создавая рабочий файл.

       12.2.1. Сохранение

       Теперь допустим,  у Вас есть файл f.c, который Вы хотите уста-
  новить под управлением RCS. Вызовите команду сохранения ci:

                  ci f.c

       Эта команда:
       1) создает RCS-файл f.c,v;
       2) загружает f.c в f.c,v, как исправление 1.1;
       3) удаляет f.c;
       4) запрашивает у Вас описание.
       Описание, которое Вы вводите,  должно быть кратким обзором со-
  держимого файла.  Все последующие команды сохранений запросят у Вас
  логический вход, под которым будут суммироваться изменения, которые
  Вы  сделали.  Файлы,  заканчивающиеся ",v",  называются RCS-файлами
  (v стоит для "версий"); все другие файлы называются рабочими файла-
  ми.

       12.2.2. Извлечение

       Для того, чтобы получить рабочий файл f.c в вышеуказанном при-
  мере, используйте команду извлечения co:

                               - 142 -

                  со f.c

       Эта команда извлекает самую последнюю версию из f.c,v и  запи-
  сывает  его  в f.c.  Если Вы хотите отредактировать f.c,  Вы должны
  заблокировать доступ к нему, когда Вы извлекаете его по команде со:

                  со -l f.c

       Теперь Вы можете редактировать f.c.
       Скажем, Вы провели редактирование и хотите увидеть,  какие из-
  менения Вы сделали. Команда:

                  rcsdiff f.c

  сообщит Вам различие между самой последней сохраненной версией и  ра-
  бочим файлом. Вы можете затем опять сохранить файл, вызывая:

                  ci f.c

       При этом номер версии соответственно увеличивается.

       12.2.3. Блокирование файлов

       Если ci выдает сообщение:

                  ci error: no lock set by your name

       Это значит,  что  Вы пытались выполнить сохранение (ci) файла,
  не блокируя его при выполнении извлечения (co). Конечно, теперь уже
  поздно  выполнять команду co с блокировкой,  т.к. другая команда co
  перезапишет Ваши модификации. Вместо этого, Вам следует вызвать:

                  rcs -l f.c

       Эта команда заблокирует для Вас самую последнюю  версию,  если
  кто-нибудь другой уже не опередил Вас.  В этом случае Вы должны до-
  говориться с этим человеком.
       Блокировка гарантирует,  что Вы и только Вы  можете  сохранить
  следующую коррекцию, и избавляет от проблем, если несколько человек
  работают с одним и тем же файлом.  Даже если версия блокирована, то
  файл может быть доступен для чтения,  компиляции и т.п.
       Единственное, что обеспечивает блокировка,  это предотвращение
  выполнения команды ci кем-нибудь другим, кто не выполнил блокирова-
  ние. Если Ваш RCS-файл - личный (то есть Вы - единственный человек,

                               - 143 -

  который собирается делать в нем исправления), строгая блокировка не
  нужна и Вы можете ее отключить.
       Если строгая блокировка выключена,  владелец RCS-файла не нуж-
  дается в блокировании для команды ci,  но все  другие  пользователи
  должны ее делать.
       Включить и выключить строгую блокировку Вы  можете  следующими
  командами:

          rcs -L f.c      установить строгую блокировку
          rcs -u f.c      установить нестрогую блокировку

       12.2.4. Создание RCS-каталога

       Если Вы  не хотите привести в беспорядок Ваш текущий каталог с
  RCS-файлами,  создайте подкаталог,  названный RCS,  в Вашем текущем
  каталоге  и переместите туда все Ваши RCS-файлы.  RCS-команды прос-
  мотрят сначала этот каталог, чтобы найти необходимые файлы. Все ко-
  манды,  рассмотренные выше, будут работать без какой-либо модифика-
  ции.
       Вы можете определить пары RCS- и рабочих файлов тремя  путями:
       - задать оба файла;
       - задать только рабочий файл;
       - задать только RCS-файл.
       Как RCS, так и рабочие файлы могут иметь произвольные префиксы
  маршрута; команды RCS сопоставят их автоматически.

       12.2.5. Защита Вашего рабочего файла

       Для того,  чтобы избежать удаления рабочего файла во время вы-
  полнения check-in в случае,  если Вы хотите продолжить редактирова-
  ние или компиляцию, введите одну из этих команд:

                  ci -l f.c
                  ci -u f.c

       Эти команды сохраняют f.c,  как обычно,  но выполняют  неявное
  извлечение.   Таким   образом,  они  сохраняют  Вам  одну  операцию
  check-out.  Команда ci -l также блокирует сохранение версии  -  это
  полезно,  если Вы хотите продолжить редактировать. Команда ci -u не
  блокирует сохранение версии - это полезно,  если Вы  просто  хотите
  прочитать  файл.  Обе  команды корректируют маркеры идентификации в
  Вашем рабочем файле (смотрите "Автоматическую идентификацию").

       12.2.6. Присваивание номеров исправлений

                               - 144 -

       В команде ci Вы можете задать номер, который Вы хотите присво-
  ить сохраняемым версиям. Скажем, все Ваши версии были пронумерованы
  1.1, 1.2, 1.3 и т.п., и Вы хотите начать версию 2. Одна из этих ко-
  манд:

                  ci -r2 f.c
                  ci -r2.1 f.c

  присвоит номер 2.1 новому исправлению. Затем команда ci будет нуме-
  ровать последующие исправления: 2.2, 2.3 и т.п. Соответствующие ко-
  манды со:

                  со -r2 f.c
                  со -r2.1 f.c

  найдут самое последнее исправление с номером 2.x и исправление 2.1,
  соответственно. Если Вы вызываете команду со без номера версии, она
  выбирает  самую  последнюю версию (то есть самую последнюю версию с
  номером, состоящим из двух частей). Номера более чем с двумя частя-
  ми необходимы для ветвей.  Например, для того, чтобы начать ветвь в
  версии 1.3, вызовите:

                  ci -r1.3.1 f.c

       Эта команда начинает ветвь номер в версии  1.3  и  присваивает
  номер 1.3.1.1 новой версии. Для получения дополнительной информации
  о ветвях смотрите раздел "Формат RCS-файлов".

       12.3. Автоматическая идентификация

       RCS позволяет Вам размещать специальные строки идентификации в
  Ваши исходный и объектный коды. Вы просто устанавливаете маркер:

                  $Id$

  в Ваш текст, например, в комментарии. RCS заменит этот маркер строкой
  следующего вида:

                  $Id: filename revision date time author state $

       С таким маркером на первой странице каждого модуля  Вы  можете
  всегда увидеть, с какой версией Вы работаете. RCS сохраняет маркеры
  последней версии автоматически. Для того, чтобы перенести маркеры в
  Ваш объектный код,  просто поместите их в литерные символьные стро-

                               - 145 -

  ки. В языке Cи Вы делаете это следующим образом:

                  static char rcsid[] = "$Id$";
       Команда ident  извлекает  такие маркеры из любого файла,  даже
  объектного кода и дампов.  Таким образом,  команда ident  позволяет
  Вам выяснять, какие исправления каких модулей использовались в дан-
  ной программе.  Полезно устанавливать маркер $Log$ в  Ваш  текст  в
  комментарии. Этот маркер накапливает регистрационные сообщения, ко-
  торые запрашиваются во время регистрации.  Таким образом, Вы можете
  хранить  полную историю Вашего файла непосредственно в файле.  Есть
  различные дополнительные маркеры идентификации; описание команды со
  дано в "Utilities Reference".

       12.3.1. Дополнительная информация

       Если Вы  хотите  получить дополнительную информацию о RCS,  мы
  рекомендуем: Walter F. Tichy, "RCS - система для управления версия-
  ми," Software - Practice & Experience 15, 7, July 1985.

       12.4. Формат RCS-файлов

       Содержание RCS-файлов описано нижеуказанной грамматикой. Текст
  - в свободном формате, следующие символы, которые формируют пробел,
  не имеют никакого значения и исключаются в строках:

                  <space>
                  <backspace>
                  <tab>
                  <newline>
                  <vertical tab>
                  <form feed>
                  <carrige return>

       Строки заканчиваются одним знаком @ в конце каждой строки. Ес-
  ли строка должна содержать эти знаки,  знак @ должен быть удвоен. В
  противном случае, строки могут содержать произвольные двоичные дан-
  ные. Метасинтаксис использует следующие соглашения:
.
                               - 146 -

  ───────────────────────────────────────────────────────────────────
  Соглашение:     Назначение:
  ───────────────────────────────────────────────────────────────────
          |       разделяет альтернативы
          { и }   включает необязательные фразы
          { и }*  включает фразы,  которые могут быть повторены нуль
                  или более раз

          { и }+  включает фразы, которые должны появиться, по крайней
                  мере, один раз и могут быть повторены
  ───────────────────────────────────────────────────────────────────

       Имейте в виду также,  что эти  терминальные  символы  выделены
  двойной толщиной; нетерминальные символы - курсивом.

  rcstext ::=     admin {delta}* desc {deltatext}*

  admin   ::=     head    {num};
                  { branch        {num}; }
                  access  {id}*;
                  symbols {id:num}*;
                  locks   {id:num}*;      {strict;}
                  { comment       {string}; }
                  { expend        {string}; }
                  { newphrase }*

  delta   ::=     num
                  date    num;
                  author  id;
                  state   {id};
                  branches        {num}*;
                  next    {num};
                  { newphrase }

  desc    ::=     desc    string

  deltatext       ::=     num
                  log     string
                  { newphrase }*
                  text    string

  num     ::=     {digit{.}}+
  digit   ::=     0|1|..|9
  id      ::=     letter{idchar}*

                               - 147 -

  letter  ::=     любая буква
  idchar  ::=     любой видимый графический символ кроме специального
  special ::=     $|,|.|:|;|@
  string  ::=     @{любой символ с удвоенным @}*@
  newphrase       ::=     id word*;
  word    ::=     id|num|string|:

       Идентификаторы зависят от регистра. Ключевые слова - только на
  нижнем регистре.  Множества ключевых слов и  идентификаторов  могут
  перекрываться.
       В большинстве сред RCS  использует  кодирование  по  ISO 8859/1:
       буквы - восьмиричные коды 101-132, 141-172, 300-326, 330-366 и
  370-377;
       видимые графические символы - коды 041-176 и 240-377;
       символы пробелов - коды 010-015 и 040. Идентификаторы newphra-
  se  в  грамматике  резервируются  для  будущих расширений в формате
  RCS-файлов.
       Никакой из идентификаторов newphrase не начнется с любого, уже
  применяемого,  ключевого слова. Узлы delta образуют дерево. Все уз-
  лы,  чьи номера состоят из единственной пары (например,  2.3,  2.1,
  1.3 и т.п.),  образуют ствол и компонуются через следующее  поле  в
  порядке уменьшения чисел.
       Поле head в узле admin указывает на начало этой  последователь-
  ности (то есть оно содержит самую верхнюю пару).
       Узел branch в узле admin указывает по умолчанию на ветвь  (или
  версию) для большинства RCS-операций. Если там пусто, то по умолча-
  нию ветвью будет самая верхняя ветвь в цепочке.
       Все узлы delta, у которых номера состоят из 2n полей (n) (нап-
  ример,  3.1.1.1, 2.1.2.2 и т.п.) компонуются следующим образом. Все
  узлы,  у  которых первые 2n-1 поля номера - идентичны,  компонуются
  через поле next в порядке увеличения номеров. Для каждой такой пос-
  ледовательности   узел delta,   номер   которого  идентичен  первым
  2n-2 номерам полей delta в этой последовательности, называется точ-
  кой  ветвления.  Поле branches  узла содержит список номеров первых
  узлов всех последовательностей для которых он является точкой ветв-
  ления. Этот список упорядочен по возрастанию номеров.

       12.4.1. Пример
.
                               - 148 -

  ┌─────────────────────────────────────────────────────────────┐
  │                                                             │
  │            Head                                             │
  │                                                             │
  │            2.1                                              │
  │             │                                               │
  │            1.3 ──────── 1.3.1.1                             │
  │             │                                               │
  │      T      │    ┌───── 1.2.2.1 ─────────── 1.2.2.2         │
  │      r      │    │         │                                │
  │      u      │    │    1.2.2.1.1.1                           │
  │      n      │    │                                          │
  │      k      │    │                                          │
  │            1.2 ──┴───── 1.2.1.1 ─────────── 1.2.1.3         │
  │             │                                               │
  │             │                    Branch                     │
  │            1.1                                              │
  │                                                             │
  └─────────────────────────────────────────────────────────────┘

                               Рис. 24

       12.5. Команды RCS

       В следующую таблицу сведены все команды RCS.  Все эти  команды
  описаны в "Utilities Reference".

  ───────────────────────────────────────────────────────────────────
  Команда:        Описание:
  ───────────────────────────────────────────────────────────────────
  ci              сохранение версии в RCS
  со              извлечение версии из RCS
  ident           идентификация файлов
  rcs             изменение атрибутов RCS-файла
  rcsclean        очищение рабочих файлов
  rcsdiff         сравнение RCS-версий
  rcsmerge        объединение RCS-версий
  rlog            печать регистрационных сообщений и другой информации
                  о RCS-файлах
  ───────────────────────────────────────────────────────────────────
.
                               - 149 -


                     Глава 13 ИЗГОТОВЛЕНИЕ КОПИЙ

       В этой главе...

       Когда копировать
       Форматы копий
       Носители резервных копий
       Сжатие
       Примеры архивации

       13.1. Введение

       В этой  главе рассматривается резервное копирование Ваших дан-
  ных, необходимое для того, чтобы избежать их потери при сбоях аппа-
  ратных средств, программного обеспечения или ошибках оператора. Ес-
  ли Ваши данные важны для Вас,  Вам следует регулярно выполнять про-
  цедуры резервного копирования,  что позволит Вам восстановить поте-
  рянную информацию с минимальными затратами времени и денег.
       Запомните: жесткие  диски выходят из строя,  а люди ошибаются.
       Помните, что поздно начинать изготовлять копии после того, как
  Ваши  данные потеряны.
       Вы можете копировать целые файловые системы или  только  части
  их.  Пользователи  предпочитают  копировать  свои собственные файлы
  обычно на флоппи-дискеты.  Для того, чтобы копировать большие части
  файловой  системы  с файлами,  принадлежащими многим пользователям,
  Вам понадобится разрешение на чтение этих файлов. Суперпользователь
  (root) имеет такие привилегии.

       13.2. Когда копировать

       Вам следует  копировать  данные  так  часто,  чтобы можно было
  восстановить текущие данные или данные,  которые могут быть восста-
  новлены с минимальными затратами.  В группе разработки программного
  обеспечения частота копирования может изменяться в пределах от  дня
  до  недели.  Каждый день старения копии обычно будет стоить Вам дня
  работы.  Если Вы сохраняете финансовые или кассовые данные, необхо-
  димо копировать ежедневно или даже дважды в день.

       13.3. Форматы копий

       QNX поддерживает  целый ряд форматов резервных копий,  которые
  могут быть распределены на две группы: архивы и регулярные файловые
  системы.  Архив состоит из одного или более файлов,  объединенных в

                               - 150 -

  единый блок с собственным каталогом.  Архив может быть сохранен или
  в регулярном файле QNX,  или на неформатированном на блоки устройс-
  тве, подобно флоппи-дискете или ленте. Сохранение в регулярной фай-
  ловой системе заключается просто в копировании файлов.  В этом слу-
  чае результатом должно быть устройство с установленной на нем  фай-
  ловой системой.

       13.3.1. Архивные копии

       В QNX имеется три основные архивные утилиты:
       - cpio
       - tar
       - pax
       Как cpio,  так и tar связаны с pax, который может читать и за-
  писывать оба формата cpio и tar. Как cpio, так и tar - общие в сис-
  темах UNIX.
       Утилита pax включает как cpio,  так и tar,  таким образом, она
  не поддерживает собственный архивный формат.  По умолчанию, pax бу-
  дет использовать формат tar при создании архива.  Утилита pax опре-
  делит, когда Вы достигли конца носителя на томе, и подскажет, чтобы
  Вы вставили следующий том,  который нужно использовать для сохране-
  ния. В результате получается копия, распределенная на различных но-
  сителях (дискеты,  ленты и т.п.).
       К сожалению, формат tar/cpio не присваивает идентификаторы то-
  ма носителю. Если Вы перепутаете Ваш носитель или вставите его не в
  нужном порядке,  Вы восстановите не те данные.
       Для того,  чтобы исключить эту возможность, в QNX есть утилита
  vol,  которая метит каждый том последовательным номером и, следова-
  тельно, предотвращает установку носителей не в том порядке. Утилита
  vol будет,  по умолчанию,  устанавливаться на первый блок носителя.
  Это  важно  для флоппи-дискет и кассетных дисков,  которые содержат
  QNX-информацию в первом блоке.  Эта информация содержит размер дис-
  кеты  (360K,  1.2M  и т.п.) и обеспечивает автоматическую установку
  сменного носителя файловой системы.
       Quantum отправляет свои дистрибутивные дискеты,  используя pax
  для создания архива,  freeze - для сжатия данных и vol - для записи
  на флоппи-дискеты.

       ВНИМАНИЕ. Если Вы хотите сохранить данные для их  последующего
                 восстановления в UNIX-системе, не используйте freeze
                 или vol, т.к. Вы не найдете там утилиты, которые вы-
                 полнят  восстановление.  Вместо  них используйте pax
                 для сохранения и восстановления  непосредственно  на
                 носителе.

                               - 151 -

       13.3.2. Копии файловой системы

       Существует возможность сохранения файловой системы посредством
  копирования файлов утилитами cp или cpio -p. Если Ваш носитель рас-
  положен  на  флоппи-дискете,  утилита cp подскажет Вам об установке
  следующей дискеты, но помните, что никакой файл не может быть боль-
  ше  размера  дискеты.  Если  Вы  хотите поддерживать копии на флоп-
  пи-дискете,  мы рекомендуем Вам пользоваться одной из архивных ути-
  лит.

       13.4. Носители резервных копий

       Ваш выбор  носителя резервных копий будет определяться доступ-
  ным аппаратным обеспечением и его стоимостью.  Есть четыре  возмож-
  ности выбора:
       - флоппи-дискета;
       - лента;
       - сменный диск;
       - фиксированный диск.

       13.4.1. Флоппи-дискета

       Флоппи-дискеты - наиболее распространенное устройство для  ре-
  зервных копий. Их основной недостаток - ограниченный размер. Т.к. в
  QNX утилиты pax и vol позволяют  распределить  носитель,  Вам  надо
  только  обеспечить  установку различных флоппи-дискет в накопитель.
       Если Вы имеете дело с более чем четырьмя или пятью флоппи-дис-
  кетами,  то процедура копирования станет достаточно неприятной, что
  влечет за собой уменьшение частоты копирования. Вы можете использо-
  вать сжатие Ваших данных,  как указано ниже.
       Для того,  чтобы скопировать/восстановить с флоппи-дискеты, Вы
  должны убедиться, что запущен драйвер флоппи-дискеты. Эта процедура
  описывается в разделе Fsys.floppy в "Utilities Reference".  Следую-
  щая командная строка запустит драйвер (предполагается, что Fsys уже
  выполняется),  который затем создаст блочный специальный  файл  для
  каждой флоппи-дискеты.

  Командная строка    Блочный специальный файл

  Fsys.floppy         /dev/fd0        (накопитель А на гибких дисках)
                      /dev/fd1        (накопитель В на гибких дисках)

       При использовании архивной утилиты для работы с копиями чтение
  и запись происходит непосредственно на флоппи-дискету блочного спе-

                               - 152 -

  циального файла.  Если Вы предпочитаете использовать утилиту cp, Вы
  должны смонтировать файловую систему на  блочном  специальном  уст-
  ройстве. Например:

                  mount /dev/fd0 /fd0

       Не забывайте  отформатировать  и  инициализировать новые флоп-
  пи-дискеты. В следующем примере показано, как отформатировать флоп-
  пи-дискету 5 1/4" на 1 Мб":

                  fdformat -s 1.2m /dev/fd0
                  dinit /dev/fd0

       Теперь Вы можете рассматривать  флоппи-дискету,  как  файловую
  систему QNX, смонтированную, как /fd0.

       13.4.2. Лента

       В QNX   имеется  драйвер,  поддерживающий  интерфейс  стандар-
  та QIC-02.  Он обеспечивает работу со стандартной кассетой  с  лен-
  той 1/4 дюйма,  которая может содержать от 60 до 300 мегабайтов данных.
  Для того,  чтобы скопировать/восстановить информацию  с  ленты,  Вы
  должны убедиться, что драйвер ленты запущен. Эта процедура описыва-
  ется в разделе Fsys.qic02 в "Utilities  Reference".  Следующая  ко-
  мандная  строка  запускает  драйвер,  который затем создает блочный
  специальный файл для ленты:

       Командная строка        Блочный специальный файл

       Fsys.qic02              /dev/tp0

       Архивные утилиты выполняют чтение и запись  непосредственно  в
  ленточный блочный специальный файл. Вы не сможете смонтировать фай-
  ловую систему на этом типе блочного специального файла. Когда драй-
  вер QIC-02 получает запрос на чтение или запись, он начинает выпол-
  нять операцию с текущей позиции на ленте.
       Если Вы создаете новую копию, Вам необходимо стереть и перемо-
  тать ленту.  Различные функции управления лентой выполняет  утилита
  tape,  которая описана в "Utilities Reference".
       Например, следующая команда выполнит стирание,  а затем  пере-
  мотку ленты, при подготовке к процедуре архивизации:

                  tape erase


                               - 153 -

       13.4.3. Сменный диск

       Сменные жесткие диски бывают как магнитного, так и оптического
  типа. Оптические диски содержат больше данных, но они работают мед-
  леннее.  Большинство  устройств используют интерфейс SCSI,  поэтому
  целесообразно сделать Ваш внутренний фиксированный  диск  накопите-
  лем SCSI.  В  отличие  от флоппи-дискет и лент сменный жесткий диск
  позволяет Вам избежать использования архивных утилит,  подобно pax.
       Вместо этого, Вы вероятно будете использовать cp, чтобы скопи-
  ровать Ваши данные в реальную файловую систему на кассете. Это поз-
  волит Вам очень легко и быстро восстанавливать отдельные файлы.

       13.4.4. Фиксированный диск

       Вы можете установить второй жесткий диск в Вашей машине или Вы
  можете копировать на жесткий диск другой машины в  сети.  Это  даст
  Вам  возможность  выполнять  резервное копирование в режиме online.
  Однако, все же лучше хранить информацию вне вычислительного центра.

       13.5. Сжатие

       Вы можете использовать утилиту сжатия,  чтобы уменьшить память
  для  хранения  данных.  Степень  сжатия будет зависеть от характера
  данных,  которые Вы сохраняете.  Некоторые базы данных,  содержащие
  большое количество  повторяемых  данных,  могут  быть сжаты до 9 90%.
   9Дру 0гие данные могут быть сжаты менее, чем на 10%. Хотя сжатие может
  экономить  пространство  носителя,  но  существует две особенности:
       1. Сжатие требует больших вычислений и может замедлить процесс
  сохранения  данных.
       2. Вы не сможете восстановить сжатые данные в случае возникно-
  вения сбоя при их создании,  как например,  появление плохого блока
  на резервном носителе.  Потенциально,  все данные,  соответствующие
  плохому блоку,  могут быть потеряны.  При сравнении несжатые данные
  будут просто иметь "дыру" в середине.

       Вы можете использовать утилиту freeze, чтобы сжать Ваши данные
  и утилиту melt, чтобы восстановить их. Обе эти утилиты работают как
  с потоком данных,  так и с файлами.  Эта способность работать,  как
  фильтр, позволяет Вам присоединять их к одному из стандартных архи-
  ваторов через канал.  Например, Quantum распространяет операционную
  систему QNX в сжатой форме на флоппи-дискетах, используя pax, free-
  ze и vol.

       13.6. Примеры архивации

                               - 154 -

       13.6.1. Сжатие флоппи-архива

       Собрать файлы в каталоге /home в архивном формате tar,  произ-
  вести  сжатие архива и записать его на такое количество флоппи-дис-
  кет, какое необходимо, проставляя последовательные номера на диске-
  ты, можно, используя следующие команды:

                  pax -w -x ustar /home | freeze | vol -w /dev/fd0

       Прочитать данные  с  флоппи-дискет,  распаковать их в архиве и
  восстановить файлы можно:

                  vol -r /dev/fd0 | melt | pax -r

       13.6.2. UNIX-совместимый флоппи-архив

       Сохранить файлы из /home/brianc в архиве формата tar для восс-
  тановления их в UNIX-системе можно, используя следующие команды:

                  pax -w -t/dev/tp0 -xustar /home/brianc

       Сохранить файлы  из  /home/brianc  в  архиве  формата cpio для
  восстановления их в UNIX-системе:

                  pax -w -xcpio -t/dev/tp0 /home/brianc

       Восстановить данные из  архива  формата tar  или  cpio  другой
  UNIX-системы и разместить все файлы в /usr/unix:

                  pax -r -s -t/dev/fd0 ",/,/usr/unix/,"

       13.6.3. Архив на ленте

       Начать архив  на  новой  ленте  и сохранить все файлы на ленте
  QIC-02 можно, используя следующие команды:

                  tape erase
                  pax -w -t/dev/tp0 /

       Добавить файлы,  которые изменились позднее даты, хранящейся в
  файле lastsave, в конец существующей архивной ленты. После сохране-
  ния, скорректировать время последней записи в файле lastsave:

                  tape forward

                               - 155 -

                  find / -newer lastsave | pax -w -t/dev/tp0
                  touch lastsave

       Восстановить с ленты все файлы,  которые находятся в  каталоге
  /home/robo:

                  tape rewind
                  pax -r "/home/robo/*" -t/dev/fd0

       13.6.4. Оптические диски

       Скопировать все файлы из файловой системы на узле 1 в файловую
  систему на узле 2:

                  cp -Rp //1/ //2/

  В следующем примере диск на узле 2 - оптический,  очень большой ем-
  кости.  Полное копирование производится каждую пятницу и  частичное
  копирование модифицируемых файлов может выполняться каждый день:

                  cp -Rp //1/ //2/fri
                  cp -Rp -a data //1/ //2/mon
                  cp -Rp -a data //1/ //2/tue
                  .
                  .
                  .
        Вы можете также сделать это, используя cpio -p.

.
                               - 156 -

              Глава 14. ВОССТАНОВЛЕНИЕ ДИСКОВ И ФАЙЛОВ

       В этой главе...

       Обзор структуры диска QNX 4
       Утилиты работы с файлами
       Процедуры восстановления диска
       Что делать, если Ваша система больше не загружается
       Восстановление потерянных файлов и каталогов

       ВНИМАНИЕ. Мы рекомендуем Вам прочитать эту главу полностью на
       случай, если Вам когда-либо придется выполнять процедуры
       восстановления диска.

       14.1. Введение

       Файловая система QNX имеет высокую производительность и надеж-
  ность. Хотя файловая система разрабатывалась в соответствии с прин-
  ципом обеспечения максимальной живучести, тем не менее, на практике
  всегда могут возникнуть ситуации отказа диска.
       Например, могут выйти из строя аппаратные средства,  произойти
  сбой по питанию или пользователи могут  перезагрузить  компьютер  в
  самый неподходящий момент.
       Файловая система QNX спроектирована так, что может устоять при
  возникновении подобных ситуаций. Она базируется на принципе обеспе-
  чения целостности и непротиворечивости файловой системы в  целом  в
  любой  момент времени,  т.е.  любой единичный отказ в худшем случае
  может испортить содержимое только тех файлов,  которые открыты  для
  записи на момент возникновения отказа.
       Это означает, что наиболее распространенные типы отказов: сбои
  по питанию,  перезагрузка, отказ ЦП,- не разрушают файловую систему
  QNX.
       Если возникает  нарушение,  мы используем утилиты восстановле-
  ния,  которые позволяют проверить файловую систему,  чтобы  опреде-
  лить, имеются ли повреждения файлов, которые были открыты на запись
  в момент возникновения нарушения.  Эти же утилиты  могут  исправить
  такие повреждения и во многих случаях полностью восстановить файло-
  вую систему.
       Иногда повреждения могут быть более серьезными.  Например,  на
  жестком диске может появиться плохой блок в середине файла или  еще
  хуже - в середине каталога или некоторого другого критического бло-
  ка.  Утилиты помогают определить степень такого повреждения.  Может
  потребоваться вновь создать файловую систему,  чтобы избежать появ-
  ления поврежденных областей.  В этом случае некоторые данные  будут

                               - 157 -

  потеряны,  но большая часть активных данных может быть восстановле-
  на.

       14.2. Обзор структуры диска QNX 4

       В этом разделе рассматривается организация данных на  диске  в
  файловой системе QNX.  Это поможет Вам определять и, возможно, кор-
  ректировать повреждения файловой системы при ее восстановлении. Ес-
  ли  у  Вас  есть  пакет  разработки  Cи,  то  в  заголовочном файле
  <sys/fsys.h> содержатся определения всех терминов, использованных в
  этом  разделе.  Полное  описание  файловой системы QNX содержится в
  "Архитектуре системы" в главе 5 "Администратор файловой системы".

       14.2.1. Структура раздела

       Файловая система QNX может занимать целый диск (в случае флоп-
  пидискет) или один из разделов жесткого диска. В пределах дискового
  раздела, файловая система QNX содержит следующие компоненты:

          +-----------------------------------------------------+
          |                                                     |
          |          +------------------------+                 |
          |          |  Программа-загрузчик   |                 |
          |          |------------------------|                 |
          |          |  Корневой блок         |-----+           |
          |          |------------------------|     |           |
          |          |-                      -|     |           |
          |          |  Битовая карта         |     |           |
          |          |-                      -|     |           |
          |          |------------------------|     |           |
          |          |-                      -|     |           |
          |          |  Корневой каталог      |<----+           |
          |          |-                      -|                 |
          |          |------------------------|                 |
          |          ~                        ~                 |
          |          |  Другие данные         |                 |
          |          ~                        ~                 |
          |          +------------------------+                 |
          +-----------------------------------------------------+

                                Рис. 25

       В дисковом разделе QNX 4 cледующие блоки всегда находятся в
  следующем порядке:

                               - 158 -

       1) блок программы-загрузчика;
       2) корневой блок;
       3) блоки битовой карты;
       4) корневой каталог.

       Блок программы-загрузчика

       Первый блок раздела QNX - блок программы-загрузчика - содержит
  начальный загрузчик, который загружает ОС QNX в память.

       Корневой блок

       Второй блок  раздела  QNX  - корневой блок - содержит вход для
  корневого каталога (/), inode-входы для файла inode и поле метки.

       Блоки битовой карты

       За корневым блоком следует несколько блоков битовой карты. Они
  образуют  битовую карту для раздела QNX.  Для каждого блока раздела
  существует один бит,  таким образом один блок битовой  карты  будет
  использоваться  для  4096  дисковых  блоков (что соответствует 2 Mб
  дискового пространства).  Если значение бита нулевое,  то соответс-
  твующий ему блок не используется.  Неиспользуемые биты в конце пос-
  леднего блока битовой карты (для которых нет соответствия  дисковым
  блокам)  имеют  единичное  значение.  Присвоение битов начинается с
  младшего бита байта 0 первого блока битовой  карты,  который  соот-
  ветствует в QNX блоку 1.

       Корневой каталог

       Корневой каталог  следует  за блоками битовой карты.  Корневой
  каталог является "нормальным" каталогом (смотрите "Каталоги"  ниже)
  и изначально создается утилитой dinit с объемом, достаточным для 32
  элементов каталога (4 блока).  Как показано на следующей  иллюстра-
  ции, корневой каталог (/) содержит элементы каталогов для различных
  специальных файлов,  которые всегда существуют в  файловой  системе
  QNX. Утилита dinit создает эти файлы, когда файловая система иници-
  ализируется первый раз.
.
                               - 159 -

  +------------------------------------------------------------------+
  |       /                                                          |
  |   +-------+                                                      |
  |   |       |               +---------------------------------+    |
  |   |   ----+-------------->| .                               |    |
  |   |       |               +---------------------------------+    |
  |   |-------|                                                      |
  |   |       |               +---------------------------------+    |
  |   |   ----+-------------->| ..                              |    |
  |   |       |               +---------------------------------+    |
  |   |-------|                                                      |
  |   |       |               +---------------------------------+    |
  |   |   ----+-------------->| .bitmap                         |    |
  |   |       |               +---------------------------------+    |
  |   |-------|                                                      |
  |   |       |               +---------------------------------+    |
  |   |   ----+-------------->| .inodes                         |    |
  |   |       |               +---------------------------------+    |
  |   |-------|                                                      |
  |   |       |               +---------------------------------+    |
  |   |   ----+-------------->| .boot                           |    |
  |   |       |               +---------------------------------+    |
  |   |-------|                                                      |
  |   |       |               +---------------------------------+    |
  |   |   ----+-------------->| .altboot                        |    |
  |   |       |               +---------------------------------+    |
  |   |-------|                                                      |
  |   |       |                                                      |
  |   |       |                                                      |
  |     . . .                                                        |
  +------------------------------------------------------------------+

                                Рис. 26

       На рис. 26 приняты следующие обозначения:
       /.        Ссылка на каталог: /

       /..       Также ссылка на каталог: /

       /.bitmap  Файл,  открываемый  только  на  чтение,  состоящий из
                 блоков битовой карты.

       /.inodes  Нормальный файл, занимающий по крайней мере один блок
                 на флоппи/RAM  дискете и 16 блоков на других дисках,

                               - 160 -

                 /.inodes - это набор inodeэлементов.  Первый элемент
                 резервируется и используется в качестве области сиг-
                 натуры/инфо.  Первые  байты  .inode-файла  -  "IamT-
                 HE.inodeFILE".

       /.boot   Файл  образа  ОС,  который будет загружаться в память
                при стандартной загрузке.  Этот  файл  имеет  нулевую
                длину, если файла загрузки не существует.

       /.altboot   Файл образа ОС, который будет загружаться в память
                   при альтернативной загрузке. Этот файл имеет нуле-
                   вую  длину,  если файла альтернативной загрузки не
                   существует.

       14.2.2. Каталоги

       Каталог - это просто файл,  который имеет специальное значение
  в файловой системе. Этот файл содержит набор строк, структура кото-
  рых показана на следующем рисунке:

  +------------------------------------------------------------------+
  |                                                                  |
  |                                   Смещение                       |
  |                               +----       +------------------+   |
  |                               |       0   | di_fname[16]     |   |
  |                               |      16   | d_size[4]        |   |
  |                               |      20   | di_first_xtnt[8] |   |
  |                               |      28   | di_xblk[4]       |   |
  |   один физический             |      32   | di_ftime[4]      |   |
  |   блок каталога               |      36   | di_mtime[4]      |   |
  |                               |      40   | di_atime[4]      |   |
  |   +-------------+             |      44   | di_ctime[4]      |   |
  |   |      0      |-------------|      48   | di_num_xtnts[2]  |   |
  |   |-------------|             |      50   | di_mode[2]       |   |
  |   |      1      |             |      52   | di_uid[2]        |   |
  |   |-------------|             |      54   | di_gid[2]        |   |
  |   |      2      |             |      56   | di_nlink[2]      |   |
  |   |-------------|             |      58   | di_zero[4]       |   |
  |   |      3      |             |      62   | di_type[1]       |   |
  |   |-------------|             |      63   | d_status[1]      |   |
  |   |      4      |             +---        +------------------+   |
  |   |-------------|                                                |
  |   |      5      |                                                |
  |   |-------------|                                                |

                               - 161 -

  |   |      6      |                                                |
  |   |-------------|                                                |
  |   |      7      |                                                |
  |   |-------------|                                                |
  |   |             |                                                |
  |                                                                  |
  +------------------------------------------------------------------+

                                Рис. 27

       Тип cтроки каталога определяется  битами  в  области  d_status
  следующим образом:

  -------------------------------------------------------------------
  Bit 3 (FILE_LINK)  Bit 0 (FILE_USED)        Комментарий
  -------------------------------------------------------------------
      0                  0              неиспользованная строка
                                        каталога

      0                  1              нормальная, используемая
                                        строка каталога

      1                  X              ссылка на строку в /.inodes
                                        (которая может использовать-
                                        ся или не использоваться)
  -------------------------------------------------------------------

       Первая строка каталога всегда принадлежит файлу "." и включает
  сигнатуру каталога ("IQNX").  Эта строка ссылается на  собственный
  каталог, указывая на строку в родительском каталоге, которая описы-
  вает этот каталог.
       Второй элемент  -  всегда  принадлежит файлу "..".  Эта строка
  ссылается на родительский каталог,  указывая на  его  первый  блок.
  Каждая строка каталога или определяет файл, или ссылается на строку
  файла /.inodes. Inode-строки используются, когда имя файла превыша-
  ет 16 символов или когда один файл имеет два или более имени.
       Первый экстент файла (если их несколько) описывается в  строке
  каталога  или  /inode-файла.  Дополнительные экстенты файла требуют
  цепной список блоков экстентов,  начало которого также находится  в
  строке каталога или /inode-файле.  Каждый блок экстентов в цепи оп-
  ределяет от 1 до 60 экстентов.

       14.2.3. Связи


                               - 162 -

       Файлы с именами, имеющими более 16 символов, и связи с другими
  файлами реализованы специальной формой строки каталога.  Эти строки
  определяются битом _FILE_LINK (0x08) поля d_status.
       Для этих файлов часть  строки  каталога  перемещается  в  файл
  /.inodes.

  +------------------------------------------------------------------+
  |                                                                  |
  |                                                                  |
  |    Строка каталога                    Строка файла /.inodes      |
  |    +------------+                                                |
  |  0 |di_fname[48]|                      +--------------+          |
  | 48 |di_inode_blk|----------------->  0 |i_reserved[16]|          |
  | 52 |di_inode_ndx|--+                16 |i_size        |          |
  | 53 |di_spare[10]|                   20 |i_first_xtnt  |          |
  | 63 |d_status    |                   28 |i_xblk        |          |
  |    +------------+                   32 |i_ftime       |          |
  |                                     36 |i_mtime       |          |
  |                                     40 |i_atime       |          |
  |                                     44 |i_ctime       |          |
  |                                     48 |i_num_xtnts   |          |
  |                                     50 |i_mode        |          |
  |                                     52 |i_uid         |          |
  |                                     54 |i_gid         |          |
  |                                     56 |i_nlink       |          |
  |                                     58 |i_zero        |          |
  |                                     62 |i_type        |          |
  |                                     63 |i_status      |          |
  |                                        +--------------+          |
  |                                                                  |
  |                                                                  |
  +------------------------------------------------------------------+

                                  Рис. 28

       14.2.4. Блоки экстентов

       Блоки эстентов используются для любого  файла,  который  имеет
  более одного экстента.  Строка каталога di_xblk указывает на первый
  блок экстентов,  который в свою очередь определяет,  где  находятся
  второй и последующие экстенты.
       Блок экстентов соответствует одному дисковому блоку в 512 байт
  и имеет следующий формат:


                               - 163 -


  +------------------------------------------------------------------+
  |                                                                  |
  |          +--------------------------------------------+          |
  |       0  |             xblk_next_xblk[4]              |          |
  |          |--------------------------------------------|          |
  |       4  |             xblk_prev_xblk[4]              |          |
  |          |--------------------------------------------|          |
  |       8  |             xblk_num_xtnts[4]              |          |
  |          |--------------------------------------------|          |
  |       9  |             xblk_spare[3]                  |          |
  |          |--------------------------------------------|          |
  |      12  |             xblk_num_blocks[4]             |          |
  |          +--------------------------------------------+          |
  |                                                                  |
  |          +--------------------------------------------+          |
  |      16  |             xblk_xtnts[0]                  |          |
  |          |--------------------------------------------|          |
  |      24  |             xblk_xtnts[1]                  |          |
  |          |--------------------------------------------|          |
  |                              . . .                               |
  |          |--------------------------------------------|          |
  |     488  |             xblk_xtnts[59]                 |          |
  |          +--------------------------------------------+          |
  |                                                                  |
  |          +--------------------------------------------+          |
  |     496  |             xblk_signature[8]              | "IamXblk"|
  |          |--------------------------------------------| (только  |
  |     504  |             xblk_first_xtnt[8]             | 1-й блок |
  |          +--------------------------------------------+ экстента)|
  |                                                                  |
  +------------------------------------------------------------------+

                              Рис. 29

       Каждый блок экстентов содержит:
       - прямые/обратные указатели;
       - количество экстентов;
       - количество всех блоков во всех экстентах,  определяемых этим
  блоком  экстента;
       - указатели и количество блоков для каждого экстента;
       - сигнатура ("IamXblk").
       Первый блок экстентов также содержит  резервный  указатель  на
  первый  экстент  файла  (который описан еще и в строке каталога или

                               - 164 -

  /inodeфайла).  Это позволит Вам восстановить все  данные  в  файле,
  располагая только этим блоком.

     14.2.5. Файлы
     Файлы  или файловые  экстенты -  это  группы  блоков,  описываемые
  строками  каталогов и  /inode-файлов; у  них нет  жесткой структуры в
  файловой системе QNX.
     Большинство файлов в QNX 4 имеет следующую общую структуру:
  +------------------------------------------------------------------+
  |                         Корень                                   |
  |                        +-----+                                   |
  |                        +-----+                                   |
  |                   +-------+                                      |
  |               +---------------- ------------                    |
  |            /  |  .    |  . .  |   |  dir   |                     |
  |               +----------------- ------------                    |
  |                   +-------------------+                          |
  |               +---------------- ------------                    |
  |          dir  |  .    |  . .  |   |  file  |                     |
  |               +----------------- ------------                    |
  |   +---------------------------------+   |                        |
  |   |              +----------------------+                        |
  |   |            +---+      +----+      +----+                    |
  |   |            | ---+----->|  --+-...->|  0 |                    |
  |   |            |----|      |----|      |----|                    |
  |   |            |  0 |<-----+--  |<-...-+--  |  Блоки             |
  |   |            |----|      |----|      |----| экстентов          |
  |   |          +-| #2 |      |#62 |      |    |                    |
  |   |          | |----|      |----|      |----|                    |
  |   |          | | #3 |--+   |#63 |      |    |                    |
  |   |          | |----|  |   |----|      |----|                    |
  |   |          |         |                                         |
  |   |          | |----|  |   |----|      |----|                    |
  |   |          | |#61 |  |   |    |     +| #n |                    |
  |   |          | |----|  |   |----|     ||----|                    |
  |   |<---------+-|    |  |   |  0 |     ||  0 |                    |
  |   |          | +----+  |   +----+     |+----+                    |
  |   |          |         +-+            |                          |
  |   |          |           |            +--+                       |
  |   |          |           |               |                       |
  |  +--- ---+ +---- ---+ +---- ---+ ... +---- ---+              |
  |  +---- ---+ +----- ---+ +----- ---+     +----- ---+              |
  |   экстент 1  экстент 2   экстент 3       экстент n               |
  +------------------------------------------------------------------+

                               - 165 -

     Сигнатуры:
     IQNX    - "точка" входа каждого каталога,
     IamXblk  - заголовок каждого блока экстентов.

                              Рис. 30

       14.3. Утилиты работы с файлами

       Следующие утилиты позволяют Вам создавать и поддерживать  дис-
  ковую/файловую структуру:
       - fdisk
       - dinit
       - chkfsys
       - zap
       - spatch


       14.3.1. Утилита fdisk

       Утилита fdisk  создает  и поддерживает блок раздела на жестком
  диске.  Этот блок совместим с другими операционными системами и мо-
  жет быть поддержан версиями fdisk других ОС (хотя наш имеет преиму-
  щество при распознавании QNX-специфической информации).  Если  заг-
  рузчик раздела отсутствует или поврежден,  fdisk может создать его.

       ВНИМАНИЕ. Мы  рекомендуем  Вам  сохранять  распечатку  таблицы
                 распределения раздела для каждого диска Вашей сети.

       14.3.2. Утилита dinit

       Утилита dinit создает (но Fsys поддерживает) следующее:
       - блок загрузки;
       - корневой блок;
       - блоки битовой карты;
       - корневой каталог;
       - inode-файл (/.inodes)

       14.3.3. Утилита chkfsys

       Утилита chkfsys  -  основное  средство  сопровождения файловой
  системы. Эта утилита:
       - проверяет структуру каталога всего раздела диска, сообщает о
  любой несовместимости и фиксирует ее, если возможно;
       - проверяет все блочное распределение диска;

                               - 166 -

       - записывает новый файл /.bitmap при Вашем согласии.
       Утилита chkfsys работает при условии, что корневой блок не на-
рушен.
       Если корневой блок нарушен,  то утилита chkfsys сообщит Вам об
  этом, чтобы Вы попытались восстановить его утилитой dinit.

       14.3.4. Утилита zap

       Утилита zap удаляет файлы или каталоги из файловой системы, не
  возвращая используемые блоки в свободный список.  Вам это может по-
  надобиться по различным причинам:
       - повреждение строки каталога;
       - два файла занимают одно и то же пространство на диске  (оши-
  бочно).
       Для того,  чтобы удалить затертые файловые данные и  восстано-
  вить используемые дисковые блоки, используйте утилиту chkfsys.

       14.3.5. Утилита spatch

       Утилита spatch  просматривает  диск с искаженной информацией и
  устраняет некоторые проблемы.  С помощью этой утилиты можно считать
  и перезаписать ошибочные блоки.

       14.4. Процедуры восстановления диска

       14.4.1. Использование утилиты chkfsys

       Утилита chkfsys  - это главное средство для проверки и восста-
  новления поврежденной файловой системы.  С ее помощью можно опреде-
  лить и исправить некоторые нарушения, а также проверить целостность
  дисковой системы в целом.
       Обычно для  утилиты chkfsys требуется,  чтобы файловая система
  была не задействована и чтобы не было файлов,  открытых  на  данном
  устройстве.
       Вы должны завершить все процессы,  которые открыли  файлы  или
  могут их открыть, пока выполняется chkfsys.
       Чтобы выполнить chkfsys для файловой системы /dev/hd0t77, сле-
  дует ввести команду:

          chkfsys /dev/hd0t77

       Утилита просматривает весь дисковый раздел от корня вниз, соз-
  давая внутреннюю копию битовой  карты  и  проверяя  согласованность
  всех файлов и каталогов, которые она обнаруживает. После завершения

                               - 167 -

  обработки всех файлов chkfsys сравнит внутреннюю  битовую  карту  с
  битовой картой на диске.  Если они совпадают, то chkfsys завершает-
  ся.
       При обнаружении  несоответствия,  утилита chkfsys перепишет (с
  Вашего согласия) битовую карту с данными о файлах,  которые она об-
  наружила  и  проверила  на противоречивость.
       Кроме того,  проверяя блочное распределение  (битовую  карту),
  chkfsys пытается фиксировать любые проблемы,  обнаруженные при ска-
  нировании.
       Например,  chkfsys может:
       - установить признак "unbusy" файлам, которые записывались при
  возникновении  сбоя;
       - установить размер файла в строке каталога, который соответс-
  твует реальным данным.

       Когда выполнять утилиту chkfsys

       Утилиту chkfsys рекомендуется выполнять,  как часть регулярных
  плановых процедур сопровождения - это позволит  Вам  проверять  це-
  лостность  данных на диске.
       Особенно важно выполнить chkfsys после системного отказа, что-
  бы  определить поврежденные файлы.
       Если Вы затрете некоторые файлы (zap) по некоторой причине Вам
  необходимо  выполнить  chkfsys для восстановления потерянных блоков
  на диске.

       Использование утилиты chkfsys в работающей системе

       Если Вы выполняете приложение, которое не может прерваться, Вы
  не можете прекратить работу системы,  чтобы выполнить chkfsys.  Для
  того, чтобы обеспечить проверку диска chkfsys, обычно требуется мо-
  нопольное  использование файловой системы.  Но Вы можете определить
  возможные проблемы в работающей системе,  используя специальный ре-
  жим chkfsys - "только-чтение":

          chkfsys -f /dev/hd0t77

       В режиме "-f" нельзя корректировать данные, но он дает Вам ин-
  формацию о состоянии файловой системы.  Если обнаруживаются серьез-
  ные проблемы, то это немедленно фиксируется, при этом Вы можете ис-
  пользовать другой специальный режим - "Rambo":

          chkfsys -R /dev/hd0t77


                               - 168 -

        3Запомните: 0 Вы можете использовать режим "Rambo" только при ус-
  ловии, что:
       - активные файлы сейчас не открыты;
       - активные файлы не будут открываться в течение процесса пере-
  записи;
       - любые  открытые в данное время файлы не увеличатся в течение
  этого процесса.

       Использование режима "Rambo" фиксирует большинство ошибок, но,
  т.к. Вы проверяете диск с работающей файловой системой и с открыты-
  ми  файлами,  утилита chkfsys не будет:
       - пытаться восстанавливать блоки битовой  карты;
       - проверять ошибки распределения блоков;
       - пытаться вновь создавать файл /.inodes.

       ВНИМАНИЕ. Риск запуска chkfsys в работающей системе заключает-
                 ся  в  том,  что chkfsys и файловая система читают и
                 возможно записывают на диск одни и те же блоки. Кро-
                 ме этого, файловая система имеет внутренние кеш-дан-
                 ные о файлах и  каталогах,  которые  не  могут  быть
                 скорректированы, при работе chkfsys. Статические из-
                 менения в файлах или каталогах, которые в данный мо-
                 мент не открыты, вероятно не вызовут проблем.

       14.4.2. Восстановление удаленных файлов

       Если файл  случайно удален,  то иногда его можно восстановить,
  используя утилиту zap.
       Для восстановления файла c помощью zap должны выполняться сле-
  дующие условия:
       - строка  каталога для этого (удаленного) файла не должна быть
  занята другим файлом;
       - дисковые блоки,  прежде используемые файлом,  не должны быть
  переназначены другому файлу.
       Таким образом,  если  Вы  действуете достаточно быстро или Вам
  повезет, есть шанс, что следующей командой можно восстановить файл:

          zap -u directory

       14.4.3. Восстановление плохого блока в середине файла

       На жестких дисках со временем могут появляться плохие блоки. В
  некоторых случаях  Вы  могли бы восстановить большую часть или даже
  все данные файла,  содержащего плохой блок.

                               - 169 -

       Некоторые плохие  блоки  являются результатом сбоев по питанию
  или низкого качества носителя жесткого диска. В этих случаях просто
  чтение и затем перезапись блока восстановит блок на короткий период
  времени.  Это позволит Вам скопировать целый файл куда-нибудь  еще,
  прежде  чем  блок  испортится снова.
       Эта процедура безболезненна и часто стоит того,  чтобы ее  вы-
  полнить.
       Для того,  чтобы проверить блоки файла, Вы используете утилиту
  spatch.  При  чтении плохого блока spatch сообщает об ошибке,  но в
  действительности,  возможно,  была прочитана часть "хороших" байтов
  из этого блока.  Запись того же блока обратно часто достигнет цели.
       В то же время,  spatch перезапишет правильный CRC (Циклический
  контроль),  это сделает блок хорошим (но, возможно, с неправильными
  данными).
       Вы можете  затем скопировать весь файл куда-нибудь еще и затем
  стереть поврежденный файл. Для того, чтобы завершить процедуру, не-
  обходимо  пометить  такой  блок,  как  плохой  (добавить его в файл
  /.bad_blks),  затем восстановить остальные хорошие блоки, используя
  утилиту  chkfsys.
       Если эти процедуры не помогут,  то Вы можете использовать ути-
  литу spatch, чтобы скопировать по возможности большую часть файла в
  другой файл, затем затереть плохой файл и выполнить chkfsys.

       14.5. Что делать, если Ваша система больше не загружается

       Если функционирующая система QNX внезапно прекратила работу  и
  больше не загружается, то, возможно, произошло следующее:
       - отказали аппаратные средства или были повреждены  данные  на
  жестком диске;
       - кто-то изменил/переписал файл загрузки или изменил файл сис-
  темной инициализации - это два наиболее типичных случая.
       Следующие шаги могут помочь Вам локализовать проблему.

       14.5.1. Рекомендуемые действия

       Шаг 1. Попытайтесь загрузиться с флоппи-дискеты или через сеть

       Если у Вас есть сеть...

       Если у Вас есть сеть,  попытайтесь загрузить Вашу машину через
  сеть.  Если машина загрузится, Вам следует войти в систему, как ro-
  ot, и затем запустить локальный Администратор файловой системы:

          Fsys &

                               - 170 -


       Если у Вас нет сети...

       Если Вы не имеете доступа к сети QNX, то попытайтесь загрузить
  QNX с флоппи-дискеты,  которая использовалась для установки системы
  на жесткий диск.  В этом случае файловая  система  будет  доступна.
  Имейте в виду, что Вам нужно войти в систему, как root.

       Шаг 2. Запустите драйвер жесткого диска

       Теперь нужно запустить подходящий драйвер жесткого диска.
       Например, для того,  чтобы работать с диском,  подключенным  к
  стандартному контроллеру, совместимому с Western Digital введите:

          Fsys.wd &

       Эта команда  должна создать блочный специальный файл /dev/hd0,
  который представляет весь жесткий диск.

       Шаг 3. Выполните утилиту fdisk

       Утилита fdisk немедленно даст Вам полезную информацию о состо-
  янии жесткого диска.  Утилита fdisk может локализовать одну из сле-
  дующих проблем:

       Ошибка чтения первого блока

       Вероятная причина. Если  fdisk сообщает об ошибке при чтении блока
  раздела  (который является первым физическим блоком на диске), то это
  говорит об отказе дискового контроллера или жесткого диска.

       Действия.
       Если диск исправен,  то, заменив плату контроллера, можно про-
  должить использовать диск.  В противном случае,  Вы должны заменить
  жесткий диск,  вновь установить QNX и восстановить Ваши файлы с ко-
  пии.

       Неправильные дисковые параметры

       Вероятная причина.  Если fdisk успешно считает первый блок, но
  сообщит  о  неправильных  дисковых параметрах (#heads,  #cylinders,
  #sectors/cylinder), то это указывает на то, что аппаратные средства
  вероятно "потеряли" информацию об этом жестком диске.  Наиболее ве-
  роятная причина в том,  что разрядилась батарея памяти CMOS.

                               - 171 -


       Действия.
       Перезапустите процедуру аппаратной установки setup (или проце-
  дуру выбора программируемых опций на PS/2). Конечно, замена батареи
  более надежна.

       Информация о плохом разделе

       Вероятная причина.  Если  дисковый  размер правильно определен
  утилитой fdisk, но информация о разделе некорректна, то это означа-
  ет,  что  данные  в первом блоке физического диска были повреждены.

     Действия.
     Используйте fdisk,  чтобы вновь создать правильную информацию  о
  разделе.  Рекомендуется регистрировать или распечатывать правильную
  информации о разделе на случай, если Вам когда-либо придется выпол-
  нять этот шаг.

       Шаг 4. Смонтируйте раздел, как блочный специальный файл

      Вы проверили, что аппаратные средства работают (по крайней мере
  для блока 1 ) и что для QNX определен правильный раздел.  Теперь Вы
  должны создать блочный специальный файл непосредственно для раздела
  QNX:

          mount -p /dev/hd0

       Эта команда должна создать том /dev/hd0t77 или его эквивалент.
  Если информация о разделе правильная, то это должно получиться.

       Шаг 5. Установите файловую систему QNX

       Пока Вы  еще  не  знаете  состояние файловой системы в разделе
  QNX. Ваша цель теперь выполнить утилиту chkfsys на диске, чтобы оп-
  ределить и,  возможно,  исправить файловую систему.  Но сначала Вам
  понадобится создать точку монтирования для  файловой  системы  QNX.
  Т.к.  корень  (/)  уже существует (на флоппи или на удаленном диске
  сети),  Вам следует смонтировать локальный раздел на жестком диске,
  как "только читаемую" файловую систему с именем /hd:

          mount /dev/hd0t77 /hd -r

       Выполнение команды mount зависит от состояния раздела QNX.


                               - 172 -

       ВНИМАНИЕ. Если  Вы  загрузились  с флоппи-дискеты и не знаете,
                 есть ли повреждения файловой системы на жестком дис-
                 ке  (например,  система  не  в состоянии загрузиться
                 из-за ошибки в файле загрузки  или  файле  системной
                 инициализации),  Вы можете изменить корневой префикс
                 в разделе жесткого диска следующей командой, что во-
                 зобновит нормальную работу системы:

          /hd/bin/prefix -R /=/hd/

       Если эта  команда  выполнится,  Вы можете пропустить остальную
  часть этого параграфа.

       Если команда mount не выполняется

       Если команда mount не выполняется, то вероятно повреждена пер-
  вая часть раздела QNX (т.к. Fsys не устанавливается, что говорит об
  искажении файловой системы).  В этом случае Вы можете  использовать
  утилиту dinit для форирования информации на диске,  необходимой для
  Fsys:

          dinit -hr /dev/hd0t77

       Опция -r сообщает dinit, что требуется перезаписать:
       - корневой блок;
       - битовую карту (со всеми распределенными блоками);
       - постоянные части корневого каталога.
       После этого Вам понадобится вновь создать битовую карту с  по-
  мощью  chkfsys даже в хорошем разделе.  Вам следует теперь повторно
  выдать команду mount и снова попытаться создать точку  монтирования
  для файловой системы QNX с именем /hd.

       Шаг 6. Выполните утилиту chkfsys

       Теперь по крайней мере часть Вашей файловой системы QNX должна
  быть доступна. Вы можете использовать chkfsys, чтобы проверить фай-
  ловую систему и восстановить по возможности большую часть данных.

  -------------------------------------------------------------------
     Если Вы загрузились:            введите эту команду:
  -------------------------------------------------------------------
     с флоппи-дискеты           /hd/bin/chkfsys /dev/hd0t77

     через сеть                 chkfsys /dev/hd0t77

                               - 173 -

       В каждом  случае  Вам  следует отмечать возникающие проблемы и
  позволить утилите chkfsys  отработать  до  конца.  Ваши  дальнейшие
  действия зависят от результата выполнения chkfsys.

       14.5.2. Если диск неисправен

       Если по  некоторой причине Ваш диск полностью неисправен,  чи-
  тайте следующий раздел "Восстановление потерянных файлов и  катало-
  гов".
       В некоторых случаях Вам вероятно придется вновь установить QNX
  с  флоппи-дискеты и восстановить информацию с Ваших резервных копий
  файлов. Если значительная часть файловой системы повреждена или по-
  теряны важные файлы, то восстановление с копии может быть наилучшей
  альтернативой.

       14.5.3. Если файловая система цела

       Если Ваша файловая система цела,  но машина не  загружается  с
  жесткого диска,  то вероятно повреждена:
       - программа-загрузчик раздела в физическом блоке 1;
       - программа-загрузчик QNX в первом блоке раздела QNX.
       Для того,  чтобы перезаписать программу-загрузчик раздела, ис-
  пользуйте fdisk:

          fdisk /dev/hd0 loader

       Для того,  чтобы перезаписать программу-загрузчик QNX, исполь-
  зуйте dinit:

          dinit -b /dev/hd0t77

       Теперь Вы сможете загрузить Вашу систему.

       14.6. Восстановление потерянных файлов и каталогов

       Вы обнаружили,  что  файлы  или  каталоги  полностью  потеряны
  вследствие отказа диска.  Если после выполнения chkfsys Вы узнаете,
  что определенные ключевые файлы или каталоги не были восстановлены,
  то Вы можете использовать spatch,  чтобы восстановить некоторые или
  все данные.  Перед этим Вам следует сначала подробно ознакомиться с
  организацией файловой системы QNX, описанной в этой главе в разделе
  "Обзор структуры диска QNX 4".  Следует также изучить описание ути-
  литы spatch в "Utilities Reference".


                               - 174 -

     14.6.1. Каталог lost+found

     Утилита spatch   может  скомпоновать  область  дисковых  блоков  в
  файловой    системе,   как    реальный   файл    (или   каталог),   в
  каталоге lost+found.
       Каталог lost+found должен всегда существовать на жестком диске
  и  иметь  объем по крайней мере для 126 строк.
       После использования spatch для компоновки этих частей диска  в
  каталоге lost+found, Вам следует немедленно выполнить chkfsys, что-
  бы вновь создать битовую карту  и  проверить  целостность  файловой
  системы,  которая  теперь  включает  новые  файлы.  После  того как
  chkfsys проверит диск, Вы можете переместить эти файлы (или катало-
  ги)  в  другие  каталоги  на  диске.  Рекомендуется  иметь  каталог
  lost+found пустым,  чтобы всегда была  возможность  восстанавливать
  файлы.

       14.6.2. Использование утилиты spatch

       Утилита spatch имеет специальный пункт меню Mark, который поз-
  воляет Вам задать область дисковых блоков в разделе.  Следующая ко-
  манда просматривает начальный раздел QNX:

          spatch /dev/hd0t77

       Помните, что  Вы  должны иметь соответствующие права доступа к
  блочному специальныому файлу.
       После выбора Mark, в первый раз утилита spatch отметит текущий
  дисковый блок,  как первый блок в области блоков.  Затем Вы  можете
  перейти  к последнему блоку области и выбрать Mark второй раз.  Это
  определит область блоков для spatch.
       Появившееся специальное  меню предоставит Вам следующий выбор:
       - удаление всех отметок;
       - компоновка выделенных блоков в lost+found как файл;
       - компоновка выделенных блоков в lost+found как каталог;
       - копирование выделенных блоков в файл;
       - копирование с добавлением  выделенных  блоков в файл;
       - игнорирование  второй отметки,  что позволяет выбрать другой
  блок.
       Если Вы выберете компоновку или копирование блоков в файл/ка-
  талог, то spatch предложит Вам сначала выполнить сканирование всего
  диска для поиска блоков экстентов xblk,  которые относятся  к  этой
  области блоков.  Если Вы согласитесь, то spatch выполнит сканирова-
  ние и, обнаружив блок, даст Вам возможность компоновки всех экстен-
  тов, определяемых этим блоком экстентов xblk, и с некоторыми други-

                               - 175 -

  ми,  связанными с ними xblk. Сканирование xblk позволяет восстанав-
  ливать потенциально большие дисковые файлы (или каталоги), как одно
  целое.
       Если Вы отказываетесь от сканирования для поиска xblk или  ни-
  каких  xblk  не обнаруживается,  то будет создаваться файл/каталог,
  который имеет единственный экстент,  содержащий только  эти  блоки.
       Если Вы  копируете,  то  Вам следует определить файл на другом
  диске (файловой системе).  Не забывайте  всегда  выполнять  chkfsys
  после компоновки или копирования нескольких файлов или каталогов.
.
                               - 176 -


            Глава 15. СИСТЕМА ОБНОВЛЕНИЯ ВЕРСИЙ QUANTUM

       В этой главе...

       Сообщения об ошибках
       Свободное программное обеспечение
       Электронная почта
       Система конференций
       О наших аппаратных средствах
       Как звонить нам
       Вход в систему
       Использование системы обновления версий

       ВНИМАНИЕ. В  зависимости от плана услуг поддержки,  на который
                 Вы подписываетесь,  Вы можете или не можете  пользо-
                 ваться услугами поддержки, описанными ниже.

       15.1. Введение

       Система обновления версий Quantum,  названная QUICS,  работает
  24 часа в сутки на компьютере,  с которым Вы можете связаться через
  модем, чтобы:
       - вносить исправления и изменения в операционную систему, ути-
  литы и библиотеки;
       - получать целый ряд продуктов свободнораспространяемого (сво-
  бодного) программного обеспечения из различных источников;
       - посылать электронную почту в Quantum;
       - участвовать  в  конференциях с другими пользователями QNX по
  большому кругу вопросов.

       15.2. Сообщения об ошибках

       Политика обновления программного обеспечения Quantum обеспечи-
  вает  получение  быстрого  ответа.  Например,  если Вы сообщаете об
  ошибке в утилите или библиотечной  программе,  Вы  можете  получить
  проверенную  версию в пределах часа после сообщения о проблеме.
       Мы поддерживаем самые последние версии всех программ,  включая
  модули  операционной системы.
       Кроме того,  мы обеспечиваем списком всех изменений, сделанных
  в системе. Вы можете один раз месяц обратиться к нам и получить ко-
  пию этого списка.
.
                               - 177 -

       15.3. Свободное программное обеспечение

       Мы также поддерживаем постоянно расширяющийся список свободно-
  го  программного обеспечения,  который может заинтересовать Вас.  В
  нем Вы найдете утилиты, игры и исходные тексты, предоставляемые на-
  ми и нашими клиентами.  Эти исходные тексты могут помочь Вам разоб-
  раться в некоторых "тонких" местах системы QNX.

       15.4. Электронная почта

       Вы можете использовать электронную почту для общения в частном
  порядке  со  служащими Quantum или с любым другим пользователем QU-
  ICS.

       15.5. Система конференций

       Если Вы хотите сделать сообщение или задать вопрос, который по
  Вашему  мнению  может  заинтересовать других пользователей,  то для
  этого Вы можете воспользоваться  нашей  системой  конференций.  Все
  разработчики Quantum являются участниками системы конференций,  как
  и большинство наших наиболее активных разработчиков третьей  сторо-
  ны. Полезно в пределах часа получить различные ответы и разъяснение
  по возникшим вопросам.  Вы можете найти темы по работе  в  реальном
  времени, аппаратным средствам, утилитам, языку Cи и так далее.

       15.6. О наших аппаратных средствах

       На момент  этой публикации,  компьютер QUICS поддерживает семь
  модемных линий и восемь каналов X.25 в сети коммутации пакетов  Da-
  tapac.  Все модемы поддерживают целый ряд скоростей передачи и про-
  токолов сжатия данных.
       В следующей таблице показан комплект аппаратуры,  имеющейся на
  момент этой публикации:
.
                               - 178 -

  -------------------------------------------------------------------
     Группа          Скорость          Тип             Протоколы
     поиска          передачи          модема
                     в бодах
  -------------------------------------------------------------------

     613-591-0934    38400 - 300      HST-Dual-Std    MNP5,ARQ,V42
  bis,V32
     613-591-0935    38400 - 300      HST-Dual-Std    MNP5,ARQ,V42
  bis,V32
     613-591-0940    38400 - 300      HST-Dual-Std    MNP5,ARQ,V42
  bis,V32,V32bis
     613-591-1735    38400 - 300      HST-Dual-Std    MNP5,ARQ,V42
  bis,V32,V32bis
     613-591-3009    38400 - 300      HST-Dual-Std    MNP5,ARQ,V42
  bis,V32,V32bis
     613-591-3128    19200 - 300      Telebit         MNP5,PEP,V42bis
     613-591-6093    19200 - 300      Telebit         MNP5,PEP,V42bis
  -------------------------------------------------------------------

       Модемы находятся в группе поиска со следующим начальным номе-
  ром:

      (613) 591-0934  Первый номер группы поиска.

       В системе  обновления версий мы поддерживаем новейшую конфигу-
  рацию по количеству модемов,  их типам и телефонным номерам. Вы мо-
  жете прочитать это, связавшись с нами. Для того, чтобы подключиться
  к QUICS через X.25,  Вы должны сделать предоплаченный вызов или за-
  регистрировать у нас учетный номер для X.25 (позволяющий Вам делать
  несколько вызовов). Наш сетевой адрес для X.25:

     3020   85701416
      |        |
      |        +-- Адрес Datapac Quantum
      |
      +-- Код сети Datapac

       15.7. Как звонить нам

       Т.к. qtalk поставляется с каждой системой,  мы описываем,  как
  обращаться к нам через qtalk.  Мы предполагаем, что Ваш модем подк-
  лючен к устройству QNX /dev/ser1. Если это не так, то Вы должны со-
  общить qtalk, где находится Ваш модем.

                               - 179 -

       Шаг 1. Установка параметров последовательного порта

       Установите параметры последовательного порта следующим образом:

          par=none
          bits=8

       В случае возникновения вопросов  смотрите  раздел,  в  котором
  описан  выбор  конфигурации  модемов.
       Вам следует также установить скорость передачи  в  зависимости
  от того, какую скорость Ваш модем поддерживает.

       Шаг 2. Запуск qtalk и установление связи с нами через модем

       Если Вы находитесь в Северной Америке и имеете Hayes-совмести-
  мый модем, Вы можете использовать каталог набираемых номеров qtalk.
  По  умолчанию каталог набираемых номеров /etc/config/dial.dir имеет
  файл quics,  который содержит номер телефона Quantum. Для получения
  дополнительной информации смотрите qtalk в "Utilities Reference".

          qtalk quics [-m modem]

       Опция -m  modem  необходима  только тогда,  когда Ваш модем не
  подключен к устройству /dev/ser1.

       15.8. Вход в систему

       Как только Вы успешно установили связь с QUICS,  Вас  попросят
  зарегистрироваться.  Если это Ваш первый вход в QUICS,  Вам следует
  зарегистрироваться с ID пользователя newuser.

          Login: newuser

       Затем Вас попросят ввести информацию о Вас и Вашей компании, а
  также имя,  которое Вы хотите ввести, как Ваш персональный ID поль-
  зователя.  Т.к.  имеются тысячи пользователей QUICS,  при выборе ID
  пользователя  мы  рекомендуем избегать простых имен (подобно вашему
  собственному имени). Хорошо, чтобы Ваш ID состоял из двух инициалов
  и Вашей фамилии.  Например, ID пользователя "Johann Sebastian Bach"
  будет таким:

          jsbach

       В дальнейшем, когда Вы получите доступ к QUICS, Вы будете вхо-

                               - 180 -

  дить в систему с Вашим ID пользователя (вместо newuser).

       15.9. Использование QUICS

       После входа  в  систему Вы увидите основное меню.  QUICS - это
  система,  полностью управляемая с помощью меню. Мы рекомендуем изу-
  чить систему,  чтобы использовать ее возможности.  Кстати,  одно из
  подменю позволяет Вам загрузить руководство по использованию QUICS.
  В любое время, когда Вы испытываете трудности, сделайте вызов нашей
  линии технической поддержки:

          (613) 591 0941

       Мы надеемся увидеть Вас в QUICS!
.
                               - 181 -


                                                         Приложение А

       ТЕРМИНАЛ QNX

       Введение
       Стандартный набор символов консоли
       Коды клавиатуры QNX
       Составные входные последовательности символов
       ESC-последовательности терминалов

       Введение

       QNX поддерживает  логический терминал на виртуальных консолях.
  Они могут распознавать определенные ESC-последовательности и специ-
  альные  символы,  а  также выполнять функции управления терминалом,
  когда встречаются специальные последовательности.
       Некоторые фирмы имеют еще ASCII-терминалы,  которые используют
  такой же протокол,  как и логический QNX-терминал.  Такой  терминал
  определяется в базе данных terminfo как QNX-терминал.

       Стандартный набор символов консоли

       Стандартный набор символов консоли смотрите в User's Guide Ap-
  pendix A, pages 194-195.

       Коды клавиатуры QNX

       Коды клавиатуры QNX смотрите в User's Guide Appendix A,  pages
  196- 197.

       Примечания:1. Вышеуказанным  кодам всегда предшествует 16-рич-
                     ный код FF.
                  2. Коды в диапазоне FF 21-FF 29 генерируются только
                     тогда, когда консоль находится в режиме сканиро-
                     вания (SCAN).
                  3. FF 20 генерируется только тогда,  когда  консоль
                     находится в режиме расширения (EXTENDED).



       Составные входные последовательности символов

       Составные входные   последовательности   символов  смотрите  в

                               - 182 -

  User's Guide Appendix A, page 198.

       Примечание: Для того, чтобы сгенерировать любой из этих симво-
                   лов, Вы должны:
                1) нажать и отпустить клавишу <Alt>;
                2) ввести указанную двухсимвольную последовательность.

       ESC-последовательности терминалов

       Следующие esc-последовательности и специальные символы застав-
  ляют qnx-терминал выполнять определенные управляющие функции.  ESC-
  последовательности задаются клавишей <Esc> (единицы IB h), за кото-
  рой следует набор ASCII символов. Любой другой символ, следуемый за
  <Esc>-символом,  включая <Esc>,  теряет свое значение,  как функции
  управления,  и просто отображается на экране,  как графический сим-
  вол.
     В  следующей таблице  пробелы включаются в esc-последовательности,
  чтобы  сделать их  более  читаемыми,  эти  пробелы  действительно  не
  входят в последовательности.

  -------------------------------------------------------------------
                 Если Вы хотите:                         используйте:
  -------------------------------------------------------------------
  Установка      включить инверсный видеорежим (если тер-
  атрибутов      минал - цветной, это также меняет опера-  <Esc>(
                 тивные и фоновые цвета,  устанавливаемые
                 последовательностью <Esc> @)

                 выключить инверсный видеорежим            <Esc>)

                 включить режим подчеркивания (возможен
                 только для черно-белых мониторов)         <Esc> [

                 выключить режим подчеркивания             <Esc> ]

                 включить мерцающий режим                  <Esc> {

                 выключить мерцающий режим                 <Esc> }

                 включить режим высокой интенсивности      <Esc> <

                 выключить режим высокой интенсивности     <Esc> >

  Определение и  определить тип курсора, где c - тип кур-  <Esc> Y c

                               - 183 -

  -------------------------------------------------------------------
                 Если Вы хотите:                         используйте:
  -------------------------------------------------------------------
  перемещение    сора (ASCII символ 0 -определяет отсутс-
  курсора        твие курсора, 1 - нормальный курсор и 2
                 - блочный курсор)

                 установить курсор на экране  в  точке c   <Esc> = r c
                 координатами r и c, где r - колонка и c     или
                 - столбец; как r, так и c - смещение до    <Esc> Y r c
                 20 h (пробел). Следовательно, rc=<space>
                 <space> - нулевая колонка, нулевой стол-
                 бец.

                 переместить курсор вверх на одну строку   <Esc> A
                 без перемещениятекста или прокрутки

                 переместить курсор вниз на одну строку
                 без перемещения текста или прокрутки      <Esc> B

                 переместить курсор вниз на одну строку    LF (0A h)
                 (если курсор находится в последней стро-
                 ке экрана, экран перемещается по одной
                 строке вверх)

                 переместить курсор вправо на один стол-   <Esc> C
                 бец без перемещения текста

                 переместить курсор влево на один столбец
                 без перемещения  текста                   <Esc> D

                 переместить курсор в верхний левый угол
                 экрана                                    <Esc> H

                 включить автоматическое перемещение тек-
                 ста строки                                <Esc> h

                 выключить автоматическое перемещение те-
                 кста строки                                <Esc> i

                 переместить курсор вверх с перемещением
                 текста строки                              <Esc> a

                 переместить курсор вниз с перемещением

                               - 184 -

  -------------------------------------------------------------------
                 Если Вы хотите:                         используйте:
  -------------------------------------------------------------------
                 текста строки                              <Esc> b

                 переместить курсор вправо с перемещением
                 текста строки                              <Esc> c

                 переместить курсор влево с перемещением
                 текста строки                              <Esc> d

                 изменить прогон строк на обратный (когда
                 курсор находится в верхней строке экрана,  <Esc> I
                 экран перемещается вниз)

                 переместить курсор в первый столбец те-
                 кущей строки                               CR (0D h)

                 ввести неразделимый пробел (если пробел    BC (08 h)
                 - в начале строки, она присоединяется к
                 предыдущей строке, если пробел - в верх-
                 нем левом углу экрана,  первая строка
                 присоединяется к последней)


  Вставка,       вставить строку в позиции курсора          <Esc> E
  удаление
  и очищение     удалить строку в позиции курсора           <Esc> F

                 очистить до конца экрана (заполнить про-   <Esc> J
                 белами) (на цветных терминалах использу-
                 ется цвет заполнения, определяемый пос-
                 ледовательностью <Esc>!)

                 очистить до конца строки (заполнить про-   <Esc> K
                 белами) (на цветных терминалах использу-
                 ется цвет заполнения, определяемый
                 <Esc>!)

                очистить весь экран (заполнить пробелами)   FF (OC h)
                (используется цвет заполнения, определяе-
                мый <Esc>! и курсор перемещается в верх-
                ний левый угол)


                               - 185 -

  -------------------------------------------------------------------
              Если Вы хотите:                            используйте:
  -------------------------------------------------------------------
                вставить пробел в позицию курсора           <Esc> e

                удалить символ в позиции курсора            <Esc> f

                повторить символ c n раз, где n - целое     <Esc> g n c
                от 0 до 20

  Сохранение  сохранить цвет и атрибуты. (Производится      <Esc> S
  атрибутов   замещение сохраненной  прежде информации;
              позиция курсора не сохраняется. QNX-програ-
              ммы, как например, редакторы, которые изме-
              няют цвета, предполагают, что значение по
              умолчанию установлено при входе, и исполь-
              зуют <Esc> R, чтобы восстановить значение
              по умолчанию при выходе)

              восстановить цвет и атрибуты, сохраненные     <Esc> R
              по <Esc> S (позиция курсора не меняется)

  Установка   определить цвет текста и цвет фона при ото-   <Esc> @ fc bc
  символов,   бражении, где fc- цвет курсора и bc -  цвет
  цвета       заполнения (как fc, так и bc представлены
              одним символом, взятым из таблицы цветов
              ниже). Это не имеет значения для черно-бело-
              го терминала или дисплея.

              установить цвет заполнения, который исполь-   <Esc>! fc bc
              зуется как для пустых строк, создаваемых
              скроллингом, так и для всего экрана при
              очистке с прогоном страницы. Это не имеет
              значения для черно-белого терминала или
              дисплея.

  Генерация   сгенерировать короткий тон на системной кон-  BELL (07 h)
  оттенка     соли или звонок на терминале
  -------------------------------------------------------------------

       Коды цветов

       Вы можете использовать эти коды цветов в вышеуказанных esc-пос-
  ледовательностях:


                               - 186 -

        Цвет           Символ ASCII

        черный             0
        синий              1
        зеленый            2
        голубой            3
        красный            4
        красный анилиновый 5
        коричневый         6
        белый              7

.
                               - 187 -


                                                         Приложение B

                       ПРАВИЛА ЧАСОВЫХ ПОЯСОВ

       Это приложение  описывает  различные правила,  применяемые для
  установки часовых поясов и изменения времени  (например,  установка
  летнего времени).
       Таблицу часовых поясов* и карту смотрите в User's  Guide,  Ap-
  pendix B.
       Информация о часовых поясах задается через внешнюю  переменную
  TZ. Эта переменная содержит закодированную строку, которая позволя-
  ет Вам определять часовой пояс,  а также правила  для  перехода  на
  летнее время (если оно вводится в Вашей области).  TZ имеет следую-
  щую структуру (пробелы включены для ясности):

       std offset dst offset, rule

  где:

       std   cтандартное время
       offset смещение стандартного времени от времени по Гринвичу
       dst   летнее время
       offset смещения летнего времени от от времени по Гринвичу
       rule  правила перехода на летнее время

       Более подробно TZ кодируется следующим образом:

       TZ=std[offset[dst[offset] [,start[/time] , end[/time]]]]

       Компоненты строки внешней переменной TZ определяются следующим
  образом:

       std and(и?)  dst  содержит  строку,  определяющую часовой пояс
  (например, EST). Разрешены все символы за исключением:
                ведущих двоеточий (:)
                цифр
                запятой (,)
                знака минус (-)
                знака плюс (+),
                нуля ASCII
       std содержит имя пояса со стандартным временем, а dst содержит
  имя пояса с летним временем.
       Если dst  отсутствует, то в этой местности летнее время не ис-

                               - 188 -

  пользуется.

       offset задает величину, которую Вы должны добавить к локально-
  му времени, чтобы получить время по Гринвичу.
       Форма для offset:

                HH[:MM[:SS]]
       Минуты MM и секунды SS задавать не обязательно. Часы HH требу-
  ются и могут быть заданы одной цифрой. Часы определяются в пределах
  от 0 до 24.  Вы можете определить минуты и секунды, если требуется,
  в пределах от 0 до 59. Время в часовых поясах к востоку от Нулевого
  Меридиана (проходящего  через Англию) должно быть указано со знаком
  (-). Время в часовых поясах к западу от Нулевого  Меридиана  должно
  быть указано со знаком (+).
       Offset, следующее за std,  необходимо, но offset, следующее за
  dst,  может  быть опущено.  В этом случае летнее время считается на
  один час впереди стандартного времени.

       ВНИМАНИЕ. Имейте в виду, что стандарт POSIX отличается от сог-
                 лашения,  использованного в  международных  таблицах
                 времени,  для  определения  смещения  от  времени по
                 Гринвичу. В большинстве таблиц часовых поясов и кар-
                 тах смещениям  к востоку от Нулевого Меридиана пред-
                 шествует +, а к западу предшествует -. Вам, следова-
                 тельно, следует инвертировать знак чисел, которые Вы
                 берете из таблицы или карты, приведенных в этом при-
                 ложении.  Например,  время  на востоке U.S.A.  будет
                 равно +5, когда в Японии будет -9.

    * Таблица часовых поясов выбрана из Высшего Руководства полетов -
      Всемирное Издание (May 1992,  Vol.  17,  No.  3 pp. 1408-1409),
      публикуемый Руководствами Официальных Авиалиний, Inc., Oak Bro-
      ok, Illinois.

     rool определяет,  когда происходит  переход на  летнее время  и
  возврат назад. Если rool не определено, то QNX принимает, что стан-
  дартное время не меняется. rool имеет следующий формат:

                дата/время, дата/время

             где первая дата определяет дату перехода на летнее  вре-
  мя, а вторая дата определяет,  когда происходит возврат к стандарт-
  ному времени.
       Поля время определяют точное время,  когда происходит переход.

                               - 189 -

       Поле дата имеет один из следующих форматов:

       J 4n 0 определяет дату,  как день  по  Юлианскому  календарю,  где
  1 7, 0n 7, 0365.
       Этот формат не позволяет задать все дни (например,  28 февраля
  -  59-й  день и 1 марта - 60-й день;невозможно определить 29 февра-
  ля).

       n определяет дату,  как день по Юлианскому календарю, начинаю-
  щийся с 0, где  0 67 7, 0n 7, 0365. Все  дни считаются,  и Вы  можете определить
  29 февраля.

       Mm w d Это определяет день (0 7, 0d 7, 06)  недели  w  месяца  m  года
  (1 7, 0w 7, 05, 1 7, 0m 7, 012,  где 5 недель, так как последний день d в месяце m,
  может появиться как на четвертой,  так и на пятой неделе). Неделя 1
  - первая  неделя  месяца m,  в которой появляется день d.  День 0 -
  воскресенье. Время имеет тот же самый формат, что и offset, за иск-
  лючением знака (+ или -).  Если время не определено, то значение по
  умолчанию равно 02:00:00.

       ВНИМАНИЕ. Так как стандарт POSIX не соответствует  соглашению,
                 принятому в международных картах времени для задания
                 смещений от времени по Гринвичу, не забывайте инвер-
                 тировать знак числа, взятого из этой карты.
